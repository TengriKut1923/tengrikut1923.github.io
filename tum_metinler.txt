
--------------------------------------------------------------------------------
FILE: adjacent-overload-signatures.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"adjacentSignature", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: adjacent-overload-signatures.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'adjacent-overload-signatures',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require that function overload signatures be consecutive',
            recommended: 'stylistic',
        },
        messages: {
            adjacentSignature: 'All {{name}} signatures should be adjacent.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        /**
         * Gets the name and attribute of the member being processed.
         * @param member the member being processed.
         * @returns the name and attribute of the member or null if it's a member not relevant to the rule.
         */
        function getMemberMethod(member) {
            switch (member.type) {
                case utils_1.AST_NODE_TYPES.ExportDefaultDeclaration:
                case utils_1.AST_NODE_TYPES.ExportNamedDeclaration: {
                    // export statements (e.g. export { a };)
                    // have no declarations, so ignore them
                    if (!member.declaration) {
                        return null;
                    }
                    return getMemberMethod(member.declaration);
                }
                case utils_1.AST_NODE_TYPES.TSDeclareFunction:
                case utils_1.AST_NODE_TYPES.FunctionDeclaration: {
                    const name = member.id?.name ?? null;
                    if (name == null) {
                        return null;
                    }
                    return {
                        name,
                        type: util_1.MemberNameType.Normal,
                        callSignature: false,
                    };
                }
                case utils_1.AST_NODE_TYPES.TSMethodSignature:
                case utils_1.AST_NODE_TYPES.MethodDefinition:
                    return {
                        ...(0, util_1.getNameFromMember)(member, context.sourceCode),
                        callSignature: false,
                        static: member.static,
                    };
                case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:
                    return {
                        name: 'call',
                        type: util_1.MemberNameType.Normal,
                        callSignature: true,
                    };
                case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:
                    return {
                        name: 'new',
                        type: util_1.MemberNameType.Normal,
                        callSignature: false,
                    };
            }
            return null;
        }
        function isSameMethod(method1, method2) {
            return (!!method2 &&
                method1.name === method2.name &&
                method1.static === method2.static &&
                method1.callSignature === method2.callSignature &&
                method1.type === method2.type);
        }
        function getMembers(node) {
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.ClassBody:
                case utils_1.AST_NODE_TYPES.Program:
                case utils_1.AST_NODE_TYPES.TSModuleBlock:
                case utils_1.AST_NODE_TYPES.TSInterfaceBody:
                case utils_1.AST_NODE_TYPES.BlockStatement:
                    return node.body;
                case utils_1.AST_NODE_TYPES.TSTypeLiteral:
                    return node.members;
            }
        }
        function checkBodyForOverloadMethods(node) {
            const members = getMembers(node);
            let lastMethod = null;
            const seenMethods = [];
            members.forEach(member => {
                const method = getMemberMethod(member);
                if (method == null) {
                    lastMethod = null;
                    return;
                }
                const index = seenMethods.findIndex(seenMethod => isSameMethod(method, seenMethod));
                if (index > -1 && !isSameMethod(method, lastMethod)) {
                    context.report({
                        node: member,
                        messageId: 'adjacentSignature',
                        data: {
                            name: `${method.static ? 'static ' : ''}${method.name}`,
                        },
                    });
                }
                else if (index === -1) {
                    seenMethods.push(method);
                }
                lastMethod = method;
            });
        }
        return {
            BlockStatement: checkBodyForOverloadMethods,
            ClassBody: checkBodyForOverloadMethods,
            Program: checkBodyForOverloadMethods,
            TSInterfaceBody: checkBodyForOverloadMethods,
            TSModuleBlock: checkBodyForOverloadMethods,
            TSTypeLiteral: checkBodyForOverloadMethods,
        };
    },
});


--------------------------------------------------------------------------------
FILE: array-type.d.ts
--------------------------------------------------------------------------------

export type OptionString = 'array' | 'array-simple' | 'generic';
export type Options = [
    {
        default: OptionString;
        readonly?: OptionString;
    }
];
export type MessageIds = 'errorStringArray' | 'errorStringArrayReadonly' | 'errorStringArraySimple' | 'errorStringArraySimpleReadonly' | 'errorStringGeneric' | 'errorStringGenericSimple';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: array-type.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
/**
 * Check whatever node can be considered as simple
 * @param node the node to be evaluated.
 */
function isSimpleType(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.Identifier:
        case utils_1.AST_NODE_TYPES.TSAnyKeyword:
        case utils_1.AST_NODE_TYPES.TSBooleanKeyword:
        case utils_1.AST_NODE_TYPES.TSNeverKeyword:
        case utils_1.AST_NODE_TYPES.TSNumberKeyword:
        case utils_1.AST_NODE_TYPES.TSBigIntKeyword:
        case utils_1.AST_NODE_TYPES.TSObjectKeyword:
        case utils_1.AST_NODE_TYPES.TSStringKeyword:
        case utils_1.AST_NODE_TYPES.TSSymbolKeyword:
        case utils_1.AST_NODE_TYPES.TSUnknownKeyword:
        case utils_1.AST_NODE_TYPES.TSVoidKeyword:
        case utils_1.AST_NODE_TYPES.TSNullKeyword:
        case utils_1.AST_NODE_TYPES.TSArrayType:
        case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
        case utils_1.AST_NODE_TYPES.TSThisType:
        case utils_1.AST_NODE_TYPES.TSQualifiedName:
            return true;
        case utils_1.AST_NODE_TYPES.TSTypeReference:
            if (node.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.typeName.name === 'Array') {
                if (!node.typeArguments) {
                    return true;
                }
                if (node.typeArguments.params.length === 1) {
                    return isSimpleType(node.typeArguments.params[0]);
                }
            }
            else {
                if (node.typeArguments) {
                    return false;
                }
                return isSimpleType(node.typeName);
            }
            return false;
        default:
            return false;
    }
}
/**
 * Check if node needs parentheses
 * @param node the node to be evaluated.
 */
function typeNeedsParentheses(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSTypeReference:
            return typeNeedsParentheses(node.typeName);
        case utils_1.AST_NODE_TYPES.TSUnionType:
        case utils_1.AST_NODE_TYPES.TSFunctionType:
        case utils_1.AST_NODE_TYPES.TSIntersectionType:
        case utils_1.AST_NODE_TYPES.TSTypeOperator:
        case utils_1.AST_NODE_TYPES.TSInferType:
        case utils_1.AST_NODE_TYPES.TSConstructorType:
        case utils_1.AST_NODE_TYPES.TSConditionalType:
            return true;
        case utils_1.AST_NODE_TYPES.Identifier:
            return node.name === 'ReadonlyArray';
        default:
            return false;
    }
}
exports.default = (0, util_1.createRule)({
    name: 'array-type',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require consistently using either `T[]` or `Array<T>` for arrays',
            recommended: 'stylistic',
        },
        fixable: 'code',
        messages: {
            errorStringArray: "Array type using '{{className}}<{{type}}>' is forbidden. Use '{{readonlyPrefix}}{{type}}[]' instead.",
            errorStringArrayReadonly: "Array type using '{{className}}<{{type}}>' is forbidden. Use '{{readonlyPrefix}}{{type}}' instead.",
            errorStringArraySimple: "Array type using '{{className}}<{{type}}>' is forbidden for simple types. Use '{{readonlyPrefix}}{{type}}[]' instead.",
            errorStringArraySimpleReadonly: "Array type using '{{className}}<{{type}}>' is forbidden for simple types. Use '{{readonlyPrefix}}{{type}}' instead.",
            errorStringGeneric: "Array type using '{{readonlyPrefix}}{{type}}[]' is forbidden. Use '{{className}}<{{type}}>' instead.",
            errorStringGenericSimple: "Array type using '{{readonlyPrefix}}{{type}}[]' is forbidden for non-simple types. Use '{{className}}<{{type}}>' instead.",
        },
        schema: [
            {
                type: 'object',
                $defs: {
                    arrayOption: {
                        type: 'string',
                        enum: ['array', 'generic', 'array-simple'],
                    },
                },
                additionalProperties: false,
                properties: {
                    default: {
                        $ref: '#/items/0/$defs/arrayOption',
                        description: 'The array type expected for mutable cases.',
                    },
                    readonly: {
                        $ref: '#/items/0/$defs/arrayOption',
                        description: 'The array type expected for readonly cases. If omitted, the value for `default` will be used.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            default: 'array',
        },
    ],
    create(context, [options]) {
        const defaultOption = options.default;
        const readonlyOption = options.readonly ?? defaultOption;
        /**
         * @param node the node to be evaluated.
         */
        function getMessageType(node) {
            if (isSimpleType(node)) {
                return context.sourceCode.getText(node);
            }
            return 'T';
        }
        return {
            TSArrayType(node) {
                const isReadonly = node.parent.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&
                    node.parent.operator === 'readonly';
                const currentOption = isReadonly ? readonlyOption : defaultOption;
                if (currentOption === 'array' ||
                    (currentOption === 'array-simple' && isSimpleType(node.elementType))) {
                    return;
                }
                const messageId = currentOption === 'generic'
                    ? 'errorStringGeneric'
                    : 'errorStringGenericSimple';
                const errorNode = isReadonly ? node.parent : node;
                context.report({
                    node: errorNode,
                    messageId,
                    data: {
                        type: getMessageType(node.elementType),
                        className: isReadonly ? 'ReadonlyArray' : 'Array',
                        readonlyPrefix: isReadonly ? 'readonly ' : '',
                    },
                    fix(fixer) {
                        const typeNode = node.elementType;
                        const arrayType = isReadonly ? 'ReadonlyArray' : 'Array';
                        return [
                            fixer.replaceTextRange([errorNode.range[0], typeNode.range[0]], `${arrayType}<`),
                            fixer.replaceTextRange([typeNode.range[1], errorNode.range[1]], '>'),
                        ];
                    },
                });
            },
            TSTypeReference(node) {
                if (node.typeName.type !== utils_1.AST_NODE_TYPES.Identifier ||
                    !(node.typeName.name === 'Array' ||
                        node.typeName.name === 'ReadonlyArray' ||
                        node.typeName.name === 'Readonly') ||
                    (node.typeName.name === 'Readonly' &&
                        node.typeArguments?.params[0].type !== utils_1.AST_NODE_TYPES.TSArrayType)) {
                    return;
                }
                const isReadonlyWithGenericArrayType = node.typeName.name === 'Readonly' &&
                    node.typeArguments?.params[0].type === utils_1.AST_NODE_TYPES.TSArrayType;
                const isReadonlyArrayType = node.typeName.name === 'ReadonlyArray' ||
                    isReadonlyWithGenericArrayType;
                const currentOption = isReadonlyArrayType
                    ? readonlyOption
                    : defaultOption;
                if (currentOption === 'generic') {
                    return;
                }
                const readonlyPrefix = isReadonlyArrayType ? 'readonly ' : '';
                const typeParams = node.typeArguments?.params;
                const messageId = currentOption === 'array'
                    ? isReadonlyWithGenericArrayType
                        ? 'errorStringArrayReadonly'
                        : 'errorStringArray'
                    : isReadonlyArrayType && node.typeName.name !== 'ReadonlyArray'
                        ? 'errorStringArraySimpleReadonly'
                        : 'errorStringArraySimple';
                if (!typeParams) {
                    // Create an 'any' array
                    context.report({
                        node,
                        messageId,
                        data: {
                            type: 'any',
                            className: isReadonlyArrayType ? 'ReadonlyArray' : 'Array',
                            readonlyPrefix,
                        },
                        fix(fixer) {
                            return fixer.replaceText(node, `${readonlyPrefix}any[]`);
                        },
                    });
                    return;
                }
                if (typeParams.length !== 1 ||
                    (currentOption === 'array-simple' && !isSimpleType(typeParams[0]))) {
                    return;
                }
                const type = typeParams[0];
                const typeParens = typeNeedsParentheses(type);
                const parentParens = readonlyPrefix &&
                    node.parent.type === utils_1.AST_NODE_TYPES.TSArrayType &&
                    !(0, util_1.isParenthesized)(node.parent.elementType, context.sourceCode);
                const start = `${parentParens ? '(' : ''}${readonlyPrefix}${typeParens ? '(' : ''}`;
                const end = `${typeParens ? ')' : ''}${isReadonlyWithGenericArrayType ? '' : `[]`}${parentParens ? ')' : ''}`;
                context.report({
                    node,
                    messageId,
                    data: {
                        type: getMessageType(type),
                        className: isReadonlyArrayType ? node.typeName.name : 'Array',
                        readonlyPrefix,
                    },
                    fix(fixer) {
                        return [
                            fixer.replaceTextRange([node.range[0], type.range[0]], start),
                            fixer.replaceTextRange([type.range[1], node.range[1]], end),
                        ];
                    },
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: await-thenable.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageId = 'await' | 'awaitUsingOfNonAsyncDisposable' | 'convertToOrdinaryFor' | 'forAwaitOfNonAsyncIterable' | 'invalidPromiseAggregatorInput' | 'removeAwait';
declare const _default: TSESLint.RuleModule<MessageId, [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: await-thenable.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
const getForStatementHeadLoc_1 = require("../util/getForStatementHeadLoc");
const isPromiseAggregatorMethod_1 = require("../util/isPromiseAggregatorMethod");
exports.default = (0, util_1.createRule)({
    name: 'await-thenable',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow awaiting a value that is not a Thenable',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            await: 'Unexpected `await` of a non-Promise (non-"Thenable") value.',
            awaitUsingOfNonAsyncDisposable: 'Unexpected `await using` of a value that is not async disposable.',
            convertToOrdinaryFor: 'Convert to an ordinary `for...of` loop.',
            forAwaitOfNonAsyncIterable: 'Unexpected `for await...of` of a value that is not async iterable.',
            invalidPromiseAggregatorInput: 'Unexpected iterable of non-Promise (non-"Thenable") values passed to promise aggregator.',
            removeAwait: 'Remove unnecessary `await`.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        return {
            AwaitExpression(node) {
                const awaitArgumentEsNode = node.argument;
                const awaitArgumentType = services.getTypeAtLocation(awaitArgumentEsNode);
                const awaitArgumentTsNode = services.esTreeNodeToTSNodeMap.get(awaitArgumentEsNode);
                const certainty = (0, util_1.needsToBeAwaited)(checker, awaitArgumentTsNode, awaitArgumentType);
                if (certainty === util_1.Awaitable.Never) {
                    context.report({
                        node,
                        messageId: 'await',
                        suggest: [
                            {
                                messageId: 'removeAwait',
                                fix(fixer) {
                                    const awaitKeyword = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isAwaitKeyword), util_1.NullThrowsReasons.MissingToken('await', 'await expression'));
                                    return fixer.remove(awaitKeyword);
                                },
                            },
                        ],
                    });
                }
            },
            CallExpression(node) {
                if (!(0, isPromiseAggregatorMethod_1.isPromiseAggregatorMethod)(context, services, node)) {
                    return;
                }
                const argument = node.arguments.at(0);
                if (argument == null) {
                    return;
                }
                if (argument.type === utils_1.TSESTree.AST_NODE_TYPES.ArrayExpression) {
                    for (const element of argument.elements) {
                        if (element == null) {
                            continue;
                        }
                        const type = (0, util_1.getConstrainedTypeAtLocation)(services, element);
                        const tsNode = services.esTreeNodeToTSNodeMap.get(element);
                        if (isAlwaysNonAwaitableType(type, tsNode, checker)) {
                            context.report({
                                node: element,
                                messageId: 'invalidPromiseAggregatorInput',
                            });
                        }
                    }
                    return;
                }
                const type = (0, util_1.getConstrainedTypeAtLocation)(services, argument);
                if (isInvalidPromiseAggregatorInput(checker, services.esTreeNodeToTSNodeMap.get(argument), type)) {
                    context.report({
                        node: argument,
                        messageId: 'invalidPromiseAggregatorInput',
                    });
                }
            },
            'ForOfStatement[await=true]'(node) {
                const type = services.getTypeAtLocation(node.right);
                if ((0, util_1.isTypeAnyType)(type)) {
                    return;
                }
                const hasAsyncIteratorSymbol = tsutils
                    .unionConstituents(type)
                    .some(typePart => tsutils.getWellKnownSymbolPropertyOfType(typePart, 'asyncIterator', checker) != null);
                if (!hasAsyncIteratorSymbol) {
                    context.report({
                        loc: (0, getForStatementHeadLoc_1.getForStatementHeadLoc)(context.sourceCode, node),
                        messageId: 'forAwaitOfNonAsyncIterable',
                        suggest: [
                            // Note that this suggestion causes broken code for sync iterables
                            // of promises, since the loop variable is not awaited.
                            {
                                messageId: 'convertToOrdinaryFor',
                                fix(fixer) {
                                    const awaitToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isAwaitKeyword), util_1.NullThrowsReasons.MissingToken('await', 'for await loop'));
                                    return fixer.remove(awaitToken);
                                },
                            },
                        ],
                    });
                }
            },
            'VariableDeclaration[kind="await using"]'(node) {
                for (const declarator of node.declarations) {
                    const init = declarator.init;
                    if (init == null) {
                        continue;
                    }
                    const type = services.getTypeAtLocation(init);
                    if ((0, util_1.isTypeAnyType)(type)) {
                        continue;
                    }
                    const hasAsyncDisposeSymbol = tsutils
                        .unionConstituents(type)
                        .some(typePart => tsutils.getWellKnownSymbolPropertyOfType(typePart, 'asyncDispose', checker) != null);
                    if (!hasAsyncDisposeSymbol) {
                        context.report({
                            node: init,
                            messageId: 'awaitUsingOfNonAsyncDisposable',
                            // let the user figure out what to do if there's
                            // await using a = b, c = d, e = f;
                            // it's rare and not worth the complexity to handle.
                            ...(0, util_1.getFixOrSuggest)({
                                fixOrSuggest: node.declarations.length === 1 ? 'suggest' : 'none',
                                suggestion: {
                                    messageId: 'removeAwait',
                                    fix(fixer) {
                                        const awaitToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isAwaitKeyword), util_1.NullThrowsReasons.MissingToken('await', 'await using'));
                                        return fixer.remove(awaitToken);
                                    },
                                },
                            }),
                        });
                    }
                }
            },
        };
    },
});
function isInvalidPromiseAggregatorInput(checker, node, type) {
    // non array/tuple/iterable types already show up as a type error
    if (!isIterable(type, checker)) {
        return false;
    }
    for (const part of tsutils.unionConstituents(type)) {
        const valueTypes = getValueTypesOfArrayLike(part, checker);
        if (valueTypes != null) {
            for (const typeArgument of valueTypes) {
                if (containsNonAwaitableType(typeArgument, node, checker)) {
                    return true;
                }
            }
        }
    }
    return false;
}
function getValueTypesOfArrayLike(type, checker) {
    if (checker.isTupleType(type)) {
        return checker.getTypeArguments(type);
    }
    if (checker.isArrayLikeType(type)) {
        return [
            (0, util_1.nullThrows)(type.getNumberIndexType(), 'number index type should exist on an array-like'),
        ];
    }
    // `Iterable<...>`
    if (tsutils.isTypeReference(type)) {
        return checker.getTypeArguments(type).slice(0, 1);
    }
    return null;
}
function isAlwaysNonAwaitableType(type, node, checker) {
    return tsutils
        .unionConstituents(type)
        .every(typeArgumentPart => (0, util_1.needsToBeAwaited)(checker, node, typeArgumentPart) === util_1.Awaitable.Never);
}
function containsNonAwaitableType(type, node, checker) {
    return tsutils
        .unionConstituents(type)
        .some(typeArgumentPart => (0, util_1.needsToBeAwaited)(checker, node, typeArgumentPart) === util_1.Awaitable.Never);
}
function isIterable(type, checker) {
    return tsutils
        .unionConstituents(type)
        .every(part => !!tsutils.getWellKnownSymbolPropertyOfType(part, 'iterator', checker));
}


--------------------------------------------------------------------------------
FILE: ban-ts-comment.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type DirectiveConfig = boolean | 'allow-with-description' | {
    descriptionFormat: string;
};
export interface OptionsShape {
    minimumDescriptionLength?: number;
    'ts-check'?: DirectiveConfig;
    'ts-expect-error'?: DirectiveConfig;
    'ts-ignore'?: DirectiveConfig;
    'ts-nocheck'?: DirectiveConfig;
}
export type Options = [OptionsShape];
export type MessageIds = 'replaceTsIgnoreWithTsExpectError' | 'tsDirectiveComment' | 'tsDirectiveCommentDescriptionNotMatchPattern' | 'tsDirectiveCommentRequiresDescription' | 'tsIgnoreInsteadOfExpectError';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: ban-ts-comment.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const defaultMinimumDescriptionLength = 3;
exports.default = (0, util_1.createRule)({
    name: 'ban-ts-comment',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow `@ts-<directive>` comments or require descriptions after directives',
            recommended: {
                recommended: true,
                strict: [{ minimumDescriptionLength: 10 }],
            },
        },
        hasSuggestions: true,
        messages: {
            replaceTsIgnoreWithTsExpectError: 'Replace "@ts-ignore" with "@ts-expect-error".',
            tsDirectiveComment: 'Do not use "@ts-{{directive}}" because it alters compilation errors.',
            tsDirectiveCommentDescriptionNotMatchPattern: 'The description for the "@ts-{{directive}}" directive must match the {{format}} format.',
            tsDirectiveCommentRequiresDescription: 'Include a description after the "@ts-{{directive}}" directive to explain why the @ts-{{directive}} is necessary. The description must be {{minimumDescriptionLength}} characters or longer.',
            tsIgnoreInsteadOfExpectError: 'Use "@ts-expect-error" instead of "@ts-ignore", as "@ts-ignore" will do nothing if the following line is error-free.',
        },
        schema: [
            {
                type: 'object',
                $defs: {
                    directiveConfigSchema: {
                        oneOf: [
                            {
                                type: 'boolean',
                                default: true,
                            },
                            {
                                type: 'string',
                                enum: ['allow-with-description'],
                            },
                            {
                                type: 'object',
                                additionalProperties: false,
                                properties: {
                                    descriptionFormat: { type: 'string' },
                                },
                            },
                        ],
                    },
                },
                additionalProperties: false,
                properties: {
                    minimumDescriptionLength: {
                        type: 'number',
                        description: 'A minimum character length for descriptions when `allow-with-description` is enabled.',
                    },
                    'ts-check': {
                        $ref: '#/items/0/$defs/directiveConfigSchema',
                        description: 'Whether allow ts-check directives, and with which restrictions.',
                    },
                    'ts-expect-error': {
                        $ref: '#/items/0/$defs/directiveConfigSchema',
                        description: 'Whether and when expect-error directives, and with which restrictions.',
                    },
                    'ts-ignore': {
                        $ref: '#/items/0/$defs/directiveConfigSchema',
                        description: 'Whether allow ts-ignore directives, and with which restrictions.',
                    },
                    'ts-nocheck': {
                        $ref: '#/items/0/$defs/directiveConfigSchema',
                        description: 'Whether allow ts-nocheck directives, and with which restrictions.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            minimumDescriptionLength: defaultMinimumDescriptionLength,
            'ts-check': false,
            'ts-expect-error': 'allow-with-description',
            'ts-ignore': true,
            'ts-nocheck': true,
        },
    ],
    create(context, [options]) {
        // https://github.com/microsoft/TypeScript/blob/6f1ad5ad8bec5671f7e951a3524b62d82ec4be68/src/compiler/parser.ts#L10591
        const singleLinePragmaRegEx = /^\/\/\/?\s*@ts-(?<directive>check|nocheck)(?<description>.*)$/;
        /*
          The regex used are taken from the ones used in the official TypeScript repo -
          https://github.com/microsoft/TypeScript/blob/6f1ad5ad8bec5671f7e951a3524b62d82ec4be68/src/compiler/scanner.ts#L340-L348
        */
        const commentDirectiveRegExSingleLine = /^\/*\s*@ts-(?<directive>expect-error|ignore)(?<description>.*)/;
        const commentDirectiveRegExMultiLine = /^\s*(?:\/|\*)*\s*@ts-(?<directive>expect-error|ignore)(?<description>.*)/;
        const descriptionFormats = new Map();
        for (const directive of [
            'ts-expect-error',
            'ts-ignore',
            'ts-nocheck',
            'ts-check',
        ]) {
            const option = options[directive];
            if (typeof option === 'object' && option.descriptionFormat) {
                descriptionFormats.set(directive, new RegExp(option.descriptionFormat));
            }
        }
        function execDirectiveRegEx(regex, str) {
            const match = regex.exec(str);
            if (!match) {
                return null;
            }
            const { description, directive } = (0, util_1.nullThrows)(match.groups, 'RegExp should contain groups');
            return {
                description: (0, util_1.nullThrows)(description, 'RegExp should contain "description" group'),
                directive: (0, util_1.nullThrows)(directive, 'RegExp should contain "directive" group'),
            };
        }
        function findDirectiveInComment(comment) {
            if (comment.type === utils_1.AST_TOKEN_TYPES.Line) {
                const matchedPragma = execDirectiveRegEx(singleLinePragmaRegEx, `//${comment.value}`);
                if (matchedPragma) {
                    return matchedPragma;
                }
                return execDirectiveRegEx(commentDirectiveRegExSingleLine, comment.value);
            }
            const commentLines = comment.value.split('\n');
            return execDirectiveRegEx(commentDirectiveRegExMultiLine, commentLines[commentLines.length - 1]);
        }
        return {
            Program(node) {
                const firstStatement = node.body.at(0);
                const comments = context.sourceCode.getAllComments();
                comments.forEach(comment => {
                    const match = findDirectiveInComment(comment);
                    if (!match) {
                        return;
                    }
                    const { description, directive } = match;
                    if (directive === 'nocheck' &&
                        firstStatement &&
                        firstStatement.loc.start.line <= comment.loc.start.line) {
                        return;
                    }
                    const fullDirective = `ts-${directive}`;
                    const option = options[fullDirective];
                    if (option === true) {
                        if (directive === 'ignore') {
                            // Special case to suggest @ts-expect-error instead of @ts-ignore
                            context.report({
                                node: comment,
                                messageId: 'tsIgnoreInsteadOfExpectError',
                                suggest: [
                                    {
                                        messageId: 'replaceTsIgnoreWithTsExpectError',
                                        fix(fixer) {
                                            const commentText = comment.value.replace(/@ts-ignore/, '@ts-expect-error');
                                            return fixer.replaceText(comment, comment.type === utils_1.AST_TOKEN_TYPES.Line
                                                ? `//${commentText}`
                                                : `/*${commentText}*/`);
                                        },
                                    },
                                ],
                            });
                        }
                        else {
                            context.report({
                                node: comment,
                                messageId: 'tsDirectiveComment',
                                data: { directive },
                            });
                        }
                    }
                    if (option === 'allow-with-description' ||
                        (typeof option === 'object' && option.descriptionFormat)) {
                        const { minimumDescriptionLength } = options;
                        const format = descriptionFormats.get(fullDirective);
                        if ((0, util_1.getStringLength)(description.trim()) <
                            (0, util_1.nullThrows)(minimumDescriptionLength, 'Expected minimumDescriptionLength to be set')) {
                            context.report({
                                node: comment,
                                messageId: 'tsDirectiveCommentRequiresDescription',
                                data: { directive, minimumDescriptionLength },
                            });
                        }
                        else if (format && !format.test(description)) {
                            context.report({
                                node: comment,
                                messageId: 'tsDirectiveCommentDescriptionNotMatchPattern',
                                data: { directive, format: format.source },
                            });
                        }
                    }
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: ban-tslint-comment.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"commentDetected", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: ban-tslint-comment.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
// tslint regex
// https://github.com/palantir/tslint/blob/95d9d958833fd9dc0002d18cbe34db20d0fbf437/src/enableDisableRules.ts#L32
const ENABLE_DISABLE_REGEX = /^\s*tslint:(enable|disable)(?:-(line|next-line))?(:|\s|$)/;
const toText = (text, type) => type === utils_1.AST_TOKEN_TYPES.Line
    ? ['//', text.trim()].join(' ')
    : ['/*', text.trim(), '*/'].join(' ');
exports.default = (0, util_1.createRule)({
    name: 'ban-tslint-comment',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow `// tslint:<rule-flag>` comments',
            recommended: 'stylistic',
        },
        fixable: 'code',
        messages: {
            commentDetected: 'tslint comment detected: "{{ text }}"',
        },
        schema: [],
    },
    defaultOptions: [],
    create: context => {
        return {
            Program() {
                const comments = context.sourceCode.getAllComments();
                comments.forEach(c => {
                    if (ENABLE_DISABLE_REGEX.test(c.value)) {
                        context.report({
                            node: c,
                            messageId: 'commentDetected',
                            data: { text: toText(c.value, c.type) },
                            fix(fixer) {
                                const rangeStart = context.sourceCode.getIndexFromLoc({
                                    column: c.loc.start.column > 0 ? c.loc.start.column - 1 : 0,
                                    line: c.loc.start.line,
                                });
                                const rangeEnd = context.sourceCode.getIndexFromLoc({
                                    column: c.loc.end.column,
                                    line: c.loc.end.line,
                                });
                                return fixer.removeRange([rangeStart, rangeEnd + 1]);
                            },
                        });
                    }
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: class-literal-property-style.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = ['fields' | 'getters'];
export type MessageIds = 'preferFieldStyle' | 'preferFieldStyleSuggestion' | 'preferGetterStyle' | 'preferGetterStyleSuggestion';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: class-literal-property-style.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const printNodeModifiers = (node, final) => `${node.accessibility ?? ''}${node.static ? ' static' : ''} ${final} `.trimStart();
const isSupportedLiteral = (node) => {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.Literal:
            return true;
        case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:
            return node.quasi.quasis.length === 1;
        case utils_1.AST_NODE_TYPES.TemplateLiteral:
            return node.quasis.length === 1;
        default:
            return false;
    }
};
exports.default = (0, util_1.createRule)({
    name: 'class-literal-property-style',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce that literals on classes are exposed in a consistent style',
            recommended: 'stylistic',
        },
        hasSuggestions: true,
        messages: {
            preferFieldStyle: 'Literals should be exposed using readonly fields.',
            preferFieldStyleSuggestion: 'Replace the literals with readonly fields.',
            preferGetterStyle: 'Literals should be exposed using getters.',
            preferGetterStyleSuggestion: 'Replace the literals with getters.',
        },
        schema: [
            {
                type: 'string',
                description: 'Which literal class member syntax to prefer.',
                enum: ['fields', 'getters'],
            },
        ],
    },
    defaultOptions: ['fields'],
    create(context, [style]) {
        const propertiesInfoStack = [];
        function enterClassBody() {
            propertiesInfoStack.push({
                excludeSet: new Set(),
                properties: [],
            });
        }
        function exitClassBody() {
            const { excludeSet, properties } = (0, util_1.nullThrows)(propertiesInfoStack.pop(), 'Stack should exist on class exit');
            properties.forEach(node => {
                const { value } = node;
                if (!value || !isSupportedLiteral(value)) {
                    return;
                }
                const name = (0, util_1.getStaticMemberAccessValue)(node, context);
                if (name && excludeSet.has(name)) {
                    return;
                }
                context.report({
                    node: node.key,
                    messageId: 'preferGetterStyle',
                    suggest: [
                        {
                            messageId: 'preferGetterStyleSuggestion',
                            fix(fixer) {
                                const name = context.sourceCode.getText(node.key);
                                let text = '';
                                text += printNodeModifiers(node, 'get');
                                text += node.computed ? `[${name}]` : name;
                                text += `() { return ${context.sourceCode.getText(value)}; }`;
                                return fixer.replaceText(node, text);
                            },
                        },
                    ],
                });
            });
        }
        function excludeAssignedProperty(node) {
            if ((0, util_1.isAssignee)(node)) {
                const { excludeSet } = propertiesInfoStack[propertiesInfoStack.length - 1];
                const name = (0, util_1.getStaticMemberAccessValue)(node, context);
                if (name) {
                    excludeSet.add(name);
                }
            }
        }
        return {
            ...(style === 'fields' && {
                MethodDefinition(node) {
                    if (node.kind !== 'get' ||
                        node.override ||
                        !node.value.body ||
                        node.value.body.body.length === 0) {
                        return;
                    }
                    const [statement] = node.value.body.body;
                    if (statement.type !== utils_1.AST_NODE_TYPES.ReturnStatement) {
                        return;
                    }
                    const { argument } = statement;
                    if (!argument || !isSupportedLiteral(argument)) {
                        return;
                    }
                    const name = (0, util_1.getStaticMemberAccessValue)(node, context);
                    const hasDuplicateKeySetter = name &&
                        node.parent.body.some(element => {
                            return (element.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                                element.kind === 'set' &&
                                (0, util_1.isStaticMemberAccessOfValue)(element, context, name));
                        });
                    if (hasDuplicateKeySetter) {
                        return;
                    }
                    context.report({
                        node: node.key,
                        messageId: 'preferFieldStyle',
                        suggest: [
                            {
                                messageId: 'preferFieldStyleSuggestion',
                                fix(fixer) {
                                    const name = context.sourceCode.getText(node.key);
                                    let text = '';
                                    text += printNodeModifiers(node, 'readonly');
                                    text += node.computed ? `[${name}]` : name;
                                    text += ` = ${context.sourceCode.getText(argument)};`;
                                    return fixer.replaceText(node, text);
                                },
                            },
                        ],
                    });
                },
            }),
            ...(style === 'getters' && {
                ClassBody: enterClassBody,
                'ClassBody:exit': exitClassBody,
                'MethodDefinition[kind="constructor"] ThisExpression'(node) {
                    if (node.parent.type === utils_1.AST_NODE_TYPES.MemberExpression) {
                        let parent = node.parent;
                        while (!(0, util_1.isFunction)(parent)) {
                            parent = parent.parent;
                        }
                        if (parent.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                            parent.parent.kind === 'constructor') {
                            excludeAssignedProperty(node.parent);
                        }
                    }
                },
                PropertyDefinition(node) {
                    if (!node.readonly || node.declare || node.override) {
                        return;
                    }
                    const { properties } = propertiesInfoStack[propertiesInfoStack.length - 1];
                    properties.push(node);
                },
            }),
        };
    },
});


--------------------------------------------------------------------------------
FILE: class-methods-use-this.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        enforceForClassFields?: boolean;
        exceptMethods?: string[];
        ignoreClassesThatImplementAnInterface?: boolean | 'public-fields';
        ignoreOverrideMethods?: boolean;
    }
];
export type MessageIds = 'missingThis';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingThis", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: class-methods-use-this.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'class-methods-use-this',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce that class methods utilize `this`',
            extendsBaseRule: true,
            requiresTypeChecking: false,
        },
        messages: {
            missingThis: "Expected 'this' to be used by class {{name}}.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    enforceForClassFields: {
                        type: 'boolean',
                        description: 'Enforces that functions used as instance field initializers utilize `this`.',
                    },
                    exceptMethods: {
                        type: 'array',
                        description: 'Allows specified method names to be ignored with this rule.',
                        items: {
                            type: 'string',
                        },
                    },
                    ignoreClassesThatImplementAnInterface: {
                        description: 'Whether to ignore class members that are defined within a class that `implements` a type.',
                        oneOf: [
                            {
                                type: 'boolean',
                                description: 'Ignore all classes that implement an interface',
                            },
                            {
                                type: 'string',
                                description: 'Ignore only the public fields of classes that implement an interface',
                                enum: ['public-fields'],
                            },
                        ],
                    },
                    ignoreOverrideMethods: {
                        type: 'boolean',
                        description: 'Whether to ignore members marked with the `override` modifier.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            enforceForClassFields: true,
            exceptMethods: [],
            ignoreClassesThatImplementAnInterface: false,
            ignoreOverrideMethods: false,
        },
    ],
    create(context, [{ enforceForClassFields, exceptMethods: exceptMethodsRaw, ignoreClassesThatImplementAnInterface, ignoreOverrideMethods, },]) {
        const exceptMethods = new Set(exceptMethodsRaw);
        let stack;
        function pushContext(member) {
            if (member?.parent.type === utils_1.AST_NODE_TYPES.ClassBody) {
                stack = {
                    class: member.parent.parent,
                    member,
                    parent: stack,
                    usesThis: false,
                };
            }
            else {
                stack = {
                    class: null,
                    member: null,
                    parent: stack,
                    usesThis: false,
                };
            }
        }
        function enterFunction(node) {
            if (node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition ||
                node.parent.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||
                node.parent.type === utils_1.AST_NODE_TYPES.AccessorProperty) {
                pushContext(node.parent);
            }
            else {
                pushContext();
            }
        }
        /**
         * Pop `this` used flag from the stack.
         */
        function popContext() {
            const oldStack = stack;
            stack = stack?.parent;
            return oldStack;
        }
        function isPublicField(accessibility) {
            if (!accessibility || accessibility === 'public') {
                return true;
            }
            return false;
        }
        /**
         * Check if the node is an instance method not excluded by config
         */
        function isIncludedInstanceMethod(node) {
            if (node.static ||
                (node.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                    node.kind === 'constructor') ||
                ((node.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||
                    node.type === utils_1.AST_NODE_TYPES.AccessorProperty) &&
                    !enforceForClassFields)) {
                return false;
            }
            if (node.computed || exceptMethods.size === 0) {
                return true;
            }
            const hashIfNeeded = node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier ? '#' : '';
            const name = (0, util_1.getStaticMemberAccessValue)(node, context);
            return (typeof name !== 'string' || !exceptMethods.has(hashIfNeeded + name));
        }
        /**
         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.
         * Static methods and the constructor are exempt.
         * Then pops the context off the stack.
         */
        function exitFunction(node) {
            const stackContext = popContext();
            if (stackContext?.member == null ||
                stackContext.usesThis ||
                (ignoreOverrideMethods && stackContext.member.override) ||
                (ignoreClassesThatImplementAnInterface === true &&
                    stackContext.class.implements.length > 0) ||
                (ignoreClassesThatImplementAnInterface === 'public-fields' &&
                    stackContext.class.implements.length > 0 &&
                    isPublicField(stackContext.member.accessibility))) {
                return;
            }
            if (isIncludedInstanceMethod(stackContext.member)) {
                context.report({
                    loc: (0, util_1.getFunctionHeadLoc)(node, context.sourceCode),
                    node,
                    messageId: 'missingThis',
                    data: {
                        name: (0, util_1.getFunctionNameWithKind)(node),
                    },
                });
            }
        }
        return {
            // function declarations have their own `this` context
            FunctionDeclaration() {
                pushContext();
            },
            'FunctionDeclaration:exit'() {
                popContext();
            },
            FunctionExpression(node) {
                enterFunction(node);
            },
            'FunctionExpression:exit'(node) {
                exitFunction(node);
            },
            ...(enforceForClassFields
                ? {
                    'AccessorProperty > ArrowFunctionExpression.value'(node) {
                        enterFunction(node);
                    },
                    'AccessorProperty > ArrowFunctionExpression.value:exit'(node) {
                        exitFunction(node);
                    },
                    'PropertyDefinition > ArrowFunctionExpression.value'(node) {
                        enterFunction(node);
                    },
                    'PropertyDefinition > ArrowFunctionExpression.value:exit'(node) {
                        exitFunction(node);
                    },
                }
                : {}),
            /*
             * Class field value are implicit functions.
             */
            'AccessorProperty:exit'() {
                popContext();
            },
            'AccessorProperty > *.key:exit'() {
                pushContext();
            },
            'PropertyDefinition:exit'() {
                popContext();
            },
            'PropertyDefinition > *.key:exit'() {
                pushContext();
            },
            /*
             * Class static blocks are implicit functions. They aren't required to use `this`,
             * but we have to push context so that it captures any use of `this` in the static block
             * separately from enclosing contexts, because static blocks have their own `this` and it
             * shouldn't count as used `this` in enclosing contexts.
             */
            StaticBlock() {
                pushContext();
            },
            'StaticBlock:exit'() {
                popContext();
            },
            'ThisExpression, Super'() {
                if (stack) {
                    stack.usesThis = true;
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: consistent-generic-constructors.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'preferConstructor' | 'preferTypeAnnotation';
export type Options = ['constructor' | 'type-annotation'];
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: consistent-generic-constructors.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const builtInArrays = new Set([
    'Float32Array',
    'Float64Array',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray',
]);
exports.default = (0, util_1.createRule)({
    name: 'consistent-generic-constructors',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce specifying generic type arguments on type annotation or constructor name of a constructor call',
            recommended: 'stylistic',
        },
        fixable: 'code',
        messages: {
            preferConstructor: 'The generic type arguments should be specified as part of the constructor type arguments.',
            preferTypeAnnotation: 'The generic type arguments should be specified as part of the type annotation.',
        },
        schema: [
            {
                type: 'string',
                description: 'Which constructor call syntax to prefer.',
                enum: ['type-annotation', 'constructor'],
            },
        ],
    },
    defaultOptions: ['constructor'],
    create(context, [mode]) {
        return {
            'VariableDeclarator,PropertyDefinition,AccessorProperty,:matches(FunctionDeclaration,FunctionExpression) > AssignmentPattern'(node) {
                function getLHSRHS() {
                    switch (node.type) {
                        case utils_1.AST_NODE_TYPES.VariableDeclarator:
                            return [node.id, node.init];
                        case utils_1.AST_NODE_TYPES.PropertyDefinition:
                        case utils_1.AST_NODE_TYPES.AccessorProperty:
                            return [node, node.value];
                        case utils_1.AST_NODE_TYPES.AssignmentPattern:
                            return [node.left, node.right];
                        default:
                            throw new Error(`Unhandled node type: ${node.type}`);
                    }
                }
                function isBuiltInArray(typeName) {
                    return (builtInArrays.has(typeName.name) &&
                        (0, util_1.isReferenceToGlobalFunction)(typeName.name, typeName, context.sourceCode));
                }
                const [lhsName, rhs] = getLHSRHS();
                const lhs = lhsName.typeAnnotation?.typeAnnotation;
                if (rhs?.type !== utils_1.AST_NODE_TYPES.NewExpression ||
                    rhs.callee.type !== utils_1.AST_NODE_TYPES.Identifier) {
                    return;
                }
                if (lhs &&
                    (lhs.type !== utils_1.AST_NODE_TYPES.TSTypeReference ||
                        lhs.typeName.type !== utils_1.AST_NODE_TYPES.Identifier ||
                        lhs.typeName.name !== rhs.callee.name ||
                        isBuiltInArray(lhs.typeName))) {
                    return;
                }
                if (mode === 'type-annotation') {
                    if (!lhs && rhs.typeArguments) {
                        const { callee, typeArguments } = rhs;
                        const typeAnnotation = context.sourceCode.getText(callee) +
                            context.sourceCode.getText(typeArguments);
                        context.report({
                            node,
                            messageId: 'preferTypeAnnotation',
                            fix(fixer) {
                                function getIDToAttachAnnotation() {
                                    if (node.type !== utils_1.AST_NODE_TYPES.PropertyDefinition &&
                                        node.type !== utils_1.AST_NODE_TYPES.AccessorProperty) {
                                        return lhsName;
                                    }
                                    if (!node.computed) {
                                        return node.key;
                                    }
                                    // If the property's computed, we have to attach the
                                    // annotation after the square bracket, not the enclosed expression
                                    return (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.key), util_1.NullThrowsReasons.MissingToken(']', 'key'));
                                }
                                return [
                                    fixer.remove(typeArguments),
                                    fixer.insertTextAfter(getIDToAttachAnnotation(), `: ${typeAnnotation}`),
                                ];
                            },
                        });
                    }
                    return;
                }
                const isolatedDeclarations = context.parserOptions.isolatedDeclarations;
                if (!isolatedDeclarations && lhs?.typeArguments && !rhs.typeArguments) {
                    const hasParens = context.sourceCode.getTokenAfter(rhs.callee)?.value === '(';
                    const extraComments = new Set(context.sourceCode.getCommentsInside(lhs.parent));
                    context.sourceCode
                        .getCommentsInside(lhs.typeArguments)
                        .forEach(c => extraComments.delete(c));
                    context.report({
                        node,
                        messageId: 'preferConstructor',
                        *fix(fixer) {
                            yield fixer.remove(lhs.parent);
                            for (const comment of extraComments) {
                                yield fixer.insertTextAfter(rhs.callee, context.sourceCode.getText(comment));
                            }
                            yield fixer.insertTextAfter(rhs.callee, context.sourceCode.getText(lhs.typeArguments));
                            if (!hasParens) {
                                yield fixer.insertTextAfter(rhs.callee, '()');
                            }
                        },
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: consistent-indexed-object-style.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageIds = 'preferIndexSignature' | 'preferIndexSignatureSuggestion' | 'preferRecord';
export type Options = ['index-signature' | 'record'];
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: consistent-indexed-object-style.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'consistent-indexed-object-style',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require or disallow the `Record` type',
            recommended: 'stylistic',
        },
        fixable: 'code',
        // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions -- suggestions are exposed through a helper.
        hasSuggestions: true,
        messages: {
            preferIndexSignature: 'An index signature is preferred over a record.',
            preferIndexSignatureSuggestion: 'Change into an index signature instead of a record.',
            preferRecord: 'A record is preferred over an index signature.',
        },
        schema: [
            {
                type: 'string',
                description: 'Which indexed object syntax to prefer.',
                enum: ['record', 'index-signature'],
            },
        ],
    },
    defaultOptions: ['record'],
    create(context, [mode]) {
        function checkMembers(members, node, parentId, prefix, postfix, safeFix = true) {
            if (members.length !== 1) {
                return;
            }
            const [member] = members;
            if (member.type !== utils_1.AST_NODE_TYPES.TSIndexSignature) {
                return;
            }
            const parameter = member.parameters.at(0);
            if (parameter?.type !== utils_1.AST_NODE_TYPES.Identifier) {
                return;
            }
            const keyType = parameter.typeAnnotation;
            if (!keyType) {
                return;
            }
            const valueType = member.typeAnnotation;
            if (!valueType) {
                return;
            }
            if (parentId) {
                const scope = context.sourceCode.getScope(parentId);
                const superVar = utils_1.ASTUtils.findVariable(scope, parentId.name);
                if (superVar &&
                    isDeeplyReferencingType(node, superVar, new Set([parentId]))) {
                    return;
                }
            }
            context.report({
                node,
                messageId: 'preferRecord',
                fix: safeFix
                    ? (fixer) => {
                        const key = context.sourceCode.getText(keyType.typeAnnotation);
                        const value = context.sourceCode.getText(valueType.typeAnnotation);
                        const record = member.readonly
                            ? `Readonly<Record<${key}, ${value}>>`
                            : `Record<${key}, ${value}>`;
                        return fixer.replaceText(node, `${prefix}${record}${postfix}`);
                    }
                    : null,
            });
        }
        return {
            ...(mode === 'index-signature' && {
                TSTypeReference(node) {
                    const typeName = node.typeName;
                    if (typeName.type !== utils_1.AST_NODE_TYPES.Identifier) {
                        return;
                    }
                    if (typeName.name !== 'Record') {
                        return;
                    }
                    const params = node.typeArguments?.params;
                    if (params?.length !== 2) {
                        return;
                    }
                    const indexParam = params[0];
                    const shouldFix = indexParam.type === utils_1.AST_NODE_TYPES.TSStringKeyword ||
                        indexParam.type === utils_1.AST_NODE_TYPES.TSNumberKeyword ||
                        indexParam.type === utils_1.AST_NODE_TYPES.TSSymbolKeyword;
                    context.report({
                        node,
                        messageId: 'preferIndexSignature',
                        ...(0, util_1.getFixOrSuggest)({
                            fixOrSuggest: shouldFix ? 'fix' : 'suggest',
                            suggestion: {
                                messageId: 'preferIndexSignatureSuggestion',
                                fix: fixer => {
                                    const key = context.sourceCode.getText(params[0]);
                                    const type = context.sourceCode.getText(params[1]);
                                    return fixer.replaceText(node, `{ [key: ${key}]: ${type} }`);
                                },
                            },
                        }),
                    });
                },
            }),
            ...(mode === 'record' && {
                TSInterfaceDeclaration(node) {
                    let genericTypes = '';
                    if (node.typeParameters?.params.length) {
                        genericTypes = `<${node.typeParameters.params
                            .map(p => context.sourceCode.getText(p))
                            .join(', ')}>`;
                    }
                    checkMembers(node.body.body, node, node.id, `type ${node.id.name}${genericTypes} = `, ';', !node.extends.length);
                },
                TSMappedType(node) {
                    const key = node.key;
                    const scope = context.sourceCode.getScope(key);
                    const scopeManagerKey = (0, util_1.nullThrows)(scope.variables.find(value => value.name === key.name && value.isTypeVariable), 'key type parameter must be a defined type variable in its scope');
                    // If the key is used to compute the value, we can't convert to a Record.
                    if (scopeManagerKey.references.some(reference => reference.isTypeReference)) {
                        return;
                    }
                    const constraint = node.constraint;
                    if (constraint.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&
                        constraint.operator === 'keyof' &&
                        !(0, util_1.isParenthesized)(constraint, context.sourceCode)) {
                        // This is a weird special case, since modifiers are preserved by
                        // the mapped type, but not by the Record type. So this type is not,
                        // in general, equivalent to a Record type.
                        return;
                    }
                    // If the mapped type is circular, we can't convert it to a Record.
                    const parentId = findParentDeclaration(node)?.id;
                    if (parentId) {
                        const scope = context.sourceCode.getScope(key);
                        const superVar = utils_1.ASTUtils.findVariable(scope, parentId.name);
                        if (superVar) {
                            const isCircular = isDeeplyReferencingType(node.parent, superVar, new Set([parentId]));
                            if (isCircular) {
                                return;
                            }
                        }
                    }
                    // There's no builtin Mutable<T> type, so we can't autofix it really.
                    const canFix = node.readonly !== '-';
                    context.report({
                        node,
                        messageId: 'preferRecord',
                        ...(canFix && {
                            fix: (fixer) => {
                                const keyType = context.sourceCode.getText(constraint);
                                const valueType = node.typeAnnotation
                                    ? context.sourceCode.getText(node.typeAnnotation)
                                    : 'any';
                                let recordText = `Record<${keyType}, ${valueType}>`;
                                if (node.optional === '+' || node.optional === true) {
                                    recordText = `Partial<${recordText}>`;
                                }
                                else if (node.optional === '-') {
                                    recordText = `Required<${recordText}>`;
                                }
                                if (node.readonly === '+' || node.readonly === true) {
                                    recordText = `Readonly<${recordText}>`;
                                }
                                return fixer.replaceText(node, recordText);
                            },
                        }),
                    });
                },
                TSTypeLiteral(node) {
                    const parent = findParentDeclaration(node);
                    checkMembers(node.members, node, parent?.id, '', '');
                },
            }),
        };
    },
});
function findParentDeclaration(node) {
    if (node.parent && node.parent.type !== utils_1.AST_NODE_TYPES.TSTypeAnnotation) {
        if (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {
            return node.parent;
        }
        return findParentDeclaration(node.parent);
    }
    return undefined;
}
function isDeeplyReferencingType(node, superVar, visited) {
    if (visited.has(node)) {
        // something on the chain is circular but it's not the reference being checked
        return false;
    }
    visited.add(node);
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSTypeLiteral:
            return node.members.some(member => isDeeplyReferencingType(member, superVar, visited));
        case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:
            return isDeeplyReferencingType(node.typeAnnotation, superVar, visited);
        case utils_1.AST_NODE_TYPES.TSIndexedAccessType:
            return [node.indexType, node.objectType].some(type => isDeeplyReferencingType(type, superVar, visited));
        case utils_1.AST_NODE_TYPES.TSMappedType:
            if (node.typeAnnotation) {
                return isDeeplyReferencingType(node.typeAnnotation, superVar, visited);
            }
            break;
        case utils_1.AST_NODE_TYPES.TSConditionalType:
            return [
                node.checkType,
                node.extendsType,
                node.falseType,
                node.trueType,
            ].some(type => isDeeplyReferencingType(type, superVar, visited));
        case utils_1.AST_NODE_TYPES.TSUnionType:
        case utils_1.AST_NODE_TYPES.TSIntersectionType:
            return node.types.some(type => isDeeplyReferencingType(type, superVar, visited));
        case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:
            return node.body.body.some(type => isDeeplyReferencingType(type, superVar, visited));
        case utils_1.AST_NODE_TYPES.TSTypeAnnotation:
            return isDeeplyReferencingType(node.typeAnnotation, superVar, visited);
        case utils_1.AST_NODE_TYPES.TSIndexSignature: {
            if (node.typeAnnotation) {
                return isDeeplyReferencingType(node.typeAnnotation, superVar, visited);
            }
            break;
        }
        case utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation: {
            return node.params.some(param => isDeeplyReferencingType(param, superVar, visited));
        }
        case utils_1.AST_NODE_TYPES.TSTypeReference: {
            if (isDeeplyReferencingType(node.typeName, superVar, visited)) {
                return true;
            }
            if (node.typeArguments &&
                isDeeplyReferencingType(node.typeArguments, superVar, visited)) {
                return true;
            }
            break;
        }
        case utils_1.AST_NODE_TYPES.Identifier: {
            // check if the identifier is a reference of the type being checked
            if (superVar.references.some(ref => (0, util_1.isNodeEqual)(ref.identifier, node))) {
                return true;
            }
            // otherwise, follow its definition(s)
            const refVar = utils_1.ASTUtils.findVariable(superVar.scope, node.name);
            if (refVar) {
                return refVar.defs.some(def => isDeeplyReferencingType(def.node, superVar, visited));
            }
        }
    }
    return false;
}


--------------------------------------------------------------------------------
FILE: consistent-return.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingReturn" | "missingReturnValue" | "unexpectedReturnValue", [({
    treatUndefinedAsUnspecified?: boolean;
} | undefined)?], unknown, {
    'ArrowFunctionExpression:exit'(node: TSESTree.ArrowFunctionExpression): void;
    'FunctionDeclaration:exit'(node: TSESTree.FunctionDeclaration): void;
    'FunctionExpression:exit'(node: TSESTree.FunctionExpression): void;
    ReturnStatement(node: TSESTree.ReturnStatement): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingReturn" | "missingReturnValue" | "unexpectedReturnValue", [({
    treatUndefinedAsUnspecified?: boolean;
} | undefined)?], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: consistent-return.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('consistent-return');
const defaultOptions = [{ treatUndefinedAsUnspecified: false }];
exports.default = (0, util_1.createRule)({
    name: 'consistent-return',
    meta: {
        type: 'suggestion',
        defaultOptions,
        docs: {
            description: 'Require `return` statements to either always or never specify values',
            extendsBaseRule: true,
            requiresTypeChecking: true,
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: baseRule.meta.schema,
    },
    defaultOptions,
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const rules = baseRule.create(context);
        const functions = [];
        const treatUndefinedAsUnspecified = options?.treatUndefinedAsUnspecified === true;
        function enterFunction(node) {
            functions.push(node);
        }
        function exitFunction() {
            functions.pop();
        }
        function getCurrentFunction() {
            return functions[functions.length - 1] ?? null;
        }
        function isPromiseVoid(node, type) {
            if (tsutils.isThenableType(checker, node, type) &&
                tsutils.isTypeReference(type)) {
                const awaitedType = type.typeArguments?.[0];
                if (awaitedType) {
                    if ((0, util_1.isTypeFlagSet)(awaitedType, ts.TypeFlags.Void)) {
                        return true;
                    }
                    return isPromiseVoid(node, awaitedType);
                }
            }
            return false;
        }
        function isReturnVoidOrThenableVoid(node) {
            const functionType = services.getTypeAtLocation(node);
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            const callSignatures = functionType.getCallSignatures();
            return callSignatures.some(signature => {
                const returnType = signature.getReturnType();
                if (node.async) {
                    return isPromiseVoid(tsNode, returnType);
                }
                return (0, util_1.isTypeFlagSet)(returnType, ts.TypeFlags.Void);
            });
        }
        return {
            ...rules,
            ArrowFunctionExpression: enterFunction,
            'ArrowFunctionExpression:exit'(node) {
                exitFunction();
                rules['ArrowFunctionExpression:exit'](node);
            },
            FunctionDeclaration: enterFunction,
            'FunctionDeclaration:exit'(node) {
                exitFunction();
                rules['FunctionDeclaration:exit'](node);
            },
            FunctionExpression: enterFunction,
            'FunctionExpression:exit'(node) {
                exitFunction();
                rules['FunctionExpression:exit'](node);
            },
            ReturnStatement(node) {
                const functionNode = getCurrentFunction();
                if (!node.argument &&
                    functionNode &&
                    isReturnVoidOrThenableVoid(functionNode)) {
                    return;
                }
                if (treatUndefinedAsUnspecified && node.argument) {
                    const returnValueType = services.getTypeAtLocation(node.argument);
                    if (returnValueType.flags === ts.TypeFlags.Undefined) {
                        rules.ReturnStatement({
                            ...node,
                            argument: null,
                        });
                        return;
                    }
                }
                rules.ReturnStatement(node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: consistent-type-assertions.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageIds = 'angle-bracket' | 'as' | 'never' | 'replaceArrayTypeAssertionWithAnnotation' | 'replaceArrayTypeAssertionWithSatisfies' | 'replaceObjectTypeAssertionWithAnnotation' | 'replaceObjectTypeAssertionWithSatisfies' | 'unexpectedArrayTypeAssertion' | 'unexpectedObjectTypeAssertion';
type OptUnion = {
    assertionStyle: 'angle-bracket' | 'as';
    objectLiteralTypeAssertions?: 'allow' | 'allow-as-parameter' | 'never';
    arrayLiteralTypeAssertions?: 'allow' | 'allow-as-parameter' | 'never';
} | {
    assertionStyle: 'never';
};
export type Options = readonly [OptUnion];
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: consistent-type-assertions.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const getWrappedCode_1 = require("../util/getWrappedCode");
exports.default = (0, util_1.createRule)({
    name: 'consistent-type-assertions',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce consistent usage of type assertions',
            recommended: 'stylistic',
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            'angle-bracket': "Use '<{{cast}}>' instead of 'as {{cast}}'.",
            as: "Use 'as {{cast}}' instead of '<{{cast}}>'.",
            never: 'Do not use any type assertions.',
            replaceArrayTypeAssertionWithAnnotation: 'Use const x: {{cast}} = [ ... ] instead.',
            replaceArrayTypeAssertionWithSatisfies: 'Use const x = [ ... ] satisfies {{cast}} instead.',
            replaceObjectTypeAssertionWithAnnotation: 'Use const x: {{cast}} = { ... } instead.',
            replaceObjectTypeAssertionWithSatisfies: 'Use const x = { ... } satisfies {{cast}} instead.',
            unexpectedArrayTypeAssertion: 'Always prefer const x: T[] = [ ... ].',
            unexpectedObjectTypeAssertion: 'Always prefer const x: T = { ... }.',
        },
        schema: [
            {
                oneOf: [
                    {
                        type: 'object',
                        additionalProperties: false,
                        properties: {
                            assertionStyle: {
                                type: 'string',
                                description: 'The expected assertion style to enforce.',
                                enum: ['never'],
                            },
                        },
                        required: ['assertionStyle'],
                    },
                    {
                        type: 'object',
                        additionalProperties: false,
                        properties: {
                            arrayLiteralTypeAssertions: {
                                type: 'string',
                                description: 'Whether to always prefer type declarations for array literals used as variable initializers, rather than type assertions.',
                                enum: ['allow', 'allow-as-parameter', 'never'],
                            },
                            assertionStyle: {
                                type: 'string',
                                description: 'The expected assertion style to enforce.',
                                enum: ['as', 'angle-bracket'],
                            },
                            objectLiteralTypeAssertions: {
                                type: 'string',
                                description: 'Whether to always prefer type declarations for object literals used as variable initializers, rather than type assertions.',
                                enum: ['allow', 'allow-as-parameter', 'never'],
                            },
                        },
                    },
                ],
            },
        ],
    },
    defaultOptions: [
        {
            arrayLiteralTypeAssertions: 'allow',
            assertionStyle: 'as',
            objectLiteralTypeAssertions: 'allow',
        },
    ],
    create(context, [options]) {
        function isConst(node) {
            if (node.type !== utils_1.AST_NODE_TYPES.TSTypeReference) {
                return false;
            }
            return (node.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.typeName.name === 'const');
        }
        function reportIncorrectAssertionType(node) {
            const messageId = options.assertionStyle;
            // If this node is `as const`, then don't report an error.
            if (isConst(node.typeAnnotation) && messageId === 'never') {
                return;
            }
            context.report({
                node,
                messageId,
                data: messageId !== 'never'
                    ? { cast: context.sourceCode.getText(node.typeAnnotation) }
                    : {},
                fix: messageId === 'as'
                    ? (fixer) => {
                        // lazily access parserServices to avoid crashing on non TS files (#9860)
                        const tsNode = (0, util_1.getParserServices)(context, true).esTreeNodeToTSNodeMap.get(node);
                        const expressionCode = context.sourceCode.getText(node.expression);
                        const typeAnnotationCode = context.sourceCode.getText(node.typeAnnotation);
                        const asPrecedence = (0, util_1.getOperatorPrecedence)(ts.SyntaxKind.AsExpression, ts.SyntaxKind.Unknown);
                        const parentPrecedence = (0, util_1.getOperatorPrecedence)(tsNode.parent.kind, ts.isBinaryExpression(tsNode.parent)
                            ? tsNode.parent.operatorToken.kind
                            : ts.SyntaxKind.Unknown, ts.isNewExpression(tsNode.parent)
                            ? tsNode.parent.arguments != null &&
                                tsNode.parent.arguments.length > 0
                            : undefined);
                        const expressionPrecedence = (0, util_1.getOperatorPrecedenceForNode)(node.expression);
                        const expressionCodeWrapped = (0, getWrappedCode_1.getWrappedCode)(expressionCode, expressionPrecedence, asPrecedence);
                        const text = `${expressionCodeWrapped} as ${typeAnnotationCode}`;
                        return fixer.replaceText(node, (0, util_1.isParenthesized)(node, context.sourceCode)
                            ? text
                            : (0, getWrappedCode_1.getWrappedCode)(text, asPrecedence, parentPrecedence));
                    }
                    : undefined,
            });
        }
        function checkType(node) {
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.TSAnyKeyword:
                case utils_1.AST_NODE_TYPES.TSUnknownKeyword:
                    return false;
                case utils_1.AST_NODE_TYPES.TSTypeReference:
                    return (
                    // Ignore `as const` and `<const>`
                    !isConst(node) ||
                        // Allow qualified names which have dots between identifiers, `Foo.Bar`
                        node.typeName.type === utils_1.AST_NODE_TYPES.TSQualifiedName);
                default:
                    return true;
            }
        }
        function getSuggestions(node, annotationMessageId, satisfiesMessageId) {
            const suggestions = [];
            if (node.parent.type === utils_1.AST_NODE_TYPES.VariableDeclarator &&
                !node.parent.id.typeAnnotation) {
                const { parent } = node;
                suggestions.push({
                    messageId: annotationMessageId,
                    data: { cast: context.sourceCode.getText(node.typeAnnotation) },
                    fix: fixer => [
                        fixer.insertTextAfter(parent.id, `: ${context.sourceCode.getText(node.typeAnnotation)}`),
                        fixer.replaceText(node, (0, util_1.getTextWithParentheses)(context.sourceCode, node.expression)),
                    ],
                });
            }
            suggestions.push({
                messageId: satisfiesMessageId,
                data: { cast: context.sourceCode.getText(node.typeAnnotation) },
                fix: fixer => [
                    fixer.replaceText(node, (0, util_1.getTextWithParentheses)(context.sourceCode, node.expression)),
                    fixer.insertTextAfter(node, ` satisfies ${context.sourceCode.getText(node.typeAnnotation)}`),
                ],
            });
            return suggestions;
        }
        function isAsParameter(node) {
            return (node.parent.type === utils_1.AST_NODE_TYPES.NewExpression ||
                node.parent.type === utils_1.AST_NODE_TYPES.CallExpression ||
                node.parent.type === utils_1.AST_NODE_TYPES.ThrowStatement ||
                node.parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern ||
                node.parent.type === utils_1.AST_NODE_TYPES.JSXExpressionContainer ||
                (node.parent.type === utils_1.AST_NODE_TYPES.TemplateLiteral &&
                    node.parent.parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression));
        }
        function checkExpressionForObjectAssertion(node) {
            if (options.assertionStyle === 'never' ||
                options.objectLiteralTypeAssertions === 'allow' ||
                node.expression.type !== utils_1.AST_NODE_TYPES.ObjectExpression) {
                return;
            }
            if (options.objectLiteralTypeAssertions === 'allow-as-parameter' &&
                isAsParameter(node)) {
                return;
            }
            if (checkType(node.typeAnnotation)) {
                const suggest = getSuggestions(node, 'replaceObjectTypeAssertionWithAnnotation', 'replaceObjectTypeAssertionWithSatisfies');
                context.report({
                    node,
                    messageId: 'unexpectedObjectTypeAssertion',
                    suggest,
                });
            }
        }
        function checkExpressionForArrayAssertion(node) {
            if (options.assertionStyle === 'never' ||
                options.arrayLiteralTypeAssertions === 'allow' ||
                node.expression.type !== utils_1.AST_NODE_TYPES.ArrayExpression) {
                return;
            }
            if (options.arrayLiteralTypeAssertions === 'allow-as-parameter' &&
                isAsParameter(node)) {
                return;
            }
            if (checkType(node.typeAnnotation)) {
                const suggest = getSuggestions(node, 'replaceArrayTypeAssertionWithAnnotation', 'replaceArrayTypeAssertionWithSatisfies');
                context.report({
                    node,
                    messageId: 'unexpectedArrayTypeAssertion',
                    suggest,
                });
            }
        }
        return {
            TSAsExpression(node) {
                if (options.assertionStyle !== 'as') {
                    reportIncorrectAssertionType(node);
                    return;
                }
                checkExpressionForObjectAssertion(node);
                checkExpressionForArrayAssertion(node);
            },
            TSTypeAssertion(node) {
                if (options.assertionStyle !== 'angle-bracket') {
                    reportIncorrectAssertionType(node);
                    return;
                }
                checkExpressionForObjectAssertion(node);
                checkExpressionForArrayAssertion(node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: consistent-type-definitions.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"interfaceOverType" | "typeOverInterface", [string], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: consistent-type-definitions.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'consistent-type-definitions',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce type definitions to consistently use either `interface` or `type`',
            recommended: 'stylistic',
        },
        fixable: 'code',
        messages: {
            interfaceOverType: 'Use an `interface` instead of a `type`.',
            typeOverInterface: 'Use a `type` instead of an `interface`.',
        },
        schema: [
            {
                type: 'string',
                description: 'Which type definition syntax to prefer.',
                enum: ['interface', 'type'],
            },
        ],
    },
    defaultOptions: ['interface'],
    create(context, [option]) {
        /**
         * Iterates from the highest parent to the currently traversed node
         * to determine whether any node in tree is globally declared module declaration
         */
        function isCurrentlyTraversedNodeWithinModuleDeclaration(node) {
            return context.sourceCode
                .getAncestors(node)
                .some(node => node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration &&
                node.declare &&
                node.kind === 'global');
        }
        return {
            ...(option === 'interface' && {
                "TSTypeAliasDeclaration[typeAnnotation.type='TSTypeLiteral']"(node) {
                    context.report({
                        node: node.id,
                        messageId: 'interfaceOverType',
                        fix(fixer) {
                            const typeToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(node.id, token => token.value === 'type'), util_1.NullThrowsReasons.MissingToken('type keyword', 'type alias'));
                            const equalsToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(node.typeAnnotation, token => token.value === '='), util_1.NullThrowsReasons.MissingToken('=', 'type alias'));
                            const beforeEqualsToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(equalsToken, {
                                includeComments: true,
                            }), util_1.NullThrowsReasons.MissingToken('before =', 'type alias'));
                            return [
                                // replace 'type' with 'interface'.
                                fixer.replaceText(typeToken, 'interface'),
                                // delete from the = to the { of the type, and put a space to be pretty.
                                fixer.replaceTextRange([beforeEqualsToken.range[1], node.typeAnnotation.range[0]], ' '),
                                // remove from the closing } through the end of the statement.
                                fixer.removeRange([
                                    node.typeAnnotation.range[1],
                                    node.range[1],
                                ]),
                            ];
                        },
                    });
                },
            }),
            ...(option === 'type' && {
                TSInterfaceDeclaration(node) {
                    const fix = isCurrentlyTraversedNodeWithinModuleDeclaration(node)
                        ? null
                        : (fixer) => {
                            const typeNode = node.typeParameters ?? node.id;
                            const fixes = [];
                            const firstToken = context.sourceCode.getTokenBefore(node.id);
                            if (firstToken) {
                                fixes.push(fixer.replaceText(firstToken, 'type'));
                                fixes.push(fixer.replaceTextRange([typeNode.range[1], node.body.range[0]], ' = '));
                            }
                            node.extends.forEach(heritage => {
                                const typeIdentifier = context.sourceCode.getText(heritage);
                                fixes.push(fixer.insertTextAfter(node.body, ` & ${typeIdentifier}`));
                            });
                            if (node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {
                                fixes.push(fixer.removeRange([node.parent.range[0], node.range[0]]), fixer.insertTextAfter(node.body, `\nexport default ${node.id.name}`));
                            }
                            return fixes;
                        };
                    context.report({
                        node: node.id,
                        messageId: 'typeOverInterface',
                        /**
                         * remove automatically fix when the interface is within a declare global
                         * @see {@link https://github.com/typescript-eslint/typescript-eslint/issues/2707}
                         */
                        fix,
                    });
                },
            }),
        };
    },
});


--------------------------------------------------------------------------------
FILE: consistent-type-exports.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        fixMixedExportsWithInlineTypeSpecifier: boolean;
    }
];
export type MessageIds = 'multipleExportsAreTypes' | 'singleExportIsType' | 'typeOverValue';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: consistent-type-exports.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'consistent-type-exports',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce consistent usage of type exports',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            multipleExportsAreTypes: 'Type exports {{exportNames}} are not values and should be exported using `export type`.',
            singleExportIsType: 'Type export {{exportNames}} is not a value and should be exported using `export type`.',
            typeOverValue: 'All exports in the declaration are only used as types. Use `export type`.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    fixMixedExportsWithInlineTypeSpecifier: {
                        type: 'boolean',
                        description: 'Whether the rule will autofix "mixed" export cases using TS inline type specifiers.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            fixMixedExportsWithInlineTypeSpecifier: false,
        },
    ],
    create(context, [{ fixMixedExportsWithInlineTypeSpecifier }]) {
        const sourceExportsMap = {};
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        /**
         * Helper for identifying if a symbol resolves to a
         * JavaScript value or a TypeScript type.
         *
         * @returns True/false if is a type or not, or undefined if the specifier
         * can't be resolved.
         */
        function isSymbolTypeBased(symbol) {
            if (!symbol || checker.isUnknownSymbol(symbol)) {
                return undefined;
            }
            if (symbol.getDeclarations()?.some(ts.isTypeOnlyImportOrExportDeclaration)) {
                return true;
            }
            if (symbol.flags & ts.SymbolFlags.Value) {
                return false;
            }
            return symbol.flags & ts.SymbolFlags.Alias
                ? isSymbolTypeBased(checker.getImmediateAliasedSymbol(symbol))
                : true;
        }
        return {
            ExportAllDeclaration(node) {
                if (node.exportKind === 'type') {
                    return;
                }
                const sourceModule = ts.resolveModuleName(node.source.value, context.filename, services.program.getCompilerOptions(), ts.sys);
                if (sourceModule.resolvedModule == null) {
                    return;
                }
                const sourceFile = services.program.getSourceFile(sourceModule.resolvedModule.resolvedFileName);
                if (sourceFile == null) {
                    return;
                }
                const sourceFileSymbol = checker.getSymbolAtLocation(sourceFile);
                if (sourceFileSymbol == null) {
                    return;
                }
                const sourceFileType = checker.getTypeOfSymbol(sourceFileSymbol);
                // Module can explicitly export types or values, and it's not difficult
                // to distinguish one from the other, since we can get the flags of
                // the exported symbols or check if symbol export declaration has
                // the "type" keyword in it.
                //
                // Things get a lot more complicated when we're dealing with
                // export * from './module-with-type-only-exports'
                // export type * from './module-with-type-and-value-exports'
                //
                // TS checker has an internal function getExportsOfModuleWorker that
                // recursively visits all module exports, including "export *". It then
                // puts type-only-star-exported symbols into the typeOnlyExportStarMap
                // property of sourceFile's SymbolLinks. Since symbol links aren't
                // exposed outside the checker, we cannot access it directly.
                //
                // Therefore, to filter out value properties, we use the following hack:
                // checker.getPropertiesOfType returns all exports that were originally
                // values, but checker.getPropertyOfType returns undefined for
                // properties that are mentioned in the typeOnlyExportStarMap.
                const isThereAnyExportedValue = checker
                    .getPropertiesOfType(sourceFileType)
                    .some(propertyTypeSymbol => checker.getPropertyOfType(sourceFileType, propertyTypeSymbol.escapedName.toString()) != null);
                if (isThereAnyExportedValue) {
                    return;
                }
                context.report({
                    node,
                    messageId: 'typeOverValue',
                    fix(fixer) {
                        const asteriskToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator &&
                            token.value === '*'), util_1.NullThrowsReasons.MissingToken('asterisk', 'export all declaration'));
                        return fixer.insertTextBefore(asteriskToken, 'type ');
                    },
                });
            },
            ExportNamedDeclaration(node) {
                // Coerce the source into a string for use as a lookup entry.
                const source = getSourceFromExport(node) ?? 'undefined';
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                const sourceExports = (sourceExportsMap[source] ||= {
                    reportValueExports: [],
                    source,
                    typeOnlyNamedExport: null,
                    valueOnlyNamedExport: null,
                });
                // Cache the first encountered exports for the package. We will need to come
                // back to these later when fixing the problems.
                if (node.exportKind === 'type') {
                    // The export is a type export
                    sourceExports.typeOnlyNamedExport ??= node;
                }
                else {
                    // The export is a value export
                    sourceExports.valueOnlyNamedExport ??= node;
                }
                // Next for the current export, we will separate type/value specifiers.
                const typeBasedSpecifiers = [];
                const inlineTypeSpecifiers = [];
                const valueSpecifiers = [];
                // Note: it is valid to export values as types. We will avoid reporting errors
                // when this is encountered.
                if (node.exportKind !== 'type') {
                    for (const specifier of node.specifiers) {
                        if (specifier.exportKind === 'type') {
                            inlineTypeSpecifiers.push(specifier);
                            continue;
                        }
                        const isTypeBased = isSymbolTypeBased(services.getSymbolAtLocation(specifier.exported));
                        if (isTypeBased === true) {
                            typeBasedSpecifiers.push(specifier);
                        }
                        else if (isTypeBased === false) {
                            // When isTypeBased is undefined, we should avoid reporting them.
                            valueSpecifiers.push(specifier);
                        }
                    }
                }
                if ((node.exportKind === 'value' && typeBasedSpecifiers.length) ||
                    (node.exportKind === 'type' && valueSpecifiers.length)) {
                    sourceExports.reportValueExports.push({
                        node,
                        inlineTypeSpecifiers,
                        typeBasedSpecifiers,
                        valueSpecifiers,
                    });
                }
            },
            'Program:exit'() {
                for (const sourceExports of Object.values(sourceExportsMap)) {
                    // If this export has no issues, move on.
                    if (sourceExports.reportValueExports.length === 0) {
                        continue;
                    }
                    for (const report of sourceExports.reportValueExports) {
                        if (report.valueSpecifiers.length === 0) {
                            // Export is all type-only with no type specifiers; convert the entire export to `export type`.
                            context.report({
                                node: report.node,
                                messageId: 'typeOverValue',
                                *fix(fixer) {
                                    yield* fixExportInsertType(fixer, context.sourceCode, report.node);
                                },
                            });
                            continue;
                        }
                        // We have both type and value violations.
                        const allExportNames = report.typeBasedSpecifiers.map(specifier => specifier.local.type === utils_1.AST_NODE_TYPES.Identifier
                            ? specifier.local.name
                            : specifier.local.value);
                        if (allExportNames.length === 1) {
                            const exportNames = allExportNames[0];
                            context.report({
                                node: report.node,
                                messageId: 'singleExportIsType',
                                data: { exportNames },
                                *fix(fixer) {
                                    if (fixMixedExportsWithInlineTypeSpecifier) {
                                        yield* fixAddTypeSpecifierToNamedExports(fixer, report);
                                    }
                                    else {
                                        yield* fixSeparateNamedExports(fixer, context.sourceCode, report);
                                    }
                                },
                            });
                        }
                        else {
                            const exportNames = (0, util_1.formatWordList)(allExportNames);
                            context.report({
                                node: report.node,
                                messageId: 'multipleExportsAreTypes',
                                data: { exportNames },
                                *fix(fixer) {
                                    if (fixMixedExportsWithInlineTypeSpecifier) {
                                        yield* fixAddTypeSpecifierToNamedExports(fixer, report);
                                    }
                                    else {
                                        yield* fixSeparateNamedExports(fixer, context.sourceCode, report);
                                    }
                                },
                            });
                        }
                    }
                }
            },
        };
    },
});
/**
 * Inserts "type" into an export.
 *
 * Example:
 *
 * export type { Foo } from 'foo';
 *        ^^^^
 */
function* fixExportInsertType(fixer, sourceCode, node) {
    const exportToken = (0, util_1.nullThrows)(sourceCode.getFirstToken(node), util_1.NullThrowsReasons.MissingToken('export', node.type));
    yield fixer.insertTextAfter(exportToken, ' type');
    for (const specifier of node.specifiers) {
        if (specifier.exportKind === 'type') {
            const kindToken = (0, util_1.nullThrows)(sourceCode.getFirstToken(specifier), util_1.NullThrowsReasons.MissingToken('export', specifier.type));
            const firstTokenAfter = (0, util_1.nullThrows)(sourceCode.getTokenAfter(kindToken, {
                includeComments: true,
            }), 'Missing token following the export kind.');
            yield fixer.removeRange([kindToken.range[0], firstTokenAfter.range[0]]);
        }
    }
}
/**
 * Separates the exports which mismatch the kind of export the given
 * node represents. For example, a type export's named specifiers which
 * represent values will be inserted in a separate `export` statement.
 */
function* fixSeparateNamedExports(fixer, sourceCode, report) {
    const { node, inlineTypeSpecifiers, typeBasedSpecifiers, valueSpecifiers } = report;
    const typeSpecifiers = [...typeBasedSpecifiers, ...inlineTypeSpecifiers];
    const source = getSourceFromExport(node);
    const specifierNames = typeSpecifiers.map(getSpecifierText).join(', ');
    const exportToken = (0, util_1.nullThrows)(sourceCode.getFirstToken(node), util_1.NullThrowsReasons.MissingToken('export', node.type));
    // Filter the bad exports from the current line.
    const filteredSpecifierNames = valueSpecifiers
        .map(getSpecifierText)
        .join(', ');
    const openToken = (0, util_1.nullThrows)(sourceCode.getFirstToken(node, util_1.isOpeningBraceToken), util_1.NullThrowsReasons.MissingToken('{', node.type));
    const closeToken = (0, util_1.nullThrows)(sourceCode.getLastToken(node, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', node.type));
    // Remove exports from the current line which we're going to re-insert.
    yield fixer.replaceTextRange([openToken.range[1], closeToken.range[0]], ` ${filteredSpecifierNames} `);
    // Insert the bad exports into a new export line above.
    yield fixer.insertTextBefore(exportToken, `export type { ${specifierNames} }${source ? ` from '${source}'` : ''};\n`);
}
function* fixAddTypeSpecifierToNamedExports(fixer, report) {
    if (report.node.exportKind === 'type') {
        return;
    }
    for (const specifier of report.typeBasedSpecifiers) {
        yield fixer.insertTextBefore(specifier, 'type ');
    }
}
/**
 * Returns the source of the export, or undefined if the named export has no source.
 */
function getSourceFromExport(node) {
    if (node.source?.type === utils_1.AST_NODE_TYPES.Literal &&
        typeof node.source.value === 'string') {
        return node.source.value;
    }
    return undefined;
}
/**
 * Returns the specifier text for the export. If it is aliased, we take care to return
 * the proper formatting.
 */
function getSpecifierText(specifier) {
    const exportedName = specifier.exported.type === utils_1.AST_NODE_TYPES.Literal
        ? specifier.exported.raw
        : specifier.exported.name;
    const localName = specifier.local.type === utils_1.AST_NODE_TYPES.Literal
        ? specifier.local.raw
        : specifier.local.name;
    return `${localName}${exportedName !== localName ? ` as ${exportedName}` : ''}`;
}


--------------------------------------------------------------------------------
FILE: consistent-type-imports.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
type Prefer = 'no-type-imports' | 'type-imports';
type FixStyle = 'inline-type-imports' | 'separate-type-imports';
export type Options = [
    {
        disallowTypeAnnotations?: boolean;
        fixStyle?: FixStyle;
        prefer?: Prefer;
    }
];
export type MessageIds = 'avoidImportType' | 'noImportTypeAnnotations' | 'someImportsAreOnlyTypes' | 'typeOverValue';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: consistent-type-imports.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'consistent-type-imports',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce consistent usage of type imports',
        },
        fixable: 'code',
        messages: {
            avoidImportType: 'Use an `import` instead of an `import type`.',
            noImportTypeAnnotations: '`import()` type annotations are forbidden.',
            someImportsAreOnlyTypes: 'Imports {{typeImports}} are only used as type.',
            typeOverValue: 'All imports in the declaration are only used as types. Use `import type`.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    disallowTypeAnnotations: {
                        type: 'boolean',
                        description: 'Whether to disallow type imports in type annotations (`import()`).',
                    },
                    fixStyle: {
                        type: 'string',
                        description: 'The expected type modifier to be added when an import is detected as used only in the type position.',
                        enum: ['separate-type-imports', 'inline-type-imports'],
                    },
                    prefer: {
                        type: 'string',
                        description: 'The expected import kind for type-only imports.',
                        enum: ['type-imports', 'no-type-imports'],
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            disallowTypeAnnotations: true,
            fixStyle: 'separate-type-imports',
            prefer: 'type-imports',
        },
    ],
    create(context, [option]) {
        const prefer = option.prefer ?? 'type-imports';
        const disallowTypeAnnotations = option.disallowTypeAnnotations !== false;
        const selectors = {};
        if (disallowTypeAnnotations) {
            selectors.TSImportType = (node) => {
                context.report({
                    node,
                    messageId: 'noImportTypeAnnotations',
                });
            };
        }
        if (prefer === 'no-type-imports') {
            return {
                ...selectors,
                'ImportDeclaration[importKind = "type"]'(node) {
                    context.report({
                        node,
                        messageId: 'avoidImportType',
                        fix(fixer) {
                            return fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);
                        },
                    });
                },
                'ImportSpecifier[importKind = "type"]'(node) {
                    context.report({
                        node,
                        messageId: 'avoidImportType',
                        fix(fixer) {
                            return fixRemoveTypeSpecifierFromImportSpecifier(fixer, node);
                        },
                    });
                },
            };
        }
        // prefer type imports
        const fixStyle = option.fixStyle ?? 'separate-type-imports';
        let hasDecoratorMetadata = false;
        const sourceImportsMap = {};
        const emitDecoratorMetadata = (0, util_1.getParserServices)(context, true).emitDecoratorMetadata ?? false;
        const experimentalDecorators = (0, util_1.getParserServices)(context, true).experimentalDecorators ?? false;
        if (experimentalDecorators && emitDecoratorMetadata) {
            selectors.Decorator = () => {
                hasDecoratorMetadata = true;
            };
        }
        return {
            ...selectors,
            ImportDeclaration(node) {
                const source = node.source.value;
                // sourceImports is the object containing all the specifics for a particular import source, type or value
                sourceImportsMap[source] ??= {
                    reportValueImports: [], // if there is a mismatch where type importKind but value specifiers
                    source,
                    typeOnlyNamedImport: null, // if only type imports
                    valueImport: null, // if only value imports
                    valueOnlyNamedImport: null, // if only value imports with named specifiers
                };
                const sourceImports = sourceImportsMap[source];
                if (node.importKind === 'type') {
                    if (!sourceImports.typeOnlyNamedImport &&
                        node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {
                        // definitely import type { TypeX }
                        sourceImports.typeOnlyNamedImport = node;
                    }
                }
                else if (!sourceImports.valueOnlyNamedImport &&
                    node.specifiers.length &&
                    node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {
                    sourceImports.valueOnlyNamedImport = node;
                    sourceImports.valueImport = node;
                }
                else if (!sourceImports.valueImport &&
                    node.specifiers.some(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier)) {
                    sourceImports.valueImport = node;
                }
                const typeSpecifiers = [];
                const inlineTypeSpecifiers = [];
                const valueSpecifiers = [];
                const unusedSpecifiers = [];
                for (const specifier of node.specifiers) {
                    if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &&
                        specifier.importKind === 'type') {
                        inlineTypeSpecifiers.push(specifier);
                        continue;
                    }
                    const [variable] = context.sourceCode.getDeclaredVariables(specifier);
                    if (variable.references.length === 0) {
                        unusedSpecifiers.push(specifier);
                    }
                    else {
                        const onlyHasTypeReferences = variable.references.every(ref => {
                            /**
                             * keep origin import kind when export
                             * export { Type }
                             * export default Type;
                             * export = Type;
                             */
                            if ((ref.identifier.parent.type ===
                                utils_1.AST_NODE_TYPES.ExportSpecifier ||
                                ref.identifier.parent.type ===
                                    utils_1.AST_NODE_TYPES.ExportDefaultDeclaration ||
                                ref.identifier.parent.type ===
                                    utils_1.AST_NODE_TYPES.TSExportAssignment) &&
                                ref.isValueReference &&
                                ref.isTypeReference) {
                                return node.importKind === 'type';
                            }
                            if (ref.isValueReference) {
                                let parent = ref.identifier.parent;
                                let child = ref.identifier;
                                while (parent) {
                                    switch (parent.type) {
                                        // CASE 1:
                                        // `type T = typeof foo` will create a value reference because "foo" must be a value type
                                        // however this value reference is safe to use with type-only imports
                                        case utils_1.AST_NODE_TYPES.TSTypeQuery:
                                            return true;
                                        case utils_1.AST_NODE_TYPES.TSQualifiedName:
                                            // TSTypeQuery must have a TSESTree.EntityName as its child, so we can filter here and break early
                                            if (parent.left !== child) {
                                                return false;
                                            }
                                            child = parent;
                                            parent = parent.parent;
                                            continue;
                                        // END CASE 1
                                        //////////////
                                        // CASE 2:
                                        // `type T = { [foo]: string }` will create a value reference because "foo" must be a value type
                                        // however this value reference is safe to use with type-only imports.
                                        // Also this is represented as a non-type AST - hence it uses MemberExpression
                                        case utils_1.AST_NODE_TYPES.TSPropertySignature:
                                            return parent.key === child;
                                        case utils_1.AST_NODE_TYPES.MemberExpression:
                                            if (parent.object !== child) {
                                                return false;
                                            }
                                            child = parent;
                                            parent = parent.parent;
                                            continue;
                                        // END CASE 2
                                        default:
                                            return false;
                                    }
                                }
                            }
                            return ref.isTypeReference;
                        });
                        if (onlyHasTypeReferences) {
                            typeSpecifiers.push(specifier);
                        }
                        else {
                            valueSpecifiers.push(specifier);
                        }
                    }
                }
                if (node.importKind === 'value' && typeSpecifiers.length) {
                    sourceImports.reportValueImports.push({
                        node,
                        inlineTypeSpecifiers,
                        typeSpecifiers,
                        unusedSpecifiers,
                        valueSpecifiers,
                    });
                }
            },
            'Program:exit'() {
                if (hasDecoratorMetadata) {
                    // Experimental decorator metadata is bowl of poop that cannot be
                    // supported based on pure syntactic analysis.
                    //
                    // So we can do one of two things:
                    // 1) add type-information to the rule in a breaking change and
                    //    prevent users from using it so that we can fully support this
                    //    case.
                    // 2) make the rule ignore all imports that are used in a file that
                    //    might have decorator metadata.
                    //
                    // (1) is has huge impact and prevents the rule from being used by 99%
                    // of users Frankly - it's a straight-up bad option. So instead we
                    // choose with option (2) and just avoid reporting on any imports in a
                    // file with both emitDecoratorMetadata AND decorators
                    //
                    // For more context see the discussion in this issue and its linked
                    // issues:
                    // https://github.com/typescript-eslint/typescript-eslint/issues/5468
                    //
                    //
                    // NOTE - in TS 5.0 `experimentalDecorators` became the legacy option,
                    // replaced with un-flagged, stable decorators and thus the type-aware
                    // emitDecoratorMetadata implementation also became legacy. in TS 5.2
                    // support for the new, stable decorator metadata proposal was added -
                    // however this proposal does not include type information
                    //
                    //
                    // PHEW. So TL;DR what does all this mean?
                    // - if you use experimentalDecorators:true,
                    //   emitDecoratorMetadata:true, and have a decorator in the file -
                    //   the rule will do nothing in the file out of an abundance of
                    //   caution.
                    // - else the rule will work as normal.
                    return;
                }
                for (const sourceImports of Object.values(sourceImportsMap)) {
                    if (sourceImports.reportValueImports.length === 0) {
                        // nothing to fix. value specifiers and type specifiers are correctly written
                        continue;
                    }
                    for (const report of sourceImports.reportValueImports) {
                        if (report.valueSpecifiers.length === 0 &&
                            report.unusedSpecifiers.length === 0 &&
                            report.node.importKind !== 'type') {
                            /**
                             * checks if import has type assertions
                             * @example
                             * ```ts
                             * import * as type from 'mod' assert \{ type: 'json' \};
                             * ```
                             * https://github.com/typescript-eslint/typescript-eslint/issues/7527
                             */
                            if (report.node.attributes.length === 0) {
                                context.report({
                                    node: report.node,
                                    messageId: 'typeOverValue',
                                    *fix(fixer) {
                                        yield* fixToTypeImportDeclaration(fixer, report, sourceImports);
                                    },
                                });
                            }
                        }
                        else {
                            // we have a mixed type/value import or just value imports, so we need to split them out into multiple imports if separate-type-imports is configured
                            const importNames = report.typeSpecifiers.map(specifier => `"${specifier.local.name}"`);
                            const message = (() => {
                                const typeImports = (0, util_1.formatWordList)(importNames);
                                if (importNames.length === 1) {
                                    return {
                                        messageId: 'someImportsAreOnlyTypes',
                                        data: {
                                            typeImports,
                                        },
                                    };
                                }
                                return {
                                    messageId: 'someImportsAreOnlyTypes',
                                    data: {
                                        typeImports,
                                    },
                                };
                            })();
                            context.report({
                                node: report.node,
                                ...message,
                                *fix(fixer) {
                                    // take all the typeSpecifiers and put them on a new line
                                    yield* fixToTypeImportDeclaration(fixer, report, sourceImports);
                                },
                            });
                        }
                    }
                }
            },
        };
        function classifySpecifier(node) {
            const defaultSpecifier = node.specifiers[0].type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier
                ? node.specifiers[0]
                : null;
            const namespaceSpecifier = node.specifiers.find((specifier) => specifier.type === utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier) ?? null;
            const namedSpecifiers = node.specifiers.filter((specifier) => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier);
            return {
                defaultSpecifier,
                namedSpecifiers,
                namespaceSpecifier,
            };
        }
        /**
         * Returns information for fixing named specifiers, type or value
         */
        function getFixesNamedSpecifiers(fixer, node, subsetNamedSpecifiers, allNamedSpecifiers) {
            if (allNamedSpecifiers.length === 0) {
                return {
                    removeTypeNamedSpecifiers: [],
                    typeNamedSpecifiersText: '',
                };
            }
            const typeNamedSpecifiersTexts = [];
            const removeTypeNamedSpecifiers = [];
            if (subsetNamedSpecifiers.length === allNamedSpecifiers.length) {
                // import Foo, {Type1, Type2} from 'foo'
                // import DefType, {Type1, Type2} from 'foo'
                const openingBraceToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(subsetNamedSpecifiers[0], util_1.isOpeningBraceToken), util_1.NullThrowsReasons.MissingToken('{', node.type));
                const commaToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(openingBraceToken, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(',', node.type));
                const closingBraceToken = (0, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', node.type));
                // import DefType, {...} from 'foo'
                //               ^^^^^^^ remove
                removeTypeNamedSpecifiers.push(fixer.removeRange([commaToken.range[0], closingBraceToken.range[1]]));
                typeNamedSpecifiersTexts.push(context.sourceCode.text.slice(openingBraceToken.range[1], closingBraceToken.range[0]));
            }
            else {
                const namedSpecifierGroups = [];
                let group = [];
                for (const namedSpecifier of allNamedSpecifiers) {
                    if (subsetNamedSpecifiers.includes(namedSpecifier)) {
                        group.push(namedSpecifier);
                    }
                    else if (group.length) {
                        namedSpecifierGroups.push(group);
                        group = [];
                    }
                }
                if (group.length) {
                    namedSpecifierGroups.push(group);
                }
                for (const namedSpecifiers of namedSpecifierGroups) {
                    const { removeRange, textRange } = getNamedSpecifierRanges(namedSpecifiers, allNamedSpecifiers);
                    removeTypeNamedSpecifiers.push(fixer.removeRange(removeRange));
                    typeNamedSpecifiersTexts.push(context.sourceCode.text.slice(...textRange));
                }
            }
            return {
                removeTypeNamedSpecifiers,
                typeNamedSpecifiersText: typeNamedSpecifiersTexts.join(','),
            };
        }
        /**
         * Returns ranges for fixing named specifier.
         */
        function getNamedSpecifierRanges(namedSpecifierGroup, allNamedSpecifiers) {
            const first = namedSpecifierGroup[0];
            const last = namedSpecifierGroup[namedSpecifierGroup.length - 1];
            const removeRange = [first.range[0], last.range[1]];
            const textRange = [...removeRange];
            const before = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(first), util_1.NullThrowsReasons.MissingToken('token', 'first specifier'));
            textRange[0] = before.range[1];
            if ((0, util_1.isCommaToken)(before)) {
                removeRange[0] = before.range[0];
            }
            else {
                removeRange[0] = before.range[1];
            }
            const isFirst = allNamedSpecifiers[0] === first;
            const isLast = allNamedSpecifiers[allNamedSpecifiers.length - 1] === last;
            const after = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(last), util_1.NullThrowsReasons.MissingToken('token', 'last specifier'));
            textRange[1] = after.range[0];
            if ((isFirst || isLast) && (0, util_1.isCommaToken)(after)) {
                removeRange[1] = after.range[1];
            }
            return {
                removeRange,
                textRange,
            };
        }
        /**
         * insert specifiers to named import node.
         * e.g.
         * import type { Already, Type1, Type2 } from 'foo'
         *                        ^^^^^^^^^^^^^ insert
         */
        function fixInsertNamedSpecifiersInNamedSpecifierList(fixer, target, insertText) {
            const closingBraceToken = (0, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween((0, util_1.nullThrows)(context.sourceCode.getFirstToken(target), util_1.NullThrowsReasons.MissingToken('token before', 'import')), target.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', target.type));
            const before = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(closingBraceToken), util_1.NullThrowsReasons.MissingToken('token before', 'closing brace'));
            if (!(0, util_1.isCommaToken)(before) && !(0, util_1.isOpeningBraceToken)(before)) {
                insertText = `,${insertText}`;
            }
            return fixer.insertTextBefore(closingBraceToken, insertText);
        }
        /**
         * insert type keyword to named import node.
         * e.g.
         * import ADefault, { Already, type Type1, type Type2 } from 'foo'
         *                             ^^^^ insert
         */
        function* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeSpecifiers) {
            for (const spec of typeSpecifiers) {
                const insertText = context.sourceCode.text.slice(...spec.range);
                yield fixer.replaceTextRange(spec.range, `type ${insertText}`);
            }
        }
        function* fixInlineTypeImportDeclaration(fixer, report, sourceImports) {
            const { node } = report;
            // For a value import, will only add an inline type to named specifiers
            const { namedSpecifiers } = classifySpecifier(node);
            const typeNamedSpecifiers = namedSpecifiers.filter(specifier => report.typeSpecifiers.includes(specifier));
            if (sourceImports.valueImport) {
                // add import named type specifiers to its value import
                // import ValueA, { type A }
                //                  ^^^^ insert
                const { namedSpecifiers: valueImportNamedSpecifiers } = classifySpecifier(sourceImports.valueImport);
                if (sourceImports.valueOnlyNamedImport ||
                    valueImportNamedSpecifiers.length) {
                    yield* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeNamedSpecifiers);
                }
            }
        }
        function* fixToTypeImportDeclaration(fixer, report, sourceImports) {
            const { node } = report;
            const { defaultSpecifier, namedSpecifiers, namespaceSpecifier } = classifySpecifier(node);
            if (namespaceSpecifier && !defaultSpecifier) {
                // import * as types from 'foo'
                // checks for presence of import assertions
                if (node.attributes.length === 0) {
                    yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, false);
                }
                return;
            }
            if (defaultSpecifier) {
                if (report.typeSpecifiers.includes(defaultSpecifier) &&
                    namedSpecifiers.length === 0 &&
                    !namespaceSpecifier) {
                    // import Type from 'foo'
                    yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, true);
                    return;
                }
                if (fixStyle === 'inline-type-imports' &&
                    !report.typeSpecifiers.includes(defaultSpecifier) &&
                    namedSpecifiers.length > 0 &&
                    !namespaceSpecifier) {
                    // if there is a default specifier but it isn't a type specifier, then just add the inline type modifier to the named specifiers
                    // import AValue, {BValue, Type1, Type2} from 'foo'
                    yield* fixInlineTypeImportDeclaration(fixer, report, sourceImports);
                    return;
                }
            }
            else if (!namespaceSpecifier) {
                if (fixStyle === 'inline-type-imports' &&
                    namedSpecifiers.some(specifier => report.typeSpecifiers.includes(specifier))) {
                    // import {AValue, Type1, Type2} from 'foo'
                    yield* fixInlineTypeImportDeclaration(fixer, report, sourceImports);
                    return;
                }
                if (namedSpecifiers.every(specifier => report.typeSpecifiers.includes(specifier))) {
                    // import {Type1, Type2} from 'foo'
                    yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, false);
                    return;
                }
            }
            const typeNamedSpecifiers = namedSpecifiers.filter(specifier => report.typeSpecifiers.includes(specifier));
            const fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, typeNamedSpecifiers, namedSpecifiers);
            const afterFixes = [];
            if (typeNamedSpecifiers.length) {
                if (sourceImports.typeOnlyNamedImport) {
                    const insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.typeOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);
                    if (sourceImports.typeOnlyNamedImport.range[1] <= node.range[0]) {
                        yield insertTypeNamedSpecifiers;
                    }
                    else {
                        afterFixes.push(insertTypeNamedSpecifiers);
                    }
                }
                else {
                    // The import is both default and named.  Insert named on new line because can't mix default type import and named type imports
                    // eslint-disable-next-line no-lonely-if
                    if (fixStyle === 'inline-type-imports') {
                        yield fixer.insertTextBefore(node, `import {${typeNamedSpecifiers
                            .map(spec => {
                            const insertText = context.sourceCode.text.slice(...spec.range);
                            return `type ${insertText}`;
                        })
                            .join(', ')}} from ${context.sourceCode.getText(node.source)};\n`);
                    }
                    else {
                        yield fixer.insertTextBefore(node, `import type {${fixesNamedSpecifiers.typeNamedSpecifiersText}} from ${context.sourceCode.getText(node.source)};\n`);
                    }
                }
            }
            const fixesRemoveTypeNamespaceSpecifier = [];
            if (namespaceSpecifier &&
                report.typeSpecifiers.includes(namespaceSpecifier)) {
                // import Foo, * as Type from 'foo'
                // import DefType, * as Type from 'foo'
                // import DefType, * as Type from 'foo'
                const commaToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(namespaceSpecifier, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(',', node.type));
                // import Def, * as Ns from 'foo'
                //           ^^^^^^^^^ remove
                fixesRemoveTypeNamespaceSpecifier.push(fixer.removeRange([commaToken.range[0], namespaceSpecifier.range[1]]));
                // import type * as Ns from 'foo'
                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ insert
                yield fixer.insertTextBefore(node, `import type ${context.sourceCode.getText(namespaceSpecifier)} from ${context.sourceCode.getText(node.source)};\n`);
            }
            if (defaultSpecifier &&
                report.typeSpecifiers.includes(defaultSpecifier)) {
                if (report.typeSpecifiers.length === node.specifiers.length) {
                    const importToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken('import', node.type));
                    // import type Type from 'foo'
                    //        ^^^^ insert
                    yield fixer.insertTextAfter(importToken, ' type');
                }
                else {
                    const commaToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(defaultSpecifier, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(',', defaultSpecifier.type));
                    // import Type , {...} from 'foo'
                    //        ^^^^^ pick
                    const defaultText = context.sourceCode.text
                        .slice(defaultSpecifier.range[0], commaToken.range[0])
                        .trim();
                    yield fixer.insertTextBefore(node, `import type ${defaultText} from ${context.sourceCode.getText(node.source)};\n`);
                    const afterToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(commaToken, {
                        includeComments: true,
                    }), util_1.NullThrowsReasons.MissingToken('any token', node.type));
                    // import Type , {...} from 'foo'
                    //        ^^^^^^^ remove
                    yield fixer.removeRange([
                        defaultSpecifier.range[0],
                        afterToken.range[0],
                    ]);
                }
            }
            yield* fixesNamedSpecifiers.removeTypeNamedSpecifiers;
            yield* fixesRemoveTypeNamespaceSpecifier;
            yield* afterFixes;
        }
        function* fixInsertTypeSpecifierForImportDeclaration(fixer, node, isDefaultImport) {
            // import type Foo from 'foo'
            //       ^^^^^ insert
            const importToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken('import', node.type));
            yield fixer.insertTextAfter(importToken, ' type');
            if (isDefaultImport) {
                // Has default import
                const openingBraceToken = context.sourceCode.getFirstTokenBetween(importToken, node.source, util_1.isOpeningBraceToken);
                if (openingBraceToken) {
                    // Only braces. e.g. import Foo, {} from 'foo'
                    const commaToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(openingBraceToken, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(',', node.type));
                    const closingBraceToken = (0, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', node.type));
                    // import type Foo, {} from 'foo'
                    //                  ^^ remove
                    yield fixer.removeRange([
                        commaToken.range[0],
                        closingBraceToken.range[1],
                    ]);
                    const specifiersText = context.sourceCode.text.slice(commaToken.range[1], closingBraceToken.range[1]);
                    if (node.specifiers.length > 1) {
                        yield fixer.insertTextAfter(node, `\nimport type${specifiersText} from ${context.sourceCode.getText(node.source)};`);
                    }
                }
            }
            // make sure we don't do anything like `import type {type T} from 'foo';`
            for (const specifier of node.specifiers) {
                if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &&
                    specifier.importKind === 'type') {
                    yield* fixRemoveTypeSpecifierFromImportSpecifier(fixer, specifier);
                }
            }
        }
        function* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node) {
            // import type Foo from 'foo'
            //        ^^^^ remove
            const importToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken('import', node.type));
            const typeToken = (0, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(importToken, node.specifiers[0]?.local ?? node.source, util_1.isTypeKeyword), util_1.NullThrowsReasons.MissingToken('type', node.type));
            const afterToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(typeToken, { includeComments: true }), util_1.NullThrowsReasons.MissingToken('any token', node.type));
            yield fixer.removeRange([typeToken.range[0], afterToken.range[0]]);
        }
        function* fixRemoveTypeSpecifierFromImportSpecifier(fixer, node) {
            // import { type Foo } from 'foo'
            //          ^^^^ remove
            const typeToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isTypeKeyword), util_1.NullThrowsReasons.MissingToken('type', node.type));
            const afterToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(typeToken, { includeComments: true }), util_1.NullThrowsReasons.MissingToken('any token', node.type));
            yield fixer.removeRange([typeToken.range[0], afterToken.range[0]]);
        }
    },
});


--------------------------------------------------------------------------------
FILE: default-param-last.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"shouldBeLast", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: default-param-last.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'default-param-last',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce default parameters to be last',
            extendsBaseRule: true,
            frozen: true,
        },
        messages: {
            shouldBeLast: 'Default parameters should be last.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        /**
         * checks if node is optional parameter
         * @param node the node to be evaluated
         * @private
         */
        function isOptionalParam(node) {
            return ((node.type === utils_1.AST_NODE_TYPES.ArrayPattern ||
                node.type === utils_1.AST_NODE_TYPES.AssignmentPattern ||
                node.type === utils_1.AST_NODE_TYPES.Identifier ||
                node.type === utils_1.AST_NODE_TYPES.ObjectPattern ||
                node.type === utils_1.AST_NODE_TYPES.RestElement) &&
                node.optional);
        }
        /**
         * checks if node is plain parameter
         * @param node the node to be evaluated
         * @private
         */
        function isPlainParam(node) {
            return !(node.type === utils_1.AST_NODE_TYPES.AssignmentPattern ||
                node.type === utils_1.AST_NODE_TYPES.RestElement ||
                isOptionalParam(node));
        }
        function checkDefaultParamLast(node) {
            let hasSeenPlainParam = false;
            for (let i = node.params.length - 1; i >= 0; i--) {
                const current = node.params[i];
                const param = current.type === utils_1.AST_NODE_TYPES.TSParameterProperty
                    ? current.parameter
                    : current;
                if (isPlainParam(param)) {
                    hasSeenPlainParam = true;
                    continue;
                }
                if (hasSeenPlainParam &&
                    (isOptionalParam(param) ||
                        param.type === utils_1.AST_NODE_TYPES.AssignmentPattern)) {
                    context.report({ node: current, messageId: 'shouldBeLast' });
                }
            }
        }
        return {
            ArrowFunctionExpression: checkDefaultParamLast,
            FunctionDeclaration: checkDefaultParamLast,
            FunctionExpression: checkDefaultParamLast,
        };
    },
});


--------------------------------------------------------------------------------
FILE: dot-notation.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"useBrackets" | "useDot", [{
    allowIndexSignaturePropertyAccess?: boolean;
    allowKeywords?: boolean;
    allowPattern?: string;
    allowPrivateClassPropertyAccess?: boolean;
    allowProtectedClassPropertyAccess?: boolean;
}], unknown, {
    MemberExpression(node: TSESTree.MemberExpression): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"useBrackets" | "useDot", [{
    allowIndexSignaturePropertyAccess?: boolean;
    allowKeywords?: boolean;
    allowPattern?: string;
    allowPrivateClassPropertyAccess?: boolean;
    allowProtectedClassPropertyAccess?: boolean;
}], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: dot-notation.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('dot-notation');
const defaultOptions = [
    {
        allowIndexSignaturePropertyAccess: false,
        allowKeywords: true,
        allowPattern: '',
        allowPrivateClassPropertyAccess: false,
        allowProtectedClassPropertyAccess: false,
    },
];
exports.default = (0, util_1.createRule)({
    name: 'dot-notation',
    meta: {
        type: 'suggestion',
        defaultOptions,
        docs: {
            description: 'Enforce dot notation whenever possible',
            extendsBaseRule: true,
            frozen: true,
            recommended: 'stylistic',
            requiresTypeChecking: true,
        },
        fixable: baseRule.meta.fixable,
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowIndexSignaturePropertyAccess: {
                        type: 'boolean',
                        description: 'Whether to allow accessing properties matching an index signature with array notation.',
                    },
                    allowKeywords: {
                        type: 'boolean',
                        description: 'Whether to allow keywords such as ["class"]`.',
                    },
                    allowPattern: {
                        type: 'string',
                        description: 'Regular expression of names to allow.',
                    },
                    allowPrivateClassPropertyAccess: {
                        type: 'boolean',
                        description: 'Whether to allow accessing class members marked as `private` with array notation.',
                    },
                    allowProtectedClassPropertyAccess: {
                        type: 'boolean',
                        description: 'Whether to allow accessing class members marked as `protected` with array notation.',
                    },
                },
            },
        ],
    },
    defaultOptions,
    create(context, [options]) {
        const rules = baseRule.create(context);
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const allowPrivateClassPropertyAccess = options.allowPrivateClassPropertyAccess;
        const allowProtectedClassPropertyAccess = options.allowProtectedClassPropertyAccess;
        const allowIndexSignaturePropertyAccess = (options.allowIndexSignaturePropertyAccess ?? false) ||
            tsutils.isCompilerOptionEnabled(services.program.getCompilerOptions(), 'noPropertyAccessFromIndexSignature');
        return {
            MemberExpression(node) {
                if ((allowPrivateClassPropertyAccess ||
                    allowProtectedClassPropertyAccess ||
                    allowIndexSignaturePropertyAccess) &&
                    node.computed) {
                    // for perf reasons - only fetch symbols if we have to
                    const propertySymbol = services.getSymbolAtLocation(node.property) ??
                        services
                            .getTypeAtLocation(node.object)
                            .getNonNullableType()
                            .getProperties()
                            .find(propertySymbol => node.property.type === utils_1.AST_NODE_TYPES.Literal &&
                            propertySymbol.escapedName === node.property.value);
                    const modifierKind = (0, util_1.getModifiers)(propertySymbol?.getDeclarations()?.[0])?.[0].kind;
                    if ((allowPrivateClassPropertyAccess &&
                        modifierKind === ts.SyntaxKind.PrivateKeyword) ||
                        (allowProtectedClassPropertyAccess &&
                            modifierKind === ts.SyntaxKind.ProtectedKeyword)) {
                        return;
                    }
                    if (propertySymbol == null && allowIndexSignaturePropertyAccess) {
                        const objectType = services
                            .getTypeAtLocation(node.object)
                            .getNonNullableType();
                        const indexInfos = checker.getIndexInfosOfType(objectType);
                        if (indexInfos.some(info => info.keyType.flags & ts.TypeFlags.StringLike)) {
                            return;
                        }
                    }
                }
                rules.MemberExpression(node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: explicit-function-return-type.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowConciseArrowFunctionExpressionsStartingWithVoid?: boolean;
        allowDirectConstAssertionInArrowFunctions?: boolean;
        allowedNames?: string[];
        allowExpressions?: boolean;
        allowFunctionsWithoutTypeParameters?: boolean;
        allowHigherOrderFunctions?: boolean;
        allowIIFEs?: boolean;
        allowTypedFunctionExpressions?: boolean;
    }
];
export type MessageIds = 'missingReturnType';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingReturnType", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: explicit-function-return-type.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const explicitReturnTypeUtils_1 = require("../util/explicitReturnTypeUtils");
exports.default = (0, util_1.createRule)({
    name: 'explicit-function-return-type',
    meta: {
        type: 'problem',
        docs: {
            description: 'Require explicit return types on functions and class methods',
        },
        messages: {
            missingReturnType: 'Missing return type on function.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowConciseArrowFunctionExpressionsStartingWithVoid: {
                        type: 'boolean',
                        description: 'Whether to allow arrow functions that start with the `void` keyword.',
                    },
                    allowDirectConstAssertionInArrowFunctions: {
                        type: 'boolean',
                        description: 'Whether to ignore arrow functions immediately returning a `as const` value.',
                    },
                    allowedNames: {
                        type: 'array',
                        description: 'An array of function/method names that will not have their arguments or return values checked.',
                        items: {
                            type: 'string',
                        },
                    },
                    allowExpressions: {
                        type: 'boolean',
                        description: 'Whether to ignore function expressions (functions which are not part of a declaration).',
                    },
                    allowFunctionsWithoutTypeParameters: {
                        type: 'boolean',
                        description: "Whether to ignore functions that don't have generic type parameters.",
                    },
                    allowHigherOrderFunctions: {
                        type: 'boolean',
                        description: 'Whether to ignore functions immediately returning another function expression.',
                    },
                    allowIIFEs: {
                        type: 'boolean',
                        description: 'Whether to ignore immediately invoked function expressions (IIFEs).',
                    },
                    allowTypedFunctionExpressions: {
                        type: 'boolean',
                        description: 'Whether to ignore type annotations on the variable of function expressions.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowConciseArrowFunctionExpressionsStartingWithVoid: false,
            allowDirectConstAssertionInArrowFunctions: true,
            allowedNames: [],
            allowExpressions: false,
            allowFunctionsWithoutTypeParameters: false,
            allowHigherOrderFunctions: true,
            allowIIFEs: false,
            allowTypedFunctionExpressions: true,
        },
    ],
    create(context, [options]) {
        const functionInfoStack = [];
        function enterFunction(node) {
            functionInfoStack.push({
                node,
                returns: [],
            });
        }
        function popFunctionInfo(exitNodeType) {
            return (0, util_1.nullThrows)(functionInfoStack.pop(), `Stack should exist on ${exitNodeType} exit`);
        }
        function isAllowedFunction(node) {
            if (options.allowFunctionsWithoutTypeParameters && !node.typeParameters) {
                return true;
            }
            if (options.allowIIFEs && isIIFE(node)) {
                return true;
            }
            if (!options.allowedNames?.length) {
                return false;
            }
            if (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                node.type === utils_1.AST_NODE_TYPES.FunctionExpression) {
                const parent = node.parent;
                let funcName;
                if (node.id?.name) {
                    funcName = node.id.name;
                }
                else {
                    switch (parent.type) {
                        case utils_1.AST_NODE_TYPES.VariableDeclarator: {
                            if (parent.id.type === utils_1.AST_NODE_TYPES.Identifier) {
                                funcName = parent.id.name;
                            }
                            break;
                        }
                        case utils_1.AST_NODE_TYPES.MethodDefinition:
                        case utils_1.AST_NODE_TYPES.PropertyDefinition:
                        case utils_1.AST_NODE_TYPES.Property: {
                            if (parent.key.type === utils_1.AST_NODE_TYPES.Identifier &&
                                !parent.computed) {
                                funcName = parent.key.name;
                            }
                            break;
                        }
                    }
                }
                if (!!funcName && options.allowedNames.includes(funcName)) {
                    return true;
                }
            }
            if (node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration &&
                node.id &&
                options.allowedNames.includes(node.id.name)) {
                return true;
            }
            return false;
        }
        function isIIFE(node) {
            return node.parent.type === utils_1.AST_NODE_TYPES.CallExpression;
        }
        function exitFunctionExpression(node) {
            const info = popFunctionInfo('function expression');
            if (options.allowConciseArrowFunctionExpressionsStartingWithVoid &&
                node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&
                node.expression &&
                node.body.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                node.body.operator === 'void') {
                return;
            }
            if (isAllowedFunction(node)) {
                return;
            }
            if (options.allowTypedFunctionExpressions &&
                ((0, explicitReturnTypeUtils_1.isValidFunctionExpressionReturnType)(node, options) ||
                    (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node))) {
                return;
            }
            (0, explicitReturnTypeUtils_1.checkFunctionReturnType)(info, options, context.sourceCode, loc => context.report({
                loc,
                node,
                messageId: 'missingReturnType',
            }));
        }
        return {
            'ArrowFunctionExpression, FunctionExpression, FunctionDeclaration': enterFunction,
            'ArrowFunctionExpression:exit': exitFunctionExpression,
            'FunctionDeclaration:exit'(node) {
                const info = popFunctionInfo('function declaration');
                if (isAllowedFunction(node)) {
                    return;
                }
                if (options.allowTypedFunctionExpressions && node.returnType) {
                    return;
                }
                (0, explicitReturnTypeUtils_1.checkFunctionReturnType)(info, options, context.sourceCode, loc => context.report({
                    loc,
                    node,
                    messageId: 'missingReturnType',
                }));
            },
            'FunctionExpression:exit': exitFunctionExpression,
            ReturnStatement(node) {
                functionInfoStack.at(-1)?.returns.push(node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: explicit-member-accessibility.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
type AccessibilityLevel = 'explicit' | 'no-public' | 'off';
export interface Config {
    accessibility?: AccessibilityLevel;
    ignoredMethodNames?: string[];
    overrides?: {
        accessors?: AccessibilityLevel;
        constructors?: AccessibilityLevel;
        methods?: AccessibilityLevel;
        parameterProperties?: AccessibilityLevel;
        properties?: AccessibilityLevel;
    };
}
export type Options = [Config];
export type MessageIds = 'addExplicitAccessibility' | 'missingAccessibility' | 'unwantedPublicAccessibility';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: explicit-member-accessibility.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getMemberHeadLoc_1 = require("../util/getMemberHeadLoc");
const rangeToLoc_1 = require("../util/rangeToLoc");
exports.default = (0, util_1.createRule)({
    name: 'explicit-member-accessibility',
    meta: {
        type: 'problem',
        docs: {
            description: 'Require explicit accessibility modifiers on class properties and methods',
            // too opinionated to be recommended
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            addExplicitAccessibility: "Add '{{ type }}' accessibility modifier",
            missingAccessibility: 'Missing accessibility modifier on {{type}} {{name}}.',
            unwantedPublicAccessibility: 'Public accessibility modifier on {{type}} {{name}}.',
        },
        schema: [
            {
                type: 'object',
                $defs: {
                    accessibilityLevel: {
                        oneOf: [
                            {
                                type: 'string',
                                description: 'Always require an accessor.',
                                enum: ['explicit'],
                            },
                            {
                                type: 'string',
                                description: 'Require an accessor except when public.',
                                enum: ['no-public'],
                            },
                            {
                                type: 'string',
                                description: 'Never check whether there is an accessor.',
                                enum: ['off'],
                            },
                        ],
                    },
                },
                additionalProperties: false,
                properties: {
                    accessibility: {
                        $ref: '#/items/0/$defs/accessibilityLevel',
                        description: 'Which accessibility modifier is required to exist or not exist.',
                    },
                    ignoredMethodNames: {
                        type: 'array',
                        description: 'Specific method names that may be ignored.',
                        items: {
                            type: 'string',
                        },
                    },
                    overrides: {
                        type: 'object',
                        additionalProperties: false,
                        description: 'Changes to required accessibility modifiers for specific kinds of class members.',
                        properties: {
                            accessors: {
                                $ref: '#/items/0/$defs/accessibilityLevel',
                                description: 'Which member accessibility modifier requirements to apply for accessors.',
                            },
                            constructors: {
                                $ref: '#/items/0/$defs/accessibilityLevel',
                                description: 'Which member accessibility modifier requirements to apply for constructors.',
                            },
                            methods: {
                                $ref: '#/items/0/$defs/accessibilityLevel',
                                description: 'Which member accessibility modifier requirements to apply for methods.',
                            },
                            parameterProperties: {
                                $ref: '#/items/0/$defs/accessibilityLevel',
                                description: 'Which member accessibility modifier requirements to apply for parameterProperties.',
                            },
                            properties: {
                                $ref: '#/items/0/$defs/accessibilityLevel',
                                description: 'Which member accessibility modifier requirements to apply for properties.',
                            },
                        },
                    },
                },
            },
        ],
    },
    defaultOptions: [{ accessibility: 'explicit' }],
    create(context, [option]) {
        const baseCheck = option.accessibility ?? 'explicit';
        const overrides = option.overrides ?? {};
        const ctorCheck = overrides.constructors ?? baseCheck;
        const accessorCheck = overrides.accessors ?? baseCheck;
        const methodCheck = overrides.methods ?? baseCheck;
        const propCheck = overrides.properties ?? baseCheck;
        const paramPropCheck = overrides.parameterProperties ?? baseCheck;
        const ignoredMethodNames = new Set(option.ignoredMethodNames ?? []);
        /**
         * Checks if a method declaration has an accessibility modifier.
         * @param methodDefinition The node representing a MethodDefinition.
         */
        function checkMethodAccessibilityModifier(methodDefinition) {
            if (methodDefinition.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                return;
            }
            let nodeType = 'method definition';
            let check = baseCheck;
            switch (methodDefinition.kind) {
                case 'method':
                    check = methodCheck;
                    break;
                case 'constructor':
                    check = ctorCheck;
                    break;
                case 'get':
                case 'set':
                    check = accessorCheck;
                    nodeType = `${methodDefinition.kind} property accessor`;
                    break;
            }
            const { name: methodName } = (0, util_1.getNameFromMember)(methodDefinition, context.sourceCode);
            if (check === 'off' || ignoredMethodNames.has(methodName)) {
                return;
            }
            if (check === 'no-public' &&
                methodDefinition.accessibility === 'public') {
                const publicKeyword = findPublicKeyword(methodDefinition);
                context.report({
                    loc: (0, rangeToLoc_1.rangeToLoc)(context.sourceCode, publicKeyword.range),
                    messageId: 'unwantedPublicAccessibility',
                    data: {
                        name: methodName,
                        type: nodeType,
                    },
                    fix: fixer => fixer.removeRange(publicKeyword.rangeToRemove),
                });
            }
            else if (check === 'explicit' && !methodDefinition.accessibility) {
                context.report({
                    loc: (0, getMemberHeadLoc_1.getMemberHeadLoc)(context.sourceCode, methodDefinition),
                    messageId: 'missingAccessibility',
                    data: {
                        name: methodName,
                        type: nodeType,
                    },
                    suggest: getMissingAccessibilitySuggestions(methodDefinition),
                });
            }
        }
        /**
         * Returns an object containing a range that corresponds to the "public"
         * keyword for a node, and the range that would need to be removed to
         * remove the "public" keyword (including associated whitespace).
         */
        function findPublicKeyword(node) {
            const tokens = context.sourceCode.getTokens(node);
            let rangeToRemove;
            let keywordRange;
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                if (token.type === utils_1.AST_TOKEN_TYPES.Keyword &&
                    token.value === 'public') {
                    keywordRange = structuredClone(token.range);
                    const commentsAfterPublicKeyword = context.sourceCode.getCommentsAfter(token);
                    if (commentsAfterPublicKeyword.length) {
                        // public /* Hi there! */ static foo()
                        // ^^^^^^^
                        rangeToRemove = [
                            token.range[0],
                            commentsAfterPublicKeyword[0].range[0],
                        ];
                        break;
                    }
                    else {
                        // public static foo()
                        // ^^^^^^^
                        rangeToRemove = [token.range[0], tokens[i + 1].range[0]];
                        break;
                    }
                }
            }
            return { range: keywordRange, rangeToRemove };
        }
        /**
         * Creates a fixer that adds an accessibility modifier keyword
         */
        function getMissingAccessibilitySuggestions(node) {
            function fix(accessibility, fixer) {
                if (node.decorators.length) {
                    const lastDecorator = node.decorators[node.decorators.length - 1];
                    const nextToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(lastDecorator), util_1.NullThrowsReasons.MissingToken('token', 'last decorator'));
                    return fixer.insertTextBefore(nextToken, `${accessibility} `);
                }
                return fixer.insertTextBefore(node, `${accessibility} `);
            }
            return [
                {
                    messageId: 'addExplicitAccessibility',
                    data: { type: 'public' },
                    fix: fixer => fix('public', fixer),
                },
                {
                    messageId: 'addExplicitAccessibility',
                    data: { type: 'private' },
                    fix: fixer => fix('private', fixer),
                },
                {
                    messageId: 'addExplicitAccessibility',
                    data: { type: 'protected' },
                    fix: fixer => fix('protected', fixer),
                },
            ];
        }
        /**
         * Checks if property has an accessibility modifier.
         * @param propertyDefinition The node representing a PropertyDefinition.
         */
        function checkPropertyAccessibilityModifier(propertyDefinition) {
            if (propertyDefinition.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                return;
            }
            const nodeType = 'class property';
            const { name: propertyName } = (0, util_1.getNameFromMember)(propertyDefinition, context.sourceCode);
            if (propCheck === 'no-public' &&
                propertyDefinition.accessibility === 'public') {
                const publicKeywordRange = findPublicKeyword(propertyDefinition);
                context.report({
                    loc: (0, rangeToLoc_1.rangeToLoc)(context.sourceCode, publicKeywordRange.range),
                    messageId: 'unwantedPublicAccessibility',
                    data: {
                        name: propertyName,
                        type: nodeType,
                    },
                    fix: fixer => fixer.removeRange(publicKeywordRange.rangeToRemove),
                });
            }
            else if (propCheck === 'explicit' &&
                !propertyDefinition.accessibility) {
                context.report({
                    loc: (0, getMemberHeadLoc_1.getMemberHeadLoc)(context.sourceCode, propertyDefinition),
                    messageId: 'missingAccessibility',
                    data: {
                        name: propertyName,
                        type: nodeType,
                    },
                    suggest: getMissingAccessibilitySuggestions(propertyDefinition),
                });
            }
        }
        /**
         * Checks that the parameter property has the desired accessibility modifiers set.
         * @param node The node representing a Parameter Property
         */
        function checkParameterPropertyAccessibilityModifier(node) {
            const nodeType = 'parameter property';
            const nodeName = node.parameter.type === utils_1.AST_NODE_TYPES.Identifier
                ? node.parameter.name
                : node.parameter.left.name;
            switch (paramPropCheck) {
                case 'explicit': {
                    if (!node.accessibility) {
                        context.report({
                            loc: (0, getMemberHeadLoc_1.getParameterPropertyHeadLoc)(context.sourceCode, node, nodeName),
                            messageId: 'missingAccessibility',
                            data: {
                                name: nodeName,
                                type: nodeType,
                            },
                            suggest: getMissingAccessibilitySuggestions(node),
                        });
                    }
                    break;
                }
                case 'no-public': {
                    if (node.accessibility === 'public' && node.readonly) {
                        const publicKeyword = findPublicKeyword(node);
                        context.report({
                            loc: (0, rangeToLoc_1.rangeToLoc)(context.sourceCode, publicKeyword.range),
                            messageId: 'unwantedPublicAccessibility',
                            data: {
                                name: nodeName,
                                type: nodeType,
                            },
                            fix: fixer => fixer.removeRange(publicKeyword.rangeToRemove),
                        });
                    }
                    break;
                }
            }
        }
        return {
            'MethodDefinition, TSAbstractMethodDefinition': checkMethodAccessibilityModifier,
            'PropertyDefinition, TSAbstractPropertyDefinition, AccessorProperty, TSAbstractAccessorProperty': checkPropertyAccessibilityModifier,
            TSParameterProperty: checkParameterPropertyAccessibilityModifier,
        };
    },
});


--------------------------------------------------------------------------------
FILE: explicit-module-boundary-types.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowArgumentsExplicitlyTypedAsAny?: boolean;
        allowDirectConstAssertionInArrowFunctions?: boolean;
        allowedNames?: string[];
        allowHigherOrderFunctions?: boolean;
        allowTypedFunctionExpressions?: boolean;
        allowOverloadFunctions?: boolean;
    }
];
export type MessageIds = 'anyTypedArg' | 'anyTypedArgUnnamed' | 'missingArgType' | 'missingArgTypeUnnamed' | 'missingReturnType';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: explicit-module-boundary-types.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const explicitReturnTypeUtils_1 = require("../util/explicitReturnTypeUtils");
exports.default = (0, util_1.createRule)({
    name: 'explicit-module-boundary-types',
    meta: {
        type: 'problem',
        docs: {
            description: "Require explicit return and argument types on exported functions' and classes' public class methods",
        },
        messages: {
            anyTypedArg: "Argument '{{name}}' should be typed with a non-any type.",
            anyTypedArgUnnamed: '{{type}} argument should be typed with a non-any type.',
            missingArgType: "Argument '{{name}}' should be typed.",
            missingArgTypeUnnamed: '{{type}} argument should be typed.',
            missingReturnType: 'Missing return type on function.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowArgumentsExplicitlyTypedAsAny: {
                        type: 'boolean',
                        description: 'Whether to ignore arguments that are explicitly typed as `any`.',
                    },
                    allowDirectConstAssertionInArrowFunctions: {
                        type: 'boolean',
                        description: [
                            'Whether to ignore return type annotations on body-less arrow functions that return an `as const` type assertion.',
                            'You must still type the parameters of the function.',
                        ].join('\n'),
                    },
                    allowedNames: {
                        type: 'array',
                        description: 'An array of function/method names that will not have their arguments or return values checked.',
                        items: {
                            type: 'string',
                        },
                    },
                    allowHigherOrderFunctions: {
                        type: 'boolean',
                        description: [
                            'Whether to ignore return type annotations on functions immediately returning another function expression.',
                            'You must still type the parameters of the function.',
                        ].join('\n'),
                    },
                    allowOverloadFunctions: {
                        type: 'boolean',
                        description: 'Whether to ignore return type annotations on functions with overload signatures.',
                    },
                    allowTypedFunctionExpressions: {
                        type: 'boolean',
                        description: 'Whether to ignore type annotations on the variable of a function expression.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowArgumentsExplicitlyTypedAsAny: false,
            allowDirectConstAssertionInArrowFunctions: true,
            allowedNames: [],
            allowHigherOrderFunctions: true,
            allowOverloadFunctions: false,
            allowTypedFunctionExpressions: true,
        },
    ],
    create(context, [options]) {
        // tracks all of the functions we've already checked
        const checkedFunctions = new Set();
        const functionStack = [];
        const functionReturnsMap = new Map();
        // all nodes visited, avoids infinite recursion for cyclic references
        // (such as class member referring to itself)
        const alreadyVisited = new Set();
        function getReturnsInFunction(node) {
            return functionReturnsMap.get(node) ?? [];
        }
        function enterFunction(node) {
            functionStack.push(node);
            functionReturnsMap.set(node, []);
        }
        function exitFunction() {
            functionStack.pop();
        }
        /*
        # How the rule works:
    
        As the rule traverses the AST, it immediately checks every single function that it finds is exported.
        "exported" means that it is either directly exported, or that its name is exported.
    
        It also collects a list of every single function it finds on the way, but does not check them.
        After it's finished traversing the AST, it then iterates through the list of found functions, and checks to see if
        any of them are part of a higher-order function
        */
        return {
            'ArrowFunctionExpression, FunctionDeclaration, FunctionExpression': enterFunction,
            'ArrowFunctionExpression:exit': exitFunction,
            'ExportDefaultDeclaration:exit'(node) {
                checkNode(node.declaration);
            },
            'ExportNamedDeclaration:not([source]):exit'(node) {
                if (node.declaration) {
                    checkNode(node.declaration);
                }
                else {
                    for (const specifier of node.specifiers) {
                        followReference(specifier.local);
                    }
                }
            },
            'FunctionDeclaration:exit': exitFunction,
            'FunctionExpression:exit': exitFunction,
            'Program:exit'() {
                for (const [node, returns] of functionReturnsMap) {
                    if (isExportedHigherOrderFunction({ node, returns })) {
                        checkNode(node);
                    }
                }
            },
            ReturnStatement(node) {
                const current = functionStack[functionStack.length - 1];
                functionReturnsMap.get(current)?.push(node);
            },
            'TSExportAssignment:exit'(node) {
                checkNode(node.expression);
            },
        };
        function checkParameters(node) {
            function checkParameter(param) {
                function report(namedMessageId, unnamedMessageId) {
                    if (param.type === utils_1.AST_NODE_TYPES.Identifier) {
                        context.report({
                            node: param,
                            messageId: namedMessageId,
                            data: { name: param.name },
                        });
                    }
                    else if (param.type === utils_1.AST_NODE_TYPES.ArrayPattern) {
                        context.report({
                            node: param,
                            messageId: unnamedMessageId,
                            data: { type: 'Array pattern' },
                        });
                    }
                    else if (param.type === utils_1.AST_NODE_TYPES.ObjectPattern) {
                        context.report({
                            node: param,
                            messageId: unnamedMessageId,
                            data: { type: 'Object pattern' },
                        });
                    }
                    else if (param.type === utils_1.AST_NODE_TYPES.RestElement) {
                        if (param.argument.type === utils_1.AST_NODE_TYPES.Identifier) {
                            context.report({
                                node: param,
                                messageId: namedMessageId,
                                data: { name: param.argument.name },
                            });
                        }
                        else {
                            context.report({
                                node: param,
                                messageId: unnamedMessageId,
                                data: { type: 'Rest' },
                            });
                        }
                    }
                }
                switch (param.type) {
                    case utils_1.AST_NODE_TYPES.ArrayPattern:
                    case utils_1.AST_NODE_TYPES.Identifier:
                    case utils_1.AST_NODE_TYPES.ObjectPattern:
                    case utils_1.AST_NODE_TYPES.RestElement:
                        if (!param.typeAnnotation) {
                            report('missingArgType', 'missingArgTypeUnnamed');
                        }
                        else if (options.allowArgumentsExplicitlyTypedAsAny !== true &&
                            param.typeAnnotation.typeAnnotation.type ===
                                utils_1.AST_NODE_TYPES.TSAnyKeyword) {
                            report('anyTypedArg', 'anyTypedArgUnnamed');
                        }
                        return;
                    case utils_1.AST_NODE_TYPES.TSParameterProperty:
                        return checkParameter(param.parameter);
                    case utils_1.AST_NODE_TYPES.AssignmentPattern: // ignored as it has a type via its assignment
                        return;
                }
            }
            for (const arg of node.params) {
                checkParameter(arg);
            }
        }
        /**
         * Checks if a function name is allowed and should not be checked.
         */
        function isAllowedName(node) {
            if (!node || !options.allowedNames || options.allowedNames.length === 0) {
                return false;
            }
            if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator ||
                node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration) {
                return (node.id?.type === utils_1.AST_NODE_TYPES.Identifier &&
                    options.allowedNames.includes(node.id.name));
            }
            if (node.type === utils_1.AST_NODE_TYPES.MethodDefinition ||
                node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
                (node.type === utils_1.AST_NODE_TYPES.Property && node.method) ||
                node.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||
                node.type === utils_1.AST_NODE_TYPES.AccessorProperty) {
                return (0, util_1.isStaticMemberAccessOfValue)(node, context, ...options.allowedNames);
            }
            return false;
        }
        function isExportedHigherOrderFunction({ node, }) {
            let current = node.parent;
            while (current) {
                if (current.type === utils_1.AST_NODE_TYPES.ReturnStatement) {
                    // the parent of a return will always be a block statement, so we can skip over it
                    current = current.parent.parent;
                    continue;
                }
                if (!(0, util_1.isFunction)(current)) {
                    return false;
                }
                const returns = getReturnsInFunction(current);
                if (!(0, explicitReturnTypeUtils_1.doesImmediatelyReturnFunctionExpression)({ node: current, returns })) {
                    return false;
                }
                if (checkedFunctions.has(current)) {
                    return true;
                }
                current = current.parent;
            }
            return false;
        }
        function followReference(node) {
            const scope = context.sourceCode.getScope(node);
            const variable = scope.set.get(node.name);
            /* istanbul ignore if */ if (!variable) {
                return;
            }
            // check all of the definitions
            for (const definition of variable.defs) {
                // cases we don't care about in this rule
                if ([
                    scope_manager_1.DefinitionType.CatchClause,
                    scope_manager_1.DefinitionType.ImplicitGlobalVariable,
                    scope_manager_1.DefinitionType.ImportBinding,
                    scope_manager_1.DefinitionType.Parameter,
                ].includes(definition.type)) {
                    continue;
                }
                checkNode(definition.node);
            }
            // follow references to find writes to the variable
            for (const reference of variable.references) {
                if (
                // we don't want to check the initialization ref, as this is handled by the declaration check
                !reference.init &&
                    reference.writeExpr) {
                    checkNode(reference.writeExpr);
                }
            }
        }
        function checkNode(node) {
            if (node == null || alreadyVisited.has(node)) {
                return;
            }
            alreadyVisited.add(node);
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                case utils_1.AST_NODE_TYPES.FunctionExpression: {
                    const returns = getReturnsInFunction(node);
                    return checkFunctionExpression({ node, returns });
                }
                case utils_1.AST_NODE_TYPES.ArrayExpression:
                    for (const element of node.elements) {
                        checkNode(element);
                    }
                    return;
                case utils_1.AST_NODE_TYPES.PropertyDefinition:
                case utils_1.AST_NODE_TYPES.AccessorProperty:
                case utils_1.AST_NODE_TYPES.MethodDefinition:
                case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
                    if (node.accessibility === 'private' ||
                        node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                        return;
                    }
                    return checkNode(node.value);
                case utils_1.AST_NODE_TYPES.ClassDeclaration:
                case utils_1.AST_NODE_TYPES.ClassExpression:
                    for (const element of node.body.body) {
                        checkNode(element);
                    }
                    return;
                case utils_1.AST_NODE_TYPES.FunctionDeclaration: {
                    const returns = getReturnsInFunction(node);
                    return checkFunction({ node, returns });
                }
                case utils_1.AST_NODE_TYPES.Identifier:
                    return followReference(node);
                case utils_1.AST_NODE_TYPES.ObjectExpression:
                    for (const property of node.properties) {
                        checkNode(property);
                    }
                    return;
                case utils_1.AST_NODE_TYPES.Property:
                    return checkNode(node.value);
                case utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression:
                    return checkEmptyBodyFunctionExpression(node);
                case utils_1.AST_NODE_TYPES.VariableDeclaration:
                    for (const declaration of node.declarations) {
                        checkNode(declaration);
                    }
                    return;
                case utils_1.AST_NODE_TYPES.VariableDeclarator:
                    return checkNode(node.init);
            }
        }
        function checkEmptyBodyFunctionExpression(node) {
            const isConstructor = node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                node.parent.kind === 'constructor';
            const isSetAccessor = (node.parent.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
                node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition) &&
                node.parent.kind === 'set';
            if (!isConstructor && !isSetAccessor && !node.returnType) {
                context.report({
                    node,
                    messageId: 'missingReturnType',
                });
            }
            checkParameters(node);
        }
        function checkFunctionExpression({ node, returns, }) {
            if (checkedFunctions.has(node)) {
                return;
            }
            checkedFunctions.add(node);
            if (isAllowedName(node.parent) ||
                (0, explicitReturnTypeUtils_1.isTypedFunctionExpression)(node, options) ||
                (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {
                return;
            }
            if (options.allowOverloadFunctions &&
                node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                (0, util_1.hasOverloadSignatures)(node.parent, context)) {
                return;
            }
            (0, explicitReturnTypeUtils_1.checkFunctionExpressionReturnType)({ node, returns }, options, context.sourceCode, loc => {
                context.report({
                    loc,
                    node,
                    messageId: 'missingReturnType',
                });
            });
            checkParameters(node);
        }
        function checkFunction({ node, returns, }) {
            if (checkedFunctions.has(node)) {
                return;
            }
            checkedFunctions.add(node);
            if (isAllowedName(node) || (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {
                return;
            }
            if (options.allowOverloadFunctions &&
                (0, util_1.hasOverloadSignatures)(node, context)) {
                return;
            }
            (0, explicitReturnTypeUtils_1.checkFunctionReturnType)({ node, returns }, options, context.sourceCode, loc => {
                context.report({
                    loc,
                    node,
                    messageId: 'missingReturnType',
                });
            });
            checkParameters(node);
        }
    },
});


--------------------------------------------------------------------------------
FILE: index.d.ts
--------------------------------------------------------------------------------

declare const rules: {
    'adjacent-overload-signatures': import("@typescript-eslint/utils/ts-eslint").RuleModule<"adjacentSignature", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'array-type': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./array-type").MessageIds, import("./array-type").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'await-thenable': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./await-thenable").MessageId, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'ban-ts-comment': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./ban-ts-comment").MessageIds, import("./ban-ts-comment").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'ban-tslint-comment': import("@typescript-eslint/utils/ts-eslint").RuleModule<"commentDetected", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'class-literal-property-style': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./class-literal-property-style").MessageIds, import("./class-literal-property-style").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'class-methods-use-this': import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingThis", import("./class-methods-use-this").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'consistent-generic-constructors': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./consistent-generic-constructors").MessageIds, import("./consistent-generic-constructors").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'consistent-indexed-object-style': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./consistent-indexed-object-style").MessageIds, import("./consistent-indexed-object-style").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'consistent-return': import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingReturn" | "missingReturnValue" | "unexpectedReturnValue", [({
        treatUndefinedAsUnspecified?: boolean;
    } | undefined)?], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'consistent-type-assertions': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./consistent-type-assertions").MessageIds, import("./consistent-type-assertions").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'consistent-type-definitions': import("@typescript-eslint/utils/ts-eslint").RuleModule<"interfaceOverType" | "typeOverInterface", [string], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'consistent-type-exports': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./consistent-type-exports").MessageIds, import("./consistent-type-exports").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'consistent-type-imports': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./consistent-type-imports").MessageIds, import("./consistent-type-imports").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'default-param-last': import("@typescript-eslint/utils/ts-eslint").RuleModule<"shouldBeLast", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'dot-notation': import("@typescript-eslint/utils/ts-eslint").RuleModule<"useBrackets" | "useDot", [{
        allowIndexSignaturePropertyAccess?: boolean;
        allowKeywords?: boolean;
        allowPattern?: string;
        allowPrivateClassPropertyAccess?: boolean;
        allowProtectedClassPropertyAccess?: boolean;
    }], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'explicit-function-return-type': import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingReturnType", import("./explicit-function-return-type").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'explicit-member-accessibility': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./explicit-member-accessibility").MessageIds, import("./explicit-member-accessibility").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'explicit-module-boundary-types': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./explicit-module-boundary-types").MessageIds, import("./explicit-module-boundary-types").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'init-declarations': import("@typescript-eslint/utils/ts-eslint").RuleModule<"initialized" | "notInitialized", ["always" | "never", ({
        ignoreForLoopInit?: boolean;
    } | undefined)?], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'max-params': import("@typescript-eslint/utils/ts-eslint").RuleModule<"exceed", ({
        countVoidThis?: boolean;
        max: number;
    } | {
        countVoidThis?: boolean;
        maximum: number;
    })[], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'member-ordering': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./member-ordering").MessageIds, import("./member-ordering").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'method-signature-style': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./method-signature-style").MessageIds, import("./method-signature-style").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'naming-convention': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./naming-convention").MessageIds, import("./naming-convention").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-array-constructor': import("@typescript-eslint/utils/ts-eslint").RuleModule<"useLiteral", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-array-delete': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-array-delete").MessageId, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-base-to-string': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-base-to-string").MessageIds, import("./no-base-to-string").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-confusing-non-null-assertion': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-confusing-non-null-assertion").MessageId, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-confusing-void-expression': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-confusing-void-expression").MessageId, import("./no-confusing-void-expression").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-deprecated': import("@typescript-eslint/utils/ts-eslint").RuleModule<"deprecated" | "deprecatedWithReason", [{
        allow?: import("@typescript-eslint/type-utils").TypeOrValueSpecifier[];
    }], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-dupe-class-members': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpected", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-duplicate-enum-values': import("@typescript-eslint/utils/ts-eslint").RuleModule<"duplicateValue", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-duplicate-type-constituents': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-duplicate-type-constituents").MessageIds, import("./no-duplicate-type-constituents").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-dynamic-delete': import("@typescript-eslint/utils/ts-eslint").RuleModule<"dynamicDelete", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-empty-function': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpected" | "suggestComment", [{
        allow?: string[];
    }], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-empty-interface': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-empty-interface").MessageIds, import("./no-empty-interface").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-empty-object-type': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-empty-object-type").MessageIds, import("./no-empty-object-type").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-explicit-any': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-explicit-any").MessageIds, import("./no-explicit-any").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-extra-non-null-assertion': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noExtraNonNullAssertion", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-extraneous-class': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-extraneous-class").MessageIds, import("./no-extraneous-class").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-floating-promises': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-floating-promises").MessageId, import("./no-floating-promises").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-for-in-array': import("@typescript-eslint/utils/ts-eslint").RuleModule<"forInViolation", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-implied-eval': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noFunctionConstructor" | "noImpliedEvalError", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-import-type-side-effects': import("@typescript-eslint/utils/ts-eslint").RuleModule<"useTopLevelQualifier", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-inferrable-types': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noInferrableType", import("./no-inferrable-types").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-invalid-this': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpectedThis", [({
        capIsConstructor?: boolean;
    } | undefined)?], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-invalid-void-type': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-invalid-void-type").MessageIds, [import("./no-invalid-void-type").Options], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-loop-func': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeRefs", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-loss-of-precision': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noLossOfPrecision", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-magic-numbers': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noMagic", [{
        detectObjects?: boolean;
        enforceConst?: boolean;
        ignore?: (number | string)[];
        ignoreArrayIndexes?: boolean;
        ignoreEnums?: boolean;
        ignoreNumericLiteralTypes?: boolean;
        ignoreReadonlyClassProperties?: boolean;
        ignoreTypeIndexes?: boolean;
    }], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-meaningless-void-operator': import("@typescript-eslint/utils/ts-eslint").RuleModule<"meaninglessVoidOperator" | "removeVoid", import("./no-meaningless-void-operator").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-misused-new': import("@typescript-eslint/utils/ts-eslint").RuleModule<"errorMessageClass" | "errorMessageInterface", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-misused-promises': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-misused-promises").MessageId, import("./no-misused-promises").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-misused-spread': import("@typescript-eslint/utils/ts-eslint").RuleModule<"addAwait" | "noArraySpreadInObject" | "noClassDeclarationSpreadInObject" | "noClassInstanceSpreadInObject" | "noFunctionSpreadInObject" | "noIterableSpreadInObject" | "noMapSpreadInObject" | "noPromiseSpreadInObject" | "noStringSpread" | "replaceMapSpreadInObject", [{
        allow?: import("@typescript-eslint/type-utils").TypeOrValueSpecifier[];
    }], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-mixed-enums': import("@typescript-eslint/utils/ts-eslint").RuleModule<"mixed", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-namespace': import("@typescript-eslint/utils/ts-eslint").RuleModule<"moduleSyntaxIsPreferred", import("./no-namespace").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-non-null-asserted-nullish-coalescing': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noNonNullAssertedNullishCoalescing" | "suggestRemovingNonNull", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-non-null-asserted-optional-chain': import("@typescript-eslint/utils/ts-eslint").RuleModule<"suggestRemovingNonNull" | "noNonNullOptionalChain", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-non-null-assertion': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-non-null-assertion").MessageIds, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-redeclare': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-redeclare").MessageIds, import("./no-redeclare").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-redundant-type-constituents': import("@typescript-eslint/utils/ts-eslint").RuleModule<"overrides" | "errorTypeOverrides" | "literalOverridden" | "overridden" | "primitiveOverridden", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-require-imports': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noRequireImports", import("./no-require-imports").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-restricted-imports': import("@typescript-eslint/utils/ts-eslint").RuleModule<"everything" | "everythingWithCustomMessage" | "importName" | "importNameWithCustomMessage" | "path" | "pathWithCustomMessage" | "patterns" | "patternWithCustomMessage", [import("eslint/lib/rules/no-restricted-imports").ObjectOfPathsAndPatterns] | import("eslint/lib/rules/no-restricted-imports").ArrayOfStringOrObject, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-restricted-types': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-restricted-types").MessageIds, import("./no-restricted-types").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-shadow': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-shadow").MessageIds, import("./no-shadow").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-this-alias': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-this-alias").MessageIds, import("./no-this-alias").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-type-alias': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-type-alias").MessageIds, import("./no-type-alias").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-boolean-literal-compare': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-unnecessary-boolean-literal-compare").MessageIds, import("./no-unnecessary-boolean-literal-compare").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-condition': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-unnecessary-condition").MessageId, import("./no-unnecessary-condition").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-parameter-property-assignment': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unnecessaryAssign", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-qualifier': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unnecessaryQualifier", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-template-expression': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noUnnecessaryTemplateExpression", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-type-arguments': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unnecessaryTypeParameter", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-type-assertion': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-unnecessary-type-assertion").MessageIds, import("./no-unnecessary-type-assertion").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-type-constraint': import("@typescript-eslint/utils/ts-eslint").RuleModule<"removeUnnecessaryConstraint" | "unnecessaryConstraint", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-type-conversion': import("@typescript-eslint/utils/ts-eslint").RuleModule<"suggestRemove" | "suggestSatisfies" | "unnecessaryTypeConversion", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unnecessary-type-parameters': import("@typescript-eslint/utils/ts-eslint").RuleModule<"replaceUsagesWithConstraint" | "sole", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-argument': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-unsafe-argument").MessageIds, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-assignment': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeArraySpread" | "anyAssignment" | "anyAssignmentThis" | "unsafeArrayPattern" | "unsafeArrayPatternFromTuple" | "unsafeAssignment" | "unsafeObjectPattern", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-call': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-unsafe-call").MessageIds, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-declaration-merging': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeMerging", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-enum-comparison': import("@typescript-eslint/utils/ts-eslint").RuleModule<"mismatchedCase" | "mismatchedCondition" | "replaceValueWithEnum", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-function-type': import("@typescript-eslint/utils/ts-eslint").RuleModule<"bannedFunctionType", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-member-access': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-unsafe-member-access").MessageIds, import("./no-unsafe-member-access").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-return': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeReturn" | "unsafeReturnAssignment" | "unsafeReturnThis", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-type-assertion': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeOfAnyTypeAssertion" | "unsafeToAnyTypeAssertion" | "unsafeToUnconstrainedTypeAssertion" | "unsafeTypeAssertion" | "unsafeTypeAssertionAssignableToConstraint", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unsafe-unary-minus': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unaryMinus", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unused-expressions': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unusedExpression", [{
        allowShortCircuit?: boolean;
        allowTaggedTemplates?: boolean;
        allowTernary?: boolean;
    }], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unused-private-class-members': import("@typescript-eslint/utils/ts-eslint").RuleModule<"unusedPrivateClassMember", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-unused-vars': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./no-unused-vars").MessageIds, import("./no-unused-vars").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-use-before-define': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noUseBeforeDefine", import("./no-use-before-define").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-useless-constructor': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noUselessConstructor" | "removeConstructor", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-useless-default-assignment': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferOptionalSyntax" | "uselessDefaultAssignment" | "uselessUndefined", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-useless-empty-export': import("@typescript-eslint/utils/ts-eslint").RuleModule<"uselessExport", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-var-requires': import("@typescript-eslint/utils/ts-eslint").RuleModule<"noVarReqs", import("./no-var-requires").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'no-wrapper-object-types': import("@typescript-eslint/utils/ts-eslint").RuleModule<"bannedClassType", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'non-nullable-type-assertion-style': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferNonNullAssertion", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'only-throw-error': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./only-throw-error").MessageIds, import("./only-throw-error").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'parameter-properties': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./parameter-properties").MessageIds, import("./parameter-properties").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-as-const': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferConstAssertion" | "variableConstAssertion" | "variableSuggest", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-destructuring': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferDestructuring", import("./prefer-destructuring").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-enum-initializers': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./prefer-enum-initializers").MessageIds, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-find': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferFind" | "preferFindSuggestion", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-for-of': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferForOf", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-function-type': import("@typescript-eslint/utils/ts-eslint").RuleModule<"functionTypeOverCallableType" | "unexpectedThisOnFunctionOnlyInterface", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-includes': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferIncludes" | "preferStringIncludes", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-literal-enum-member': import("@typescript-eslint/utils/ts-eslint").RuleModule<"notLiteral" | "notLiteralOrBitwiseExpression", [{
        allowBitwiseExpressions: boolean;
    }], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-namespace-keyword': import("@typescript-eslint/utils/ts-eslint").RuleModule<"useNamespace", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-nullish-coalescing': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./prefer-nullish-coalescing").MessageIds, import("./prefer-nullish-coalescing").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-optional-chain': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./prefer-optional-chain-utils/PreferOptionalChainOptions").PreferOptionalChainMessageIds, [import("./prefer-optional-chain-utils/PreferOptionalChainOptions").PreferOptionalChainOptions], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-promise-reject-errors': import("@typescript-eslint/utils/ts-eslint").RuleModule<"rejectAnError", import("./prefer-promise-reject-errors").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-readonly': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferReadonly", import("./prefer-readonly").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-readonly-parameter-types': import("@typescript-eslint/utils/ts-eslint").RuleModule<"shouldBeReadonly", import("./prefer-readonly-parameter-types").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-reduce-type-parameter': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferTypeParameter", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-regexp-exec': import("@typescript-eslint/utils/ts-eslint").RuleModule<"regExpExecOverStringMatch", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-return-this-type': import("@typescript-eslint/utils/ts-eslint").RuleModule<"useThisType", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-string-starts-ends-with': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./prefer-string-starts-ends-with").MessageIds, import("./prefer-string-starts-ends-with").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'prefer-ts-expect-error': import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferExpectErrorComment", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'promise-function-async': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./promise-function-async").MessageIds, import("./promise-function-async").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'related-getter-setter-pairs': import("@typescript-eslint/utils/ts-eslint").RuleModule<"mismatch", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'require-array-sort-compare': import("@typescript-eslint/utils/ts-eslint").RuleModule<"requireCompare", import("./require-array-sort-compare").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'require-await': import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingAwait" | "removeAsync", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'restrict-plus-operands': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./restrict-plus-operands").MessageIds, import("./restrict-plus-operands").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'restrict-template-expressions': import("@typescript-eslint/utils/ts-eslint").RuleModule<"invalidType", import("./restrict-template-expressions").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'return-await': import("@typescript-eslint/utils/ts-eslint").RuleModule<"disallowedPromiseAwait" | "disallowedPromiseAwaitSuggestion" | "nonPromiseAwait" | "requiredPromiseAwait" | "requiredPromiseAwaitSuggestion", [string], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'sort-type-constituents': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./sort-type-constituents").MessageIds, import("./sort-type-constituents").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'strict-boolean-expressions': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./strict-boolean-expressions").MessageId, import("./strict-boolean-expressions").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'strict-void-return': import("@typescript-eslint/utils/ts-eslint").RuleModule<"asyncFunc" | "nonVoidFunc" | "nonVoidReturn", [{
        allowReturnAny?: boolean;
    }], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'switch-exhaustiveness-check': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./switch-exhaustiveness-check").MessageIds, import("./switch-exhaustiveness-check").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'triple-slash-reference': import("@typescript-eslint/utils/ts-eslint").RuleModule<"tripleSlashReference", import("./triple-slash-reference").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    typedef: import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./typedef").MessageIds, import("./typedef").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'unbound-method': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./unbound-method").MessageIds, import("./unbound-method").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'unified-signatures': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./unified-signatures").MessageIds, import("./unified-signatures").Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
    'use-unknown-in-catch-callback-variable': import("@typescript-eslint/utils/ts-eslint").RuleModule<import("./use-unknown-in-catch-callback-variable").MessageIds, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
        name: string;
    };
};
export = rules;


--------------------------------------------------------------------------------
FILE: index.js
--------------------------------------------------------------------------------

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const adjacent_overload_signatures_1 = __importDefault(require("./adjacent-overload-signatures"));
const array_type_1 = __importDefault(require("./array-type"));
const await_thenable_1 = __importDefault(require("./await-thenable"));
const ban_ts_comment_1 = __importDefault(require("./ban-ts-comment"));
const ban_tslint_comment_1 = __importDefault(require("./ban-tslint-comment"));
const class_literal_property_style_1 = __importDefault(require("./class-literal-property-style"));
const class_methods_use_this_1 = __importDefault(require("./class-methods-use-this"));
const consistent_generic_constructors_1 = __importDefault(require("./consistent-generic-constructors"));
const consistent_indexed_object_style_1 = __importDefault(require("./consistent-indexed-object-style"));
const consistent_return_1 = __importDefault(require("./consistent-return"));
const consistent_type_assertions_1 = __importDefault(require("./consistent-type-assertions"));
const consistent_type_definitions_1 = __importDefault(require("./consistent-type-definitions"));
const consistent_type_exports_1 = __importDefault(require("./consistent-type-exports"));
const consistent_type_imports_1 = __importDefault(require("./consistent-type-imports"));
const default_param_last_1 = __importDefault(require("./default-param-last"));
const dot_notation_1 = __importDefault(require("./dot-notation"));
const explicit_function_return_type_1 = __importDefault(require("./explicit-function-return-type"));
const explicit_member_accessibility_1 = __importDefault(require("./explicit-member-accessibility"));
const explicit_module_boundary_types_1 = __importDefault(require("./explicit-module-boundary-types"));
const init_declarations_1 = __importDefault(require("./init-declarations"));
const max_params_1 = __importDefault(require("./max-params"));
const member_ordering_1 = __importDefault(require("./member-ordering"));
const method_signature_style_1 = __importDefault(require("./method-signature-style"));
const naming_convention_1 = __importDefault(require("./naming-convention"));
const no_array_constructor_1 = __importDefault(require("./no-array-constructor"));
const no_array_delete_1 = __importDefault(require("./no-array-delete"));
const no_base_to_string_1 = __importDefault(require("./no-base-to-string"));
const no_confusing_non_null_assertion_1 = __importDefault(require("./no-confusing-non-null-assertion"));
const no_confusing_void_expression_1 = __importDefault(require("./no-confusing-void-expression"));
const no_deprecated_1 = __importDefault(require("./no-deprecated"));
const no_dupe_class_members_1 = __importDefault(require("./no-dupe-class-members"));
const no_duplicate_enum_values_1 = __importDefault(require("./no-duplicate-enum-values"));
const no_duplicate_type_constituents_1 = __importDefault(require("./no-duplicate-type-constituents"));
const no_dynamic_delete_1 = __importDefault(require("./no-dynamic-delete"));
const no_empty_function_1 = __importDefault(require("./no-empty-function"));
const no_empty_interface_1 = __importDefault(require("./no-empty-interface"));
const no_empty_object_type_1 = __importDefault(require("./no-empty-object-type"));
const no_explicit_any_1 = __importDefault(require("./no-explicit-any"));
const no_extra_non_null_assertion_1 = __importDefault(require("./no-extra-non-null-assertion"));
const no_extraneous_class_1 = __importDefault(require("./no-extraneous-class"));
const no_floating_promises_1 = __importDefault(require("./no-floating-promises"));
const no_for_in_array_1 = __importDefault(require("./no-for-in-array"));
const no_implied_eval_1 = __importDefault(require("./no-implied-eval"));
const no_import_type_side_effects_1 = __importDefault(require("./no-import-type-side-effects"));
const no_inferrable_types_1 = __importDefault(require("./no-inferrable-types"));
const no_invalid_this_1 = __importDefault(require("./no-invalid-this"));
const no_invalid_void_type_1 = __importDefault(require("./no-invalid-void-type"));
const no_loop_func_1 = __importDefault(require("./no-loop-func"));
const no_loss_of_precision_1 = __importDefault(require("./no-loss-of-precision"));
const no_magic_numbers_1 = __importDefault(require("./no-magic-numbers"));
const no_meaningless_void_operator_1 = __importDefault(require("./no-meaningless-void-operator"));
const no_misused_new_1 = __importDefault(require("./no-misused-new"));
const no_misused_promises_1 = __importDefault(require("./no-misused-promises"));
const no_misused_spread_1 = __importDefault(require("./no-misused-spread"));
const no_mixed_enums_1 = __importDefault(require("./no-mixed-enums"));
const no_namespace_1 = __importDefault(require("./no-namespace"));
const no_non_null_asserted_nullish_coalescing_1 = __importDefault(require("./no-non-null-asserted-nullish-coalescing"));
const no_non_null_asserted_optional_chain_1 = __importDefault(require("./no-non-null-asserted-optional-chain"));
const no_non_null_assertion_1 = __importDefault(require("./no-non-null-assertion"));
const no_redeclare_1 = __importDefault(require("./no-redeclare"));
const no_redundant_type_constituents_1 = __importDefault(require("./no-redundant-type-constituents"));
const no_require_imports_1 = __importDefault(require("./no-require-imports"));
const no_restricted_imports_1 = __importDefault(require("./no-restricted-imports"));
const no_restricted_types_1 = __importDefault(require("./no-restricted-types"));
const no_shadow_1 = __importDefault(require("./no-shadow"));
const no_this_alias_1 = __importDefault(require("./no-this-alias"));
const no_type_alias_1 = __importDefault(require("./no-type-alias"));
const no_unnecessary_boolean_literal_compare_1 = __importDefault(require("./no-unnecessary-boolean-literal-compare"));
const no_unnecessary_condition_1 = __importDefault(require("./no-unnecessary-condition"));
const no_unnecessary_parameter_property_assignment_1 = __importDefault(require("./no-unnecessary-parameter-property-assignment"));
const no_unnecessary_qualifier_1 = __importDefault(require("./no-unnecessary-qualifier"));
const no_unnecessary_template_expression_1 = __importDefault(require("./no-unnecessary-template-expression"));
const no_unnecessary_type_arguments_1 = __importDefault(require("./no-unnecessary-type-arguments"));
const no_unnecessary_type_assertion_1 = __importDefault(require("./no-unnecessary-type-assertion"));
const no_unnecessary_type_constraint_1 = __importDefault(require("./no-unnecessary-type-constraint"));
const no_unnecessary_type_conversion_1 = __importDefault(require("./no-unnecessary-type-conversion"));
const no_unnecessary_type_parameters_1 = __importDefault(require("./no-unnecessary-type-parameters"));
const no_unsafe_argument_1 = __importDefault(require("./no-unsafe-argument"));
const no_unsafe_assignment_1 = __importDefault(require("./no-unsafe-assignment"));
const no_unsafe_call_1 = __importDefault(require("./no-unsafe-call"));
const no_unsafe_declaration_merging_1 = __importDefault(require("./no-unsafe-declaration-merging"));
const no_unsafe_enum_comparison_1 = __importDefault(require("./no-unsafe-enum-comparison"));
const no_unsafe_function_type_1 = __importDefault(require("./no-unsafe-function-type"));
const no_unsafe_member_access_1 = __importDefault(require("./no-unsafe-member-access"));
const no_unsafe_return_1 = __importDefault(require("./no-unsafe-return"));
const no_unsafe_type_assertion_1 = __importDefault(require("./no-unsafe-type-assertion"));
const no_unsafe_unary_minus_1 = __importDefault(require("./no-unsafe-unary-minus"));
const no_unused_expressions_1 = __importDefault(require("./no-unused-expressions"));
const no_unused_private_class_members_1 = __importDefault(require("./no-unused-private-class-members"));
const no_unused_vars_1 = __importDefault(require("./no-unused-vars"));
const no_use_before_define_1 = __importDefault(require("./no-use-before-define"));
const no_useless_constructor_1 = __importDefault(require("./no-useless-constructor"));
const no_useless_default_assignment_1 = __importDefault(require("./no-useless-default-assignment"));
const no_useless_empty_export_1 = __importDefault(require("./no-useless-empty-export"));
const no_var_requires_1 = __importDefault(require("./no-var-requires"));
const no_wrapper_object_types_1 = __importDefault(require("./no-wrapper-object-types"));
const non_nullable_type_assertion_style_1 = __importDefault(require("./non-nullable-type-assertion-style"));
const only_throw_error_1 = __importDefault(require("./only-throw-error"));
const parameter_properties_1 = __importDefault(require("./parameter-properties"));
const prefer_as_const_1 = __importDefault(require("./prefer-as-const"));
const prefer_destructuring_1 = __importDefault(require("./prefer-destructuring"));
const prefer_enum_initializers_1 = __importDefault(require("./prefer-enum-initializers"));
const prefer_find_1 = __importDefault(require("./prefer-find"));
const prefer_for_of_1 = __importDefault(require("./prefer-for-of"));
const prefer_function_type_1 = __importDefault(require("./prefer-function-type"));
const prefer_includes_1 = __importDefault(require("./prefer-includes"));
const prefer_literal_enum_member_1 = __importDefault(require("./prefer-literal-enum-member"));
const prefer_namespace_keyword_1 = __importDefault(require("./prefer-namespace-keyword"));
const prefer_nullish_coalescing_1 = __importDefault(require("./prefer-nullish-coalescing"));
const prefer_optional_chain_1 = __importDefault(require("./prefer-optional-chain"));
const prefer_promise_reject_errors_1 = __importDefault(require("./prefer-promise-reject-errors"));
const prefer_readonly_1 = __importDefault(require("./prefer-readonly"));
const prefer_readonly_parameter_types_1 = __importDefault(require("./prefer-readonly-parameter-types"));
const prefer_reduce_type_parameter_1 = __importDefault(require("./prefer-reduce-type-parameter"));
const prefer_regexp_exec_1 = __importDefault(require("./prefer-regexp-exec"));
const prefer_return_this_type_1 = __importDefault(require("./prefer-return-this-type"));
const prefer_string_starts_ends_with_1 = __importDefault(require("./prefer-string-starts-ends-with"));
const prefer_ts_expect_error_1 = __importDefault(require("./prefer-ts-expect-error"));
const promise_function_async_1 = __importDefault(require("./promise-function-async"));
const related_getter_setter_pairs_1 = __importDefault(require("./related-getter-setter-pairs"));
const require_array_sort_compare_1 = __importDefault(require("./require-array-sort-compare"));
const require_await_1 = __importDefault(require("./require-await"));
const restrict_plus_operands_1 = __importDefault(require("./restrict-plus-operands"));
const restrict_template_expressions_1 = __importDefault(require("./restrict-template-expressions"));
const return_await_1 = __importDefault(require("./return-await"));
const sort_type_constituents_1 = __importDefault(require("./sort-type-constituents"));
const strict_boolean_expressions_1 = __importDefault(require("./strict-boolean-expressions"));
const strict_void_return_1 = __importDefault(require("./strict-void-return"));
const switch_exhaustiveness_check_1 = __importDefault(require("./switch-exhaustiveness-check"));
const triple_slash_reference_1 = __importDefault(require("./triple-slash-reference"));
const typedef_1 = __importDefault(require("./typedef"));
const unbound_method_1 = __importDefault(require("./unbound-method"));
const unified_signatures_1 = __importDefault(require("./unified-signatures"));
const use_unknown_in_catch_callback_variable_1 = __importDefault(require("./use-unknown-in-catch-callback-variable"));
const rules = {
    'adjacent-overload-signatures': adjacent_overload_signatures_1.default,
    'array-type': array_type_1.default,
    'await-thenable': await_thenable_1.default,
    'ban-ts-comment': ban_ts_comment_1.default,
    'ban-tslint-comment': ban_tslint_comment_1.default,
    'class-literal-property-style': class_literal_property_style_1.default,
    'class-methods-use-this': class_methods_use_this_1.default,
    'consistent-generic-constructors': consistent_generic_constructors_1.default,
    'consistent-indexed-object-style': consistent_indexed_object_style_1.default,
    'consistent-return': consistent_return_1.default,
    'consistent-type-assertions': consistent_type_assertions_1.default,
    'consistent-type-definitions': consistent_type_definitions_1.default,
    'consistent-type-exports': consistent_type_exports_1.default,
    'consistent-type-imports': consistent_type_imports_1.default,
    'default-param-last': default_param_last_1.default,
    'dot-notation': dot_notation_1.default,
    'explicit-function-return-type': explicit_function_return_type_1.default,
    'explicit-member-accessibility': explicit_member_accessibility_1.default,
    'explicit-module-boundary-types': explicit_module_boundary_types_1.default,
    'init-declarations': init_declarations_1.default,
    'max-params': max_params_1.default,
    'member-ordering': member_ordering_1.default,
    'method-signature-style': method_signature_style_1.default,
    'naming-convention': naming_convention_1.default,
    'no-array-constructor': no_array_constructor_1.default,
    'no-array-delete': no_array_delete_1.default,
    'no-base-to-string': no_base_to_string_1.default,
    'no-confusing-non-null-assertion': no_confusing_non_null_assertion_1.default,
    'no-confusing-void-expression': no_confusing_void_expression_1.default,
    'no-deprecated': no_deprecated_1.default,
    'no-dupe-class-members': no_dupe_class_members_1.default,
    'no-duplicate-enum-values': no_duplicate_enum_values_1.default,
    'no-duplicate-type-constituents': no_duplicate_type_constituents_1.default,
    'no-dynamic-delete': no_dynamic_delete_1.default,
    'no-empty-function': no_empty_function_1.default,
    'no-empty-interface': no_empty_interface_1.default,
    'no-empty-object-type': no_empty_object_type_1.default,
    'no-explicit-any': no_explicit_any_1.default,
    'no-extra-non-null-assertion': no_extra_non_null_assertion_1.default,
    'no-extraneous-class': no_extraneous_class_1.default,
    'no-floating-promises': no_floating_promises_1.default,
    'no-for-in-array': no_for_in_array_1.default,
    'no-implied-eval': no_implied_eval_1.default,
    'no-import-type-side-effects': no_import_type_side_effects_1.default,
    'no-inferrable-types': no_inferrable_types_1.default,
    'no-invalid-this': no_invalid_this_1.default,
    'no-invalid-void-type': no_invalid_void_type_1.default,
    'no-loop-func': no_loop_func_1.default,
    'no-loss-of-precision': no_loss_of_precision_1.default,
    'no-magic-numbers': no_magic_numbers_1.default,
    'no-meaningless-void-operator': no_meaningless_void_operator_1.default,
    'no-misused-new': no_misused_new_1.default,
    'no-misused-promises': no_misused_promises_1.default,
    'no-misused-spread': no_misused_spread_1.default,
    'no-mixed-enums': no_mixed_enums_1.default,
    'no-namespace': no_namespace_1.default,
    'no-non-null-asserted-nullish-coalescing': no_non_null_asserted_nullish_coalescing_1.default,
    'no-non-null-asserted-optional-chain': no_non_null_asserted_optional_chain_1.default,
    'no-non-null-assertion': no_non_null_assertion_1.default,
    'no-redeclare': no_redeclare_1.default,
    'no-redundant-type-constituents': no_redundant_type_constituents_1.default,
    'no-require-imports': no_require_imports_1.default,
    'no-restricted-imports': no_restricted_imports_1.default,
    'no-restricted-types': no_restricted_types_1.default,
    'no-shadow': no_shadow_1.default,
    'no-this-alias': no_this_alias_1.default,
    'no-type-alias': no_type_alias_1.default,
    'no-unnecessary-boolean-literal-compare': no_unnecessary_boolean_literal_compare_1.default,
    'no-unnecessary-condition': no_unnecessary_condition_1.default,
    'no-unnecessary-parameter-property-assignment': no_unnecessary_parameter_property_assignment_1.default,
    'no-unnecessary-qualifier': no_unnecessary_qualifier_1.default,
    'no-unnecessary-template-expression': no_unnecessary_template_expression_1.default,
    'no-unnecessary-type-arguments': no_unnecessary_type_arguments_1.default,
    'no-unnecessary-type-assertion': no_unnecessary_type_assertion_1.default,
    'no-unnecessary-type-constraint': no_unnecessary_type_constraint_1.default,
    'no-unnecessary-type-conversion': no_unnecessary_type_conversion_1.default,
    'no-unnecessary-type-parameters': no_unnecessary_type_parameters_1.default,
    'no-unsafe-argument': no_unsafe_argument_1.default,
    'no-unsafe-assignment': no_unsafe_assignment_1.default,
    'no-unsafe-call': no_unsafe_call_1.default,
    'no-unsafe-declaration-merging': no_unsafe_declaration_merging_1.default,
    'no-unsafe-enum-comparison': no_unsafe_enum_comparison_1.default,
    'no-unsafe-function-type': no_unsafe_function_type_1.default,
    'no-unsafe-member-access': no_unsafe_member_access_1.default,
    'no-unsafe-return': no_unsafe_return_1.default,
    'no-unsafe-type-assertion': no_unsafe_type_assertion_1.default,
    'no-unsafe-unary-minus': no_unsafe_unary_minus_1.default,
    'no-unused-expressions': no_unused_expressions_1.default,
    'no-unused-private-class-members': no_unused_private_class_members_1.default,
    'no-unused-vars': no_unused_vars_1.default,
    'no-use-before-define': no_use_before_define_1.default,
    'no-useless-constructor': no_useless_constructor_1.default,
    'no-useless-default-assignment': no_useless_default_assignment_1.default,
    'no-useless-empty-export': no_useless_empty_export_1.default,
    'no-var-requires': no_var_requires_1.default,
    'no-wrapper-object-types': no_wrapper_object_types_1.default,
    'non-nullable-type-assertion-style': non_nullable_type_assertion_style_1.default,
    'only-throw-error': only_throw_error_1.default,
    'parameter-properties': parameter_properties_1.default,
    'prefer-as-const': prefer_as_const_1.default,
    'prefer-destructuring': prefer_destructuring_1.default,
    'prefer-enum-initializers': prefer_enum_initializers_1.default,
    'prefer-find': prefer_find_1.default,
    'prefer-for-of': prefer_for_of_1.default,
    'prefer-function-type': prefer_function_type_1.default,
    'prefer-includes': prefer_includes_1.default,
    'prefer-literal-enum-member': prefer_literal_enum_member_1.default,
    'prefer-namespace-keyword': prefer_namespace_keyword_1.default,
    'prefer-nullish-coalescing': prefer_nullish_coalescing_1.default,
    'prefer-optional-chain': prefer_optional_chain_1.default,
    'prefer-promise-reject-errors': prefer_promise_reject_errors_1.default,
    'prefer-readonly': prefer_readonly_1.default,
    'prefer-readonly-parameter-types': prefer_readonly_parameter_types_1.default,
    'prefer-reduce-type-parameter': prefer_reduce_type_parameter_1.default,
    'prefer-regexp-exec': prefer_regexp_exec_1.default,
    'prefer-return-this-type': prefer_return_this_type_1.default,
    'prefer-string-starts-ends-with': prefer_string_starts_ends_with_1.default,
    'prefer-ts-expect-error': prefer_ts_expect_error_1.default,
    'promise-function-async': promise_function_async_1.default,
    'related-getter-setter-pairs': related_getter_setter_pairs_1.default,
    'require-array-sort-compare': require_array_sort_compare_1.default,
    'require-await': require_await_1.default,
    'restrict-plus-operands': restrict_plus_operands_1.default,
    'restrict-template-expressions': restrict_template_expressions_1.default,
    'return-await': return_await_1.default,
    'sort-type-constituents': sort_type_constituents_1.default,
    'strict-boolean-expressions': strict_boolean_expressions_1.default,
    'strict-void-return': strict_void_return_1.default,
    'switch-exhaustiveness-check': switch_exhaustiveness_check_1.default,
    'triple-slash-reference': triple_slash_reference_1.default,
    typedef: typedef_1.default,
    'unbound-method': unbound_method_1.default,
    'unified-signatures': unified_signatures_1.default,
    'use-unknown-in-catch-callback-variable': use_unknown_in_catch_callback_variable_1.default,
};
module.exports = rules;


--------------------------------------------------------------------------------
FILE: init-declarations.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"initialized" | "notInitialized", ["always" | "never", ({
    ignoreForLoopInit?: boolean;
} | undefined)?], unknown, {
    'VariableDeclaration:exit'(node: TSESTree.VariableDeclaration): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"initialized" | "notInitialized", ["always" | "never", ({
    ignoreForLoopInit?: boolean;
} | undefined)?], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: init-declarations.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('init-declarations');
exports.default = (0, util_1.createRule)({
    name: 'init-declarations',
    meta: {
        type: 'suggestion',
        // defaultOptions, -- base rule does not use defaultOptions
        docs: {
            description: 'Require or disallow initialization in variable declarations',
            extendsBaseRule: true,
            frozen: true,
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: baseRule.meta.schema,
    },
    defaultOptions: ['always'],
    create(context, [mode]) {
        // Make a custom context to adjust the loc of reports where the base
        // rule's behavior is a bit too aggressive with TS-specific syntax (namely,
        // type annotations).
        function getBaseContextOverride() {
            const reportOverride = descriptor => {
                if ('node' in descriptor && descriptor.loc == null) {
                    const { node, ...rest } = descriptor;
                    // We only want to special case the report loc when reporting on
                    // variables declarations that are not initialized. Declarations that
                    // _are_ initialized get reported by the base rule due to a setting to
                    // prohibit initializing variables entirely, in which case underlining
                    // the whole node including the type annotation and initializer is
                    // appropriate.
                    if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator &&
                        node.init == null) {
                        context.report({
                            ...rest,
                            loc: getReportLoc(node),
                        });
                        return;
                    }
                }
                context.report(descriptor);
            };
            // `return { ...context, report: reportOverride }` isn't safe because the
            // `context` object has some getters that need to be preserved.
            //
            // `return new Proxy(context, ...)` doesn't work because `context` has
            // non-configurable properties that throw when constructing a Proxy.
            //
            // So, we'll just use Proxy on a dummy object and use the `get` trap to
            // proxy `context`'s properties.
            return new Proxy({}, {
                get: (target, prop, receiver) => prop === 'report'
                    ? reportOverride
                    : Reflect.get(context, prop, receiver),
            });
        }
        const rules = baseRule.create(getBaseContextOverride());
        return {
            'VariableDeclaration:exit'(node) {
                if (mode === 'always') {
                    if (node.declare) {
                        return;
                    }
                    if (isAncestorNamespaceDeclared(node)) {
                        return;
                    }
                }
                rules['VariableDeclaration:exit'](node);
            },
        };
        function isAncestorNamespaceDeclared(node) {
            let ancestor = node.parent;
            while (ancestor) {
                if (ancestor.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration &&
                    ancestor.declare) {
                    return true;
                }
                ancestor = ancestor.parent;
            }
            return false;
        }
    },
});
/**
 * When reporting an uninitialized variable declarator, get the loc excluding
 * the type annotation.
 */
function getReportLoc(node) {
    const start = structuredClone(node.loc.start);
    const end = {
        line: node.loc.start.line,
        // `if (id.type === AST_NODE_TYPES.Identifier)` is a condition for
        // reporting in the base rule (as opposed to things like destructuring
        // assignment), so the type assertion should always be valid.
        column: node.loc.start.column + node.id.name.length,
    };
    return {
        start,
        end,
    };
}


--------------------------------------------------------------------------------
FILE: max-params.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"exceed", ({
    countVoidThis?: boolean;
    max: number;
} | {
    countVoidThis?: boolean;
    maximum: number;
})[], unknown, {
    ArrowFunctionExpression(node: TSESTree.ArrowFunctionExpression): void;
    FunctionDeclaration(node: TSESTree.FunctionDeclaration | TSESTree.TSDeclareFunction | TSESTree.TSFunctionType): void;
    FunctionExpression(node: TSESTree.FunctionExpression): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"exceed", ({
    countVoidThis?: boolean;
    max: number;
} | {
    countVoidThis?: boolean;
    maximum: number;
})[], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: max-params.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('max-params');
exports.default = (0, util_1.createRule)({
    name: 'max-params',
    meta: {
        type: 'suggestion',
        // defaultOptions, -- base rule does not use defaultOptions
        docs: {
            description: 'Enforce a maximum number of parameters in function definitions',
            extendsBaseRule: true,
        },
        messages: baseRule.meta.messages,
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    countVoidThis: {
                        type: 'boolean',
                        description: 'Whether to count a `this` declaration when the type is `void`.',
                    },
                    max: {
                        type: 'integer',
                        description: 'A maximum number of parameters in function definitions.',
                        minimum: 0,
                    },
                    maximum: {
                        type: 'integer',
                        description: '(deprecated) A maximum number of parameters in function definitions.',
                        minimum: 0,
                    },
                },
            },
        ],
    },
    defaultOptions: [{ countVoidThis: false, max: 3 }],
    create(context, [{ countVoidThis }]) {
        const baseRules = baseRule.create(context);
        if (countVoidThis === true) {
            return baseRules;
        }
        const removeVoidThisParam = (node) => {
            if (node.params.length === 0 ||
                node.params[0].type !== utils_1.AST_NODE_TYPES.Identifier ||
                node.params[0].name !== 'this' ||
                node.params[0].typeAnnotation?.typeAnnotation.type !==
                    utils_1.AST_NODE_TYPES.TSVoidKeyword) {
                return node;
            }
            return {
                ...node,
                params: node.params.slice(1),
            };
        };
        const wrapListener = (listener) => {
            return (node) => {
                listener(removeVoidThisParam(node));
            };
        };
        return {
            ArrowFunctionExpression: wrapListener(baseRules.ArrowFunctionExpression),
            FunctionDeclaration: wrapListener(baseRules.FunctionDeclaration),
            FunctionExpression: wrapListener(baseRules.FunctionExpression),
            TSDeclareFunction: wrapListener(baseRules.FunctionDeclaration),
            TSFunctionType: wrapListener(baseRules.FunctionDeclaration),
        };
    },
});


--------------------------------------------------------------------------------
FILE: member-ordering.d.ts
--------------------------------------------------------------------------------

import type { TSESLint, TSESTree } from '@typescript-eslint/utils';
export type MessageIds = 'incorrectGroupOrder' | 'incorrectOrder' | 'incorrectRequiredMembersOrder';
type ReadonlyType = 'readonly-field' | 'readonly-signature';
type MemberKind = 'accessor' | 'call-signature' | 'constructor' | 'field' | 'get' | 'method' | 'set' | 'signature' | 'static-initialization' | ReadonlyType;
type DecoratedMemberKind = 'accessor' | 'field' | 'get' | 'method' | 'set' | Exclude<ReadonlyType, 'readonly-signature'>;
type NonCallableMemberKind = Exclude<MemberKind, 'constructor' | 'readonly-signature' | 'signature'>;
type MemberScope = 'abstract' | 'instance' | 'static';
type Accessibility = '#private' | TSESTree.Accessibility;
type BaseMemberType = `${Accessibility}-${Exclude<MemberKind, 'readonly-signature' | 'signature' | 'static-initialization'>}` | `${Accessibility}-${MemberScope}-${NonCallableMemberKind}` | `${Accessibility}-decorated-${DecoratedMemberKind}` | `${MemberScope}-${NonCallableMemberKind}` | `decorated-${DecoratedMemberKind}` | MemberKind;
type MemberType = BaseMemberType | BaseMemberType[];
type AlphabeticalOrder = 'alphabetically' | 'alphabetically-case-insensitive' | 'natural' | 'natural-case-insensitive';
type Order = 'as-written' | AlphabeticalOrder;
interface SortedOrderConfig {
    memberTypes?: 'never' | MemberType[];
    optionalityOrder?: OptionalityOrder;
    order?: Order;
}
type OrderConfig = 'never' | MemberType[] | SortedOrderConfig;
type OptionalityOrder = 'optional-first' | 'required-first';
export type Options = [
    {
        classes?: OrderConfig;
        classExpressions?: OrderConfig;
        default?: OrderConfig;
        interfaces?: OrderConfig;
        typeLiterals?: OrderConfig;
    }
];
export declare const defaultOrder: MemberType[];
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: member-ordering.js
--------------------------------------------------------------------------------

"use strict";
// This rule was feature-frozen before we enabled no-property-in-node.
/* eslint-disable eslint-plugin/no-property-in-node */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultOrder = void 0;
const utils_1 = require("@typescript-eslint/utils");
const natural_compare_1 = __importDefault(require("natural-compare"));
const util_1 = require("../util");
const neverConfig = {
    type: 'string',
    enum: ['never'],
};
const arrayConfig = (memberTypes) => ({
    type: 'array',
    items: {
        oneOf: [
            {
                $ref: memberTypes,
            },
            {
                type: 'array',
                items: {
                    $ref: memberTypes,
                },
            },
        ],
    },
});
const objectConfig = (memberTypes) => ({
    type: 'object',
    additionalProperties: false,
    properties: {
        memberTypes: {
            oneOf: [arrayConfig(memberTypes), neverConfig],
        },
        optionalityOrder: {
            $ref: '#/items/0/$defs/optionalityOrderOptions',
        },
        order: {
            $ref: '#/items/0/$defs/orderOptions',
        },
    },
});
exports.defaultOrder = [
    // Index signature
    'signature',
    'call-signature',
    // Fields
    'public-static-field',
    'protected-static-field',
    'private-static-field',
    '#private-static-field',
    'public-decorated-field',
    'protected-decorated-field',
    'private-decorated-field',
    'public-instance-field',
    'protected-instance-field',
    'private-instance-field',
    '#private-instance-field',
    'public-abstract-field',
    'protected-abstract-field',
    'public-field',
    'protected-field',
    'private-field',
    '#private-field',
    'static-field',
    'instance-field',
    'abstract-field',
    'decorated-field',
    'field',
    // Static initialization
    'static-initialization',
    // Constructors
    'public-constructor',
    'protected-constructor',
    'private-constructor',
    'constructor',
    // Accessors
    'public-static-accessor',
    'protected-static-accessor',
    'private-static-accessor',
    '#private-static-accessor',
    'public-decorated-accessor',
    'protected-decorated-accessor',
    'private-decorated-accessor',
    'public-instance-accessor',
    'protected-instance-accessor',
    'private-instance-accessor',
    '#private-instance-accessor',
    'public-abstract-accessor',
    'protected-abstract-accessor',
    'public-accessor',
    'protected-accessor',
    'private-accessor',
    '#private-accessor',
    'static-accessor',
    'instance-accessor',
    'abstract-accessor',
    'decorated-accessor',
    'accessor',
    // Getters
    'public-static-get',
    'protected-static-get',
    'private-static-get',
    '#private-static-get',
    'public-decorated-get',
    'protected-decorated-get',
    'private-decorated-get',
    'public-instance-get',
    'protected-instance-get',
    'private-instance-get',
    '#private-instance-get',
    'public-abstract-get',
    'protected-abstract-get',
    'public-get',
    'protected-get',
    'private-get',
    '#private-get',
    'static-get',
    'instance-get',
    'abstract-get',
    'decorated-get',
    'get',
    // Setters
    'public-static-set',
    'protected-static-set',
    'private-static-set',
    '#private-static-set',
    'public-decorated-set',
    'protected-decorated-set',
    'private-decorated-set',
    'public-instance-set',
    'protected-instance-set',
    'private-instance-set',
    '#private-instance-set',
    'public-abstract-set',
    'protected-abstract-set',
    'public-set',
    'protected-set',
    'private-set',
    '#private-set',
    'static-set',
    'instance-set',
    'abstract-set',
    'decorated-set',
    'set',
    // Methods
    'public-static-method',
    'protected-static-method',
    'private-static-method',
    '#private-static-method',
    'public-decorated-method',
    'protected-decorated-method',
    'private-decorated-method',
    'public-instance-method',
    'protected-instance-method',
    'private-instance-method',
    '#private-instance-method',
    'public-abstract-method',
    'protected-abstract-method',
    'public-method',
    'protected-method',
    'private-method',
    '#private-method',
    'static-method',
    'instance-method',
    'abstract-method',
    'decorated-method',
    'method',
];
const allMemberTypes = [
    ...new Set([
        'readonly-signature',
        'signature',
        'readonly-field',
        'field',
        'method',
        'call-signature',
        'constructor',
        'accessor',
        'get',
        'set',
        'static-initialization',
    ].flatMap(type => [
        type,
        ...['public', 'protected', 'private', '#private']
            .flatMap(accessibility => [
            type !== 'readonly-signature' &&
                type !== 'signature' &&
                type !== 'static-initialization' &&
                type !== 'call-signature' &&
                !(type === 'constructor' && accessibility === '#private')
                ? `${accessibility}-${type}` // e.g. `public-field`
                : [],
            // Only class instance fields, methods, accessors, get and set can have decorators attached to them
            accessibility !== '#private' &&
                (type === 'readonly-field' ||
                    type === 'field' ||
                    type === 'method' ||
                    type === 'accessor' ||
                    type === 'get' ||
                    type === 'set')
                ? [`${accessibility}-decorated-${type}`, `decorated-${type}`]
                : [],
            type !== 'constructor' &&
                type !== 'readonly-signature' &&
                type !== 'signature' &&
                type !== 'call-signature'
                ? [
                    'static',
                    'instance',
                    // There is no `static-constructor` or `instance-constructor` or `abstract-constructor`
                    ...(accessibility === '#private' ||
                        accessibility === 'private'
                        ? []
                        : ['abstract']),
                ].flatMap(scope => [
                    `${scope}-${type}`,
                    `${accessibility}-${scope}-${type}`,
                ])
                : [],
        ])
            .flat(),
    ])),
];
const functionExpressions = [
    utils_1.AST_NODE_TYPES.FunctionExpression,
    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
];
/**
 * Gets the node type.
 *
 * @param node the node to be evaluated.
 */
function getNodeType(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
        case utils_1.AST_NODE_TYPES.MethodDefinition:
        case utils_1.AST_NODE_TYPES.TSMethodSignature:
            return node.kind;
        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:
            return 'call-signature';
        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:
            return 'constructor';
        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:
        case utils_1.AST_NODE_TYPES.TSPropertySignature:
            return node.readonly ? 'readonly-field' : 'field';
        case utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:
        case utils_1.AST_NODE_TYPES.AccessorProperty:
            return 'accessor';
        case utils_1.AST_NODE_TYPES.PropertyDefinition:
            return node.value && functionExpressions.includes(node.value.type)
                ? 'method'
                : node.readonly
                    ? 'readonly-field'
                    : 'field';
        case utils_1.AST_NODE_TYPES.TSIndexSignature:
            return node.readonly ? 'readonly-signature' : 'signature';
        case utils_1.AST_NODE_TYPES.StaticBlock:
            return 'static-initialization';
        default:
            return null;
    }
}
/**
 * Gets the raw string value of a member's name
 */
function getMemberRawName(member, sourceCode) {
    const { name, type } = (0, util_1.getNameFromMember)(member, sourceCode);
    if (type === util_1.MemberNameType.Quoted) {
        return name.slice(1, -1);
    }
    if (type === util_1.MemberNameType.Private) {
        return name.slice(1);
    }
    return name;
}
/**
 * Gets the member name based on the member type.
 *
 * @param node the node to be evaluated.
 */
function getMemberName(node, sourceCode) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSPropertySignature:
        case utils_1.AST_NODE_TYPES.TSMethodSignature:
        case utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:
        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:
        case utils_1.AST_NODE_TYPES.AccessorProperty:
        case utils_1.AST_NODE_TYPES.PropertyDefinition:
            return getMemberRawName(node, sourceCode);
        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
        case utils_1.AST_NODE_TYPES.MethodDefinition:
            return node.kind === 'constructor'
                ? 'constructor'
                : getMemberRawName(node, sourceCode);
        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:
            return 'new';
        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:
            return 'call';
        case utils_1.AST_NODE_TYPES.TSIndexSignature:
            return (0, util_1.getNameFromIndexSignature)(node);
        case utils_1.AST_NODE_TYPES.StaticBlock:
            return 'static block';
        default:
            return null;
    }
}
/**
 * Returns true if the member is optional based on the member type.
 *
 * @param node the node to be evaluated.
 *
 * @returns Whether the member is optional, or false if it cannot be optional at all.
 */
function isMemberOptional(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSPropertySignature:
        case utils_1.AST_NODE_TYPES.TSMethodSignature:
        case utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:
        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:
        case utils_1.AST_NODE_TYPES.AccessorProperty:
        case utils_1.AST_NODE_TYPES.PropertyDefinition:
        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
        case utils_1.AST_NODE_TYPES.MethodDefinition:
            return node.optional;
    }
    return false;
}
/**
 * Gets the calculated rank using the provided method definition.
 * The algorithm is as follows:
 * - Get the rank based on the accessibility-scope-type name, e.g. public-instance-field
 * - If there is no order for accessibility-scope-type, then strip out the accessibility.
 * - If there is no order for scope-type, then strip out the scope.
 * - If there is no order for type, then return -1
 * @param memberGroups the valid names to be validated.
 * @param orderConfig the current order to be validated.
 *
 * @return Index of the matching member type in the order configuration.
 */
function getRankOrder(memberGroups, orderConfig) {
    let rank = -1;
    const stack = [...memberGroups]; // Get a copy of the member groups
    while (stack.length > 0 && rank === -1) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const memberGroup = stack.shift();
        rank = orderConfig.findIndex(memberType => Array.isArray(memberType)
            ? memberType.includes(memberGroup)
            : memberType === memberGroup);
    }
    return rank;
}
function getAccessibility(node) {
    if ('accessibility' in node && node.accessibility) {
        return node.accessibility;
    }
    if ('key' in node && node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
        return '#private';
    }
    return 'public';
}
/**
 * Gets the rank of the node given the order.
 * @param node the node to be evaluated.
 * @param orderConfig the current order to be validated.
 * @param supportsModifiers a flag indicating whether the type supports modifiers (scope or accessibility) or not.
 */
function getRank(node, orderConfig, supportsModifiers) {
    const type = getNodeType(node);
    if (node.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
        node.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {
        return -1;
    }
    if (type == null) {
        // shouldn't happen but just in case, put it on the end
        return orderConfig.length - 1;
    }
    const abstract = node.type === utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty ||
        node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||
        node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition;
    const scope = 'static' in node && node.static
        ? 'static'
        : abstract
            ? 'abstract'
            : 'instance';
    const accessibility = getAccessibility(node);
    // Collect all existing member groups that apply to this node...
    // (e.g. 'public-instance-field', 'instance-field', 'public-field', 'constructor' etc.)
    const memberGroups = [];
    if (supportsModifiers) {
        const decorated = 'decorators' in node && node.decorators.length > 0;
        if (decorated &&
            (type === 'readonly-field' ||
                type === 'field' ||
                type === 'method' ||
                type === 'accessor' ||
                type === 'get' ||
                type === 'set')) {
            memberGroups.push(`${accessibility}-decorated-${type}`);
            memberGroups.push(`decorated-${type}`);
            if (type === 'readonly-field') {
                memberGroups.push(`${accessibility}-decorated-field`);
                memberGroups.push(`decorated-field`);
            }
        }
        if (type !== 'readonly-signature' &&
            type !== 'signature' &&
            type !== 'static-initialization') {
            if (type !== 'constructor') {
                // Constructors have no scope
                memberGroups.push(`${accessibility}-${scope}-${type}`);
                memberGroups.push(`${scope}-${type}`);
                if (type === 'readonly-field') {
                    memberGroups.push(`${accessibility}-${scope}-field`);
                    memberGroups.push(`${scope}-field`);
                }
            }
            memberGroups.push(`${accessibility}-${type}`);
            if (type === 'readonly-field') {
                memberGroups.push(`${accessibility}-field`);
            }
        }
    }
    memberGroups.push(type);
    if (type === 'readonly-signature') {
        memberGroups.push('signature');
    }
    else if (type === 'readonly-field') {
        memberGroups.push('field');
    }
    // ...then get the rank order for those member groups based on the node
    return getRankOrder(memberGroups, orderConfig);
}
/**
 * Groups members into arrays of consecutive members with the same rank.
 * If, for example, the memberSet parameter looks like the following...
 * @example
 * ```
 * interface Foo {
 *   [a: string]: number;
 *
 *   a: x;
 *   B: x;
 *   c: x;
 *
 *   c(): void;
 *   B(): void;
 *   a(): void;
 *
 *   (): Baz;
 *
 *   new (): Bar;
 * }
 * ```
 * ...the resulting array will look like: [[a, B, c], [c, B, a]].
 * @param memberSet The members to be grouped.
 * @param memberType The configured order of member types.
 * @param supportsModifiers It'll get passed to getRank().
 * @returns The array of groups of members.
 */
function groupMembersByType(members, memberTypes, supportsModifiers) {
    const groupedMembers = [];
    const memberRanks = members.map(member => getRank(member, memberTypes, supportsModifiers));
    let previousRank = undefined;
    members.forEach((member, index) => {
        if (index === members.length - 1) {
            return;
        }
        const rankOfCurrentMember = memberRanks[index];
        const rankOfNextMember = memberRanks[index + 1];
        if (rankOfCurrentMember === previousRank) {
            groupedMembers.at(-1)?.push(member);
        }
        else if (rankOfCurrentMember === rankOfNextMember) {
            groupedMembers.push([member]);
            previousRank = rankOfCurrentMember;
        }
    });
    return groupedMembers;
}
/**
 * Gets the lowest possible rank(s) higher than target.
 * e.g. given the following order:
 *   ...
 *   public-static-method
 *   protected-static-method
 *   private-static-method
 *   public-instance-method
 *   protected-instance-method
 *   private-instance-method
 *   ...
 * and considering that a public-instance-method has already been declared, so ranks contains
 * public-instance-method, then the lowest possible rank for public-static-method is
 * public-instance-method.
 * If a lowest possible rank is a member group, a comma separated list of ranks is returned.
 * @param ranks the existing ranks in the object.
 * @param target the minimum target rank to filter on.
 * @param order the current order to be validated.
 * @returns the name(s) of the lowest possible rank without dashes (-).
 */
function getLowestRank(ranks, target, order) {
    let lowest = ranks[ranks.length - 1];
    ranks.forEach(rank => {
        if (rank > target) {
            lowest = Math.min(lowest, rank);
        }
    });
    const lowestRank = order[lowest];
    const lowestRanks = Array.isArray(lowestRank) ? lowestRank : [lowestRank];
    return lowestRanks.map(rank => rank.replaceAll('-', ' ')).join(', ');
}
exports.default = (0, util_1.createRule)({
    name: 'member-ordering',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require a consistent member declaration order',
            frozen: true,
        },
        messages: {
            incorrectGroupOrder: 'Member {{name}} should be declared before all {{rank}} definitions.',
            incorrectOrder: 'Member {{member}} should be declared before member {{beforeMember}}.',
            incorrectRequiredMembersOrder: `Member {{member}} should be declared after all {{optionalOrRequired}} members.`,
        },
        schema: [
            {
                type: 'object',
                $defs: {
                    allItems: {
                        type: 'string',
                        enum: allMemberTypes,
                    },
                    optionalityOrderOptions: {
                        type: 'string',
                        enum: ['optional-first', 'required-first'],
                    },
                    orderOptions: {
                        type: 'string',
                        enum: [
                            'alphabetically',
                            'alphabetically-case-insensitive',
                            'as-written',
                            'natural',
                            'natural-case-insensitive',
                        ],
                    },
                    typeItems: {
                        type: 'string',
                        enum: [
                            'readonly-signature',
                            'signature',
                            'readonly-field',
                            'field',
                            'method',
                            'constructor',
                        ],
                    },
                    // ajv is order-dependent; these configs must come last
                    baseConfig: {
                        oneOf: [
                            neverConfig,
                            arrayConfig('#/items/0/$defs/allItems'),
                            objectConfig('#/items/0/$defs/allItems'),
                        ],
                    },
                    typesConfig: {
                        oneOf: [
                            neverConfig,
                            arrayConfig('#/items/0/$defs/typeItems'),
                            objectConfig('#/items/0/$defs/typeItems'),
                        ],
                    },
                },
                additionalProperties: false,
                properties: {
                    classes: {
                        $ref: '#/items/0/$defs/baseConfig',
                        description: 'Which ordering to enforce for classes.',
                    },
                    classExpressions: {
                        $ref: '#/items/0/$defs/baseConfig',
                        description: 'Which ordering to enforce for classExpressions.',
                    },
                    default: {
                        $ref: '#/items/0/$defs/baseConfig',
                        description: 'Which ordering to enforce for default.',
                    },
                    interfaces: {
                        $ref: '#/items/0/$defs/typesConfig',
                        description: 'Which ordering to enforce for interfaces.',
                    },
                    typeLiterals: {
                        $ref: '#/items/0/$defs/typesConfig',
                        description: 'Which ordering to enforce for typeLiterals.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            default: {
                memberTypes: exports.defaultOrder,
            },
        },
    ],
    create(context, [options]) {
        /**
         * Checks if the member groups are correctly sorted.
         *
         * @param members Members to be validated.
         * @param groupOrder Group order to be validated.
         * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.
         *
         * @return Array of member groups or null if one of the groups is not correctly sorted.
         */
        function checkGroupSort(members, groupOrder, supportsModifiers) {
            const previousRanks = [];
            const memberGroups = [];
            let isCorrectlySorted = true;
            // Find first member which isn't correctly sorted
            for (const member of members) {
                const rank = getRank(member, groupOrder, supportsModifiers);
                const name = getMemberName(member, context.sourceCode);
                const rankLastMember = previousRanks[previousRanks.length - 1];
                if (rank === -1) {
                    continue;
                }
                // Works for 1st item because x < undefined === false for any x (typeof string)
                if (rank < rankLastMember) {
                    context.report({
                        node: member,
                        messageId: 'incorrectGroupOrder',
                        data: {
                            name,
                            rank: getLowestRank(previousRanks, rank, groupOrder),
                        },
                    });
                    isCorrectlySorted = false;
                }
                else if (rank === rankLastMember) {
                    // Same member group --> Push to existing member group array
                    memberGroups[memberGroups.length - 1].push(member);
                }
                else {
                    // New member group --> Create new member group array
                    previousRanks.push(rank);
                    memberGroups.push([member]);
                }
            }
            return isCorrectlySorted ? memberGroups : null;
        }
        /**
         * Checks if the members are alphabetically sorted.
         *
         * @param members Members to be validated.
         * @param order What order the members should be sorted in.
         *
         * @return True if all members are correctly sorted.
         */
        function checkAlphaSort(members, order) {
            let previousName = '';
            let isCorrectlySorted = true;
            // Find first member which isn't correctly sorted
            members.forEach(member => {
                const name = getMemberName(member, context.sourceCode);
                // Note: Not all members have names
                if (name) {
                    if (naturalOutOfOrder(name, previousName, order)) {
                        context.report({
                            node: member,
                            messageId: 'incorrectOrder',
                            data: {
                                beforeMember: previousName,
                                member: name,
                            },
                        });
                        isCorrectlySorted = false;
                    }
                    previousName = name;
                }
            });
            return isCorrectlySorted;
        }
        function naturalOutOfOrder(name, previousName, order) {
            if (name === previousName) {
                return false;
            }
            switch (order) {
                case 'alphabetically':
                    return name < previousName;
                case 'alphabetically-case-insensitive':
                    return name.toLowerCase() < previousName.toLowerCase();
                case 'natural':
                    return (0, natural_compare_1.default)(name, previousName) !== 1;
                case 'natural-case-insensitive':
                    return ((0, natural_compare_1.default)(name.toLowerCase(), previousName.toLowerCase()) !== 1);
            }
        }
        /**
         * Checks if the order of optional and required members is correct based
         * on the given 'required' parameter.
         *
         * @param members Members to be validated.
         * @param optionalityOrder Where to place optional members, if not intermixed.
         *
         * @return True if all required and optional members are correctly sorted.
         */
        function checkRequiredOrder(members, optionalityOrder) {
            const switchIndex = members.findIndex((member, i) => i && isMemberOptional(member) !== isMemberOptional(members[i - 1]));
            const report = (member) => context.report({
                loc: member.loc,
                messageId: 'incorrectRequiredMembersOrder',
                data: {
                    member: getMemberName(member, context.sourceCode),
                    optionalOrRequired: optionalityOrder === 'required-first' ? 'required' : 'optional',
                },
            });
            // if the optionality of the first item is correct (based on optionalityOrder)
            // then the first 0 inclusive to switchIndex exclusive members all
            // have the correct optionality
            if (isMemberOptional(members[0]) !==
                (optionalityOrder === 'optional-first')) {
                report(members[0]);
                return false;
            }
            for (let i = switchIndex + 1; i < members.length; i++) {
                if (isMemberOptional(members[i]) !==
                    isMemberOptional(members[switchIndex])) {
                    report(members[switchIndex]);
                    return false;
                }
            }
            return true;
        }
        /**
         * Validates if all members are correctly sorted.
         *
         * @param members Members to be validated.
         * @param orderConfig Order config to be validated.
         * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.
         */
        function validateMembersOrder(members, orderConfig, supportsModifiers) {
            if (orderConfig === 'never') {
                return;
            }
            // Standardize config
            let order;
            let memberTypes;
            let optionalityOrder;
            /**
             * It runs an alphabetic sort on the groups of the members of the class in the source code.
             * @param memberSet The members in the class of the source code on which the grouping operation will be performed.
             */
            const checkAlphaSortForAllMembers = (memberSet) => {
                const hasAlphaSort = !!(order && order !== 'as-written');
                if (hasAlphaSort && Array.isArray(memberTypes)) {
                    groupMembersByType(memberSet, memberTypes, supportsModifiers).forEach(members => {
                        checkAlphaSort(members, order);
                    });
                }
            };
            // returns true if everything is good and false if an error was reported
            const checkOrder = (memberSet) => {
                const hasAlphaSort = !!(order && order !== 'as-written');
                // Check order
                if (Array.isArray(memberTypes)) {
                    const grouped = checkGroupSort(memberSet, memberTypes, supportsModifiers);
                    if (grouped == null) {
                        checkAlphaSortForAllMembers(members);
                        return false;
                    }
                    if (hasAlphaSort) {
                        grouped.map(groupMember => checkAlphaSort(groupMember, order));
                    }
                }
                else if (hasAlphaSort) {
                    return checkAlphaSort(memberSet, order);
                }
                return false;
            };
            if (Array.isArray(orderConfig)) {
                memberTypes = orderConfig;
            }
            else {
                order = orderConfig.order;
                memberTypes = orderConfig.memberTypes;
                optionalityOrder = orderConfig.optionalityOrder;
            }
            if (!optionalityOrder) {
                checkOrder(members);
                return;
            }
            const switchIndex = members.findIndex((member, i) => i && isMemberOptional(member) !== isMemberOptional(members[i - 1]));
            if (switchIndex !== -1) {
                if (!checkRequiredOrder(members, optionalityOrder)) {
                    return;
                }
                checkOrder(members.slice(0, switchIndex));
                checkOrder(members.slice(switchIndex));
            }
            else {
                checkOrder(members);
            }
        }
        // https://github.com/typescript-eslint/typescript-eslint/issues/5439
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        return {
            ClassDeclaration(node) {
                validateMembersOrder(node.body.body, options.classes ?? options.default, true);
            },
            'ClassDeclaration, FunctionDeclaration'(node) {
                if ('superClass' in node) {
                    // ...
                }
            },
            ClassExpression(node) {
                validateMembersOrder(node.body.body, options.classExpressions ?? options.default, true);
            },
            TSInterfaceDeclaration(node) {
                validateMembersOrder(node.body.body, options.interfaces ?? options.default, false);
            },
            TSTypeLiteral(node) {
                validateMembersOrder(node.members, options.typeLiterals ?? options.default, false);
            },
        };
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
    },
});


--------------------------------------------------------------------------------
FILE: method-signature-style.d.ts
--------------------------------------------------------------------------------

export type Options = [('method' | 'property')?];
export type MessageIds = 'errorMethod' | 'errorProperty';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: method-signature-style.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'method-signature-style',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce using a particular method signature syntax',
        },
        fixable: 'code',
        messages: {
            errorMethod: 'Shorthand method signature is forbidden. Use a function property instead.',
            errorProperty: 'Function property signature is forbidden. Use a method shorthand instead.',
        },
        schema: [
            {
                type: 'string',
                description: 'The method signature style to enforce using.',
                enum: ['property', 'method'],
            },
        ],
    },
    defaultOptions: ['property'],
    create(context, [mode]) {
        function getMethodKey(node) {
            let key = context.sourceCode.getText(node.key);
            if (node.computed) {
                key = `[${key}]`;
            }
            if (node.optional) {
                key = `${key}?`;
            }
            if (node.readonly) {
                key = `readonly ${key}`;
            }
            return key;
        }
        function getMethodParams(node) {
            let params = '()';
            if (node.params.length > 0) {
                const openingParen = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(node.params[0], util_1.isOpeningParenToken), 'Missing opening paren before first parameter');
                const closingParen = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.params[node.params.length - 1], util_1.isClosingParenToken), 'Missing closing paren after last parameter');
                params = context.sourceCode.text.substring(openingParen.range[0], closingParen.range[1]);
            }
            if (node.typeParameters != null) {
                const typeParams = context.sourceCode.getText(node.typeParameters);
                params = `${typeParams}${params}`;
            }
            return params;
        }
        function getMethodReturnType(node) {
            return node.returnType == null
                ? // if the method has no return type, it implicitly has an `any` return type
                    // we just make it explicit here so we can do the fix
                    'any'
                : context.sourceCode.getText(node.returnType.typeAnnotation);
        }
        function getDelimiter(node) {
            const lastToken = context.sourceCode.getLastToken(node);
            if (lastToken &&
                ((0, util_1.isSemicolonToken)(lastToken) || (0, util_1.isCommaToken)(lastToken))) {
                return lastToken.value;
            }
            return '';
        }
        function isNodeParentModuleDeclaration(node) {
            if (!node.parent) {
                return false;
            }
            if (node.parent.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration) {
                return true;
            }
            if (node.parent.type === utils_1.AST_NODE_TYPES.Program) {
                return false;
            }
            return isNodeParentModuleDeclaration(node.parent);
        }
        return {
            ...(mode === 'property' && {
                TSMethodSignature(methodNode) {
                    if (methodNode.kind !== 'method') {
                        return;
                    }
                    const skipFix = returnTypeReferencesThisType(methodNode.returnType);
                    const parent = methodNode.parent;
                    const members = parent.type === utils_1.AST_NODE_TYPES.TSInterfaceBody
                        ? parent.body
                        : parent.members;
                    const duplicatedKeyMethodNodes = members.filter((element) => element.type === utils_1.AST_NODE_TYPES.TSMethodSignature &&
                        element !== methodNode &&
                        getMethodKey(element) === getMethodKey(methodNode));
                    const isParentModule = isNodeParentModuleDeclaration(methodNode);
                    if (duplicatedKeyMethodNodes.length > 0) {
                        if (isParentModule) {
                            context.report({
                                node: methodNode,
                                messageId: 'errorMethod',
                            });
                        }
                        else {
                            context.report({
                                node: methodNode,
                                messageId: 'errorMethod',
                                fix: skipFix
                                    ? undefined
                                    : function* fix(fixer) {
                                        const methodNodes = [
                                            methodNode,
                                            ...duplicatedKeyMethodNodes,
                                        ].sort((a, b) => (a.range[0] < b.range[0] ? -1 : 1));
                                        const typeString = methodNodes
                                            .map(node => {
                                            const params = getMethodParams(node);
                                            const returnType = getMethodReturnType(node);
                                            return `(${params} => ${returnType})`;
                                        })
                                            .join(' & ');
                                        const key = getMethodKey(methodNode);
                                        const delimiter = getDelimiter(methodNode);
                                        yield fixer.replaceText(methodNode, `${key}: ${typeString}${delimiter}`);
                                        for (const node of duplicatedKeyMethodNodes) {
                                            const lastToken = context.sourceCode.getLastToken(node);
                                            if (lastToken) {
                                                const nextToken = context.sourceCode.getTokenAfter(lastToken);
                                                if (nextToken) {
                                                    yield fixer.remove(node);
                                                    yield fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], '');
                                                }
                                            }
                                        }
                                    },
                            });
                        }
                        return;
                    }
                    if (isParentModule) {
                        context.report({
                            node: methodNode,
                            messageId: 'errorMethod',
                        });
                    }
                    else {
                        context.report({
                            node: methodNode,
                            messageId: 'errorMethod',
                            fix: skipFix
                                ? undefined
                                : fixer => {
                                    const key = getMethodKey(methodNode);
                                    const params = getMethodParams(methodNode);
                                    const returnType = getMethodReturnType(methodNode);
                                    const delimiter = getDelimiter(methodNode);
                                    return fixer.replaceText(methodNode, `${key}: ${params} => ${returnType}${delimiter}`);
                                },
                        });
                    }
                },
            }),
            ...(mode === 'method' && {
                TSPropertySignature(propertyNode) {
                    const typeNode = propertyNode.typeAnnotation?.typeAnnotation;
                    if (typeNode?.type !== utils_1.AST_NODE_TYPES.TSFunctionType) {
                        return;
                    }
                    context.report({
                        node: propertyNode,
                        messageId: 'errorProperty',
                        fix: fixer => {
                            const key = getMethodKey(propertyNode);
                            const params = getMethodParams(typeNode);
                            const returnType = getMethodReturnType(typeNode);
                            const delimiter = getDelimiter(propertyNode);
                            return fixer.replaceText(propertyNode, `${key}${params}: ${returnType}${delimiter}`);
                        },
                    });
                },
            }),
        };
    },
});
function returnTypeReferencesThisType(node) {
    return (node &&
        (0, util_1.forEachChildESTree)(node.typeAnnotation, child => child.type === utils_1.AST_NODE_TYPES.TSThisType));
}


--------------------------------------------------------------------------------
FILE: naming-convention.d.ts
--------------------------------------------------------------------------------

import { TSESLint } from '@typescript-eslint/utils';
import type { Selector } from './naming-convention-utils';
export type MessageIds = 'doesNotMatchFormat' | 'doesNotMatchFormatTrimmed' | 'missingAffix' | 'missingUnderscore' | 'satisfyCustom' | 'unexpectedUnderscore';
export type Options = Selector[];
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: naming-convention.js
--------------------------------------------------------------------------------

"use strict";
// This rule was feature-frozen before we enabled no-property-in-node.
/* eslint-disable eslint-plugin/no-property-in-node */
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const naming_convention_utils_1 = require("./naming-convention-utils");
// This essentially mirrors ESLint's `camelcase` rule
// note that that rule ignores leading and trailing underscores and only checks those in the middle of a variable name
const defaultCamelCaseAllTheThingsConfig = [
    {
        format: ['camelCase'],
        leadingUnderscore: 'allow',
        selector: 'default',
        trailingUnderscore: 'allow',
    },
    {
        format: ['camelCase', 'PascalCase'],
        selector: 'import',
    },
    {
        format: ['camelCase', 'UPPER_CASE'],
        leadingUnderscore: 'allow',
        selector: 'variable',
        trailingUnderscore: 'allow',
    },
    {
        format: ['PascalCase'],
        selector: 'typeLike',
    },
];
exports.default = (0, util_1.createRule)({
    name: 'naming-convention',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce naming conventions for everything across a codebase',
            // technically only requires type checking if the user uses "type" modifiers
            frozen: true,
            requiresTypeChecking: true,
        },
        messages: {
            doesNotMatchFormat: '{{type}} name `{{name}}` must match one of the following formats: {{formats}}',
            doesNotMatchFormatTrimmed: '{{type}} name `{{name}}` trimmed as `{{processedName}}` must match one of the following formats: {{formats}}',
            missingAffix: '{{type}} name `{{name}}` must have one of the following {{position}}es: {{affixes}}',
            missingUnderscore: '{{type}} name `{{name}}` must have {{count}} {{position}} underscore(s).',
            satisfyCustom: '{{type}} name `{{name}}` must {{regexMatch}} the RegExp: {{regex}}',
            unexpectedUnderscore: '{{type}} name `{{name}}` must not have a {{position}} underscore.',
        },
        schema: naming_convention_utils_1.SCHEMA,
    },
    defaultOptions: defaultCamelCaseAllTheThingsConfig,
    create(contextWithoutDefaults) {
        const context = contextWithoutDefaults.options.length > 0
            ? contextWithoutDefaults
            : // only apply the defaults when the user provides no config
                Object.setPrototypeOf({
                    options: defaultCamelCaseAllTheThingsConfig,
                }, contextWithoutDefaults);
        const validators = (0, naming_convention_utils_1.parseOptions)(context);
        const compilerOptions = (0, util_1.getParserServices)(context, true).program?.getCompilerOptions() ?? {};
        function handleMember(validator, node, modifiers) {
            const key = node.key;
            if (requiresQuoting(key, compilerOptions.target)) {
                modifiers.add(naming_convention_utils_1.Modifiers.requiresQuotes);
            }
            validator(key, modifiers);
        }
        function getMemberModifiers(node) {
            const modifiers = new Set();
            if ('key' in node && node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                modifiers.add(naming_convention_utils_1.Modifiers['#private']);
            }
            else if (node.accessibility) {
                modifiers.add(naming_convention_utils_1.Modifiers[node.accessibility]);
            }
            else {
                modifiers.add(naming_convention_utils_1.Modifiers.public);
            }
            if (node.static) {
                modifiers.add(naming_convention_utils_1.Modifiers.static);
            }
            if ('readonly' in node && node.readonly) {
                modifiers.add(naming_convention_utils_1.Modifiers.readonly);
            }
            if ('override' in node && node.override) {
                modifiers.add(naming_convention_utils_1.Modifiers.override);
            }
            if (node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||
                node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
                node.type === utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty) {
                modifiers.add(naming_convention_utils_1.Modifiers.abstract);
            }
            return modifiers;
        }
        const { unusedVariables } = (0, util_1.collectVariables)(context);
        function isUnused(name, initialScope) {
            let variable = null;
            let scope = initialScope;
            while (scope) {
                variable = scope.set.get(name) ?? null;
                if (variable) {
                    break;
                }
                scope = scope.upper;
            }
            if (!variable) {
                return false;
            }
            return unusedVariables.has(variable);
        }
        function isDestructured(id) {
            return (
            // `const { x }`
            // does not match `const { x: y }`
            (id.parent.type === utils_1.AST_NODE_TYPES.Property && id.parent.shorthand) ||
                // `const { x = 2 }`
                // does not match const `{ x: y = 2 }`
                (id.parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern &&
                    id.parent.parent.type === utils_1.AST_NODE_TYPES.Property &&
                    id.parent.parent.shorthand));
        }
        function isAsyncMemberOrProperty(propertyOrMemberNode) {
            return Boolean('value' in propertyOrMemberNode &&
                propertyOrMemberNode.value &&
                'async' in propertyOrMemberNode.value &&
                propertyOrMemberNode.value.async);
        }
        function isAsyncVariableIdentifier(id) {
            return Boolean(('async' in id.parent && id.parent.async) ||
                ('init' in id.parent &&
                    id.parent.init &&
                    'async' in id.parent.init &&
                    id.parent.init.async));
        }
        const selectors = {
            // #region import
            'FunctionDeclaration, TSDeclareFunction, FunctionExpression': {
                handler: (node, validator) => {
                    if (node.id == null) {
                        return;
                    }
                    const modifiers = new Set();
                    // functions create their own nested scope
                    const scope = context.sourceCode.getScope(node).upper;
                    if (isGlobal(scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.global);
                    }
                    if (isExported(node, node.id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.exported);
                    }
                    if (isUnused(node.id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.unused);
                    }
                    if (node.async) {
                        modifiers.add(naming_convention_utils_1.Modifiers.async);
                    }
                    validator(node.id, modifiers);
                },
                validator: validators.function,
            },
            // #endregion
            // #region variable
            'ImportDefaultSpecifier, ImportNamespaceSpecifier, ImportSpecifier': {
                handler: (node, validator) => {
                    const modifiers = new Set();
                    switch (node.type) {
                        case utils_1.AST_NODE_TYPES.ImportDefaultSpecifier:
                            modifiers.add(naming_convention_utils_1.Modifiers.default);
                            break;
                        case utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier:
                            modifiers.add(naming_convention_utils_1.Modifiers.namespace);
                            break;
                        case utils_1.AST_NODE_TYPES.ImportSpecifier:
                            // Handle `import { default as Foo }`
                            if (node.imported.type === utils_1.AST_NODE_TYPES.Identifier &&
                                node.imported.name !== 'default') {
                                return;
                            }
                            modifiers.add(naming_convention_utils_1.Modifiers.default);
                            break;
                    }
                    validator(node.local, modifiers);
                },
                validator: validators.import,
            },
            // #endregion
            // #region function
            VariableDeclarator: {
                handler: (node, validator) => {
                    const identifiers = getIdentifiersFromPattern(node.id);
                    const baseModifiers = new Set();
                    const parent = node.parent;
                    if (parent.kind === 'const') {
                        baseModifiers.add(naming_convention_utils_1.Modifiers.const);
                    }
                    if (isGlobal(context.sourceCode.getScope(node))) {
                        baseModifiers.add(naming_convention_utils_1.Modifiers.global);
                    }
                    identifiers.forEach(id => {
                        const modifiers = new Set(baseModifiers);
                        if (isDestructured(id)) {
                            modifiers.add(naming_convention_utils_1.Modifiers.destructured);
                        }
                        const scope = context.sourceCode.getScope(id);
                        if (isExported(parent, id.name, scope)) {
                            modifiers.add(naming_convention_utils_1.Modifiers.exported);
                        }
                        if (isUnused(id.name, scope)) {
                            modifiers.add(naming_convention_utils_1.Modifiers.unused);
                        }
                        if (isAsyncVariableIdentifier(id)) {
                            modifiers.add(naming_convention_utils_1.Modifiers.async);
                        }
                        validator(id, modifiers);
                    });
                },
                validator: validators.variable,
            },
            // #endregion function
            // #region parameter
            ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type != "ArrowFunctionExpression"][value.type != "FunctionExpression"][value.type != "TSEmptyBodyFunctionExpression"]': {
                handler: (node, validator) => {
                    const modifiers = getMemberModifiers(node);
                    handleMember(validator, node, modifiers);
                },
                validator: validators.classProperty,
            },
            // #endregion parameter
            // #region parameterProperty
            ':not(ObjectPattern) > Property[computed = false][kind = "init"][value.type != "ArrowFunctionExpression"][value.type != "FunctionExpression"][value.type != "TSEmptyBodyFunctionExpression"]': {
                handler: (node, validator) => {
                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);
                    handleMember(validator, node, modifiers);
                },
                validator: validators.objectLiteralProperty,
            },
            // #endregion parameterProperty
            // #region property
            [[
                ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = "ArrowFunctionExpression"]',
                ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = "FunctionExpression"]',
                ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = "TSEmptyBodyFunctionExpression"]',
                ':matches(MethodDefinition, TSAbstractMethodDefinition)[computed = false][kind = "method"]',
            ].join(', ')]: {
                handler: (node, validator) => {
                    const modifiers = getMemberModifiers(node);
                    if (isAsyncMemberOrProperty(node)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.async);
                    }
                    handleMember(validator, node, modifiers);
                },
                validator: validators.classMethod,
            },
            [[
                'MethodDefinition[computed = false]:matches([kind = "get"], [kind = "set"])',
                'TSAbstractMethodDefinition[computed = false]:matches([kind="get"], [kind="set"])',
            ].join(', ')]: {
                handler: (node, validator) => {
                    const modifiers = getMemberModifiers(node);
                    handleMember(validator, node, modifiers);
                },
                validator: validators.classicAccessor,
            },
            [[
                'Property[computed = false][kind = "init"][value.type = "ArrowFunctionExpression"]',
                'Property[computed = false][kind = "init"][value.type = "FunctionExpression"]',
                'Property[computed = false][kind = "init"][value.type = "TSEmptyBodyFunctionExpression"]',
            ].join(', ')]: {
                handler: (node, validator) => {
                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);
                    if (isAsyncMemberOrProperty(node)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.async);
                    }
                    handleMember(validator, node, modifiers);
                },
                validator: validators.objectLiteralMethod,
            },
            // #endregion property
            // #region method
            [[
                'TSMethodSignature[computed = false]',
                'TSPropertySignature[computed = false][typeAnnotation.typeAnnotation.type = "TSFunctionType"]',
            ].join(', ')]: {
                handler: (node, validator) => {
                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);
                    handleMember(validator, node, modifiers);
                },
                validator: validators.typeMethod,
            },
            [[
                utils_1.AST_NODE_TYPES.AccessorProperty,
                utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty,
            ].join(', ')]: {
                handler: (node, validator) => {
                    const modifiers = getMemberModifiers(node);
                    handleMember(validator, node, modifiers);
                },
                validator: validators.autoAccessor,
            },
            'FunctionDeclaration, TSDeclareFunction, TSEmptyBodyFunctionExpression, FunctionExpression, ArrowFunctionExpression': {
                handler: (node, validator) => {
                    node.params.forEach(param => {
                        if (param.type === utils_1.AST_NODE_TYPES.TSParameterProperty) {
                            return;
                        }
                        const identifiers = getIdentifiersFromPattern(param);
                        identifiers.forEach(i => {
                            const modifiers = new Set();
                            if (isDestructured(i)) {
                                modifiers.add(naming_convention_utils_1.Modifiers.destructured);
                            }
                            if (isUnused(i.name, context.sourceCode.getScope(i))) {
                                modifiers.add(naming_convention_utils_1.Modifiers.unused);
                            }
                            validator(i, modifiers);
                        });
                    });
                },
                validator: validators.parameter,
            },
            // #endregion method
            // #region accessor
            'Property[computed = false]:matches([kind = "get"], [kind = "set"])': {
                handler: (node, validator) => {
                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);
                    handleMember(validator, node, modifiers);
                },
                validator: validators.classicAccessor,
            },
            TSParameterProperty: {
                handler: (node, validator) => {
                    const modifiers = getMemberModifiers(node);
                    const identifiers = getIdentifiersFromPattern(node.parameter);
                    identifiers.forEach(i => {
                        validator(i, modifiers);
                    });
                },
                validator: validators.parameterProperty,
            },
            // #endregion accessor
            // #region autoAccessor
            'TSPropertySignature[computed = false][typeAnnotation.typeAnnotation.type != "TSFunctionType"]': {
                handler: (node, validator) => {
                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);
                    if (node.readonly) {
                        modifiers.add(naming_convention_utils_1.Modifiers.readonly);
                    }
                    handleMember(validator, node, modifiers);
                },
                validator: validators.typeProperty,
            },
            // #endregion autoAccessor
            // #region enumMember
            // computed is optional, so can't do [computed = false]
            'ClassDeclaration, ClassExpression': {
                handler: (node, validator) => {
                    const id = node.id;
                    if (id == null) {
                        return;
                    }
                    const modifiers = new Set();
                    // classes create their own nested scope
                    const scope = context.sourceCode.getScope(node).upper;
                    if (node.abstract) {
                        modifiers.add(naming_convention_utils_1.Modifiers.abstract);
                    }
                    if (isExported(node, id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.exported);
                    }
                    if (isUnused(id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.unused);
                    }
                    validator(id, modifiers);
                },
                validator: validators.class,
            },
            // #endregion enumMember
            // #region class
            TSEnumDeclaration: {
                handler: (node, validator) => {
                    const modifiers = new Set();
                    // enums create their own nested scope
                    const scope = context.sourceCode.getScope(node).upper;
                    if (isExported(node, node.id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.exported);
                    }
                    if (isUnused(node.id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.unused);
                    }
                    validator(node.id, modifiers);
                },
                validator: validators.enum,
            },
            // #endregion class
            // #region interface
            TSEnumMember: {
                handler: (node, validator) => {
                    const id = node.id;
                    const modifiers = new Set();
                    if (requiresQuoting(id, compilerOptions.target)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.requiresQuotes);
                    }
                    validator(id, modifiers);
                },
                validator: validators.enumMember,
            },
            // #endregion interface
            // #region typeAlias
            TSInterfaceDeclaration: {
                handler: (node, validator) => {
                    const modifiers = new Set();
                    const scope = context.sourceCode.getScope(node);
                    if (isExported(node, node.id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.exported);
                    }
                    if (isUnused(node.id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.unused);
                    }
                    validator(node.id, modifiers);
                },
                validator: validators.interface,
            },
            // #endregion typeAlias
            // #region enum
            TSTypeAliasDeclaration: {
                handler: (node, validator) => {
                    const modifiers = new Set();
                    const scope = context.sourceCode.getScope(node);
                    if (isExported(node, node.id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.exported);
                    }
                    if (isUnused(node.id.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.unused);
                    }
                    validator(node.id, modifiers);
                },
                validator: validators.typeAlias,
            },
            // #endregion enum
            // #region typeParameter
            'TSTypeParameterDeclaration > TSTypeParameter': {
                handler: (node, validator) => {
                    const modifiers = new Set();
                    const scope = context.sourceCode.getScope(node);
                    if (isUnused(node.name.name, scope)) {
                        modifiers.add(naming_convention_utils_1.Modifiers.unused);
                    }
                    validator(node.name, modifiers);
                },
                validator: validators.typeParameter,
            },
            // #endregion typeParameter
        };
        return Object.fromEntries(Object.entries(selectors).map(([selector, { handler, validator }]) => {
            return [
                selector,
                (node) => {
                    handler(node, validator);
                },
            ];
        }));
    },
});
function getIdentifiersFromPattern(pattern) {
    const identifiers = [];
    const visitor = new scope_manager_1.PatternVisitor({}, pattern, id => identifiers.push(id));
    visitor.visit(pattern);
    return identifiers;
}
function isExported(node, name, scope) {
    if (node?.parent?.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration ||
        node?.parent?.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration) {
        return true;
    }
    if (scope == null) {
        return false;
    }
    const variable = scope.set.get(name);
    if (variable) {
        for (const ref of variable.references) {
            const refParent = ref.identifier.parent;
            if (refParent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration ||
                refParent.type === utils_1.AST_NODE_TYPES.ExportSpecifier) {
                return true;
            }
        }
    }
    return false;
}
function isGlobal(scope) {
    if (scope == null) {
        return false;
    }
    return (scope.type === utils_1.TSESLint.Scope.ScopeType.global ||
        scope.type === utils_1.TSESLint.Scope.ScopeType.module);
}
function requiresQuoting(node, target) {
    const name = node.type === utils_1.AST_NODE_TYPES.Identifier ||
        node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier
        ? node.name
        : `${node.value}`;
    return (0, util_1.requiresQuoting)(name, target);
}


--------------------------------------------------------------------------------
FILE: no-array-constructor.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"useLiteral", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-array-constructor.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const ast_utils_1 = require("@typescript-eslint/utils/ast-utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-array-constructor',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow generic `Array` constructors',
            extendsBaseRule: true,
            recommended: 'recommended',
        },
        fixable: 'code',
        messages: {
            useLiteral: 'The array literal notation [] is preferable.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const sourceCode = context.sourceCode;
        function getArgumentsText(node) {
            const lastToken = sourceCode.getLastToken(node);
            if (lastToken == null || !(0, ast_utils_1.isClosingParenToken)(lastToken)) {
                return '';
            }
            let firstToken = node.callee;
            do {
                firstToken = sourceCode.getTokenAfter(firstToken);
                if (!firstToken || firstToken === lastToken) {
                    return '';
                }
            } while (!(0, ast_utils_1.isOpeningParenToken)(firstToken));
            return sourceCode.text.slice(firstToken.range[1], lastToken.range[0]);
        }
        /**
         * Disallow construction of dense arrays using the Array constructor
         * @param node node to evaluate
         */
        function check(node) {
            if (node.arguments.length !== 1 &&
                node.callee.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.callee.name === 'Array' &&
                !node.typeArguments) {
                context.report({
                    node,
                    messageId: 'useLiteral',
                    fix(fixer) {
                        const argsText = getArgumentsText(node);
                        return fixer.replaceText(node, `[${argsText}]`);
                    },
                });
            }
        }
        return {
            CallExpression: check,
            NewExpression: check,
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-array-delete.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageId = 'noArrayDelete' | 'useSplice';
declare const _default: TSESLint.RuleModule<MessageId, [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-array-delete.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-array-delete',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow using the `delete` operator on array values',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            noArrayDelete: 'Using the `delete` operator with an array expression is unsafe.',
            useSplice: 'Use `array.splice()` instead.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function isUnderlyingTypeArray(type) {
            const predicate = (t) => checker.isArrayType(t) || checker.isTupleType(t);
            if (type.isUnion()) {
                return type.types.every(predicate);
            }
            if (type.isIntersection()) {
                return type.types.some(predicate);
            }
            return predicate(type);
        }
        return {
            'UnaryExpression[operator="delete"]'(node) {
                const { argument } = node;
                if (argument.type !== utils_1.AST_NODE_TYPES.MemberExpression) {
                    return;
                }
                const type = (0, util_1.getConstrainedTypeAtLocation)(services, argument.object);
                if (!isUnderlyingTypeArray(type)) {
                    return;
                }
                context.report({
                    node,
                    messageId: 'noArrayDelete',
                    suggest: [
                        {
                            messageId: 'useSplice',
                            fix(fixer) {
                                const { object, property } = argument;
                                const shouldHaveParentheses = property.type === utils_1.AST_NODE_TYPES.SequenceExpression;
                                const nodeMap = services.esTreeNodeToTSNodeMap;
                                const target = nodeMap.get(object).getText();
                                const rawKey = nodeMap.get(property).getText();
                                const key = shouldHaveParentheses ? `(${rawKey})` : rawKey;
                                let suggestion = `${target}.splice(${key}, 1)`;
                                const comments = context.sourceCode.getCommentsInside(node);
                                if (comments.length > 0) {
                                    const indentationCount = node.loc.start.column;
                                    const indentation = ' '.repeat(indentationCount);
                                    const commentsText = comments
                                        .map(comment => {
                                        return comment.type === utils_1.AST_TOKEN_TYPES.Line
                                            ? `//${comment.value}`
                                            : `/*${comment.value}*/`;
                                    })
                                        .join(`\n${indentation}`);
                                    suggestion = `${commentsText}\n${indentation}${suggestion}`;
                                }
                                return fixer.replaceText(node, suggestion);
                            },
                        },
                    ],
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-base-to-string.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        ignoredTypeNames?: string[];
        checkUnknown?: boolean;
    }
];
export type MessageIds = 'baseArrayJoin' | 'baseToString';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-base-to-string.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
var Usefulness;
(function (Usefulness) {
    Usefulness["Always"] = "always";
    Usefulness["Never"] = "will";
    Usefulness["Sometimes"] = "may";
})(Usefulness || (Usefulness = {}));
const canHaveTypeParameters = (declaration) => {
    return (ts.isTypeAliasDeclaration(declaration) ||
        ts.isInterfaceDeclaration(declaration) ||
        ts.isClassDeclaration(declaration));
};
exports.default = (0, util_1.createRule)({
    name: 'no-base-to-string',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require `.toString()` and `.toLocaleString()` to only be called on objects which provide useful information when stringified',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            baseArrayJoin: "Using `join()` for {{name}} {{certainty}} use Object's default stringification format ('[object Object]') when stringified.",
            baseToString: "'{{name}}' {{certainty}} use Object's default stringification format ('[object Object]') when stringified.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    checkUnknown: {
                        type: 'boolean',
                        description: 'Whether to also check values of type `unknown`',
                    },
                    ignoredTypeNames: {
                        type: 'array',
                        description: 'Stringified type names to ignore.',
                        items: {
                            type: 'string',
                        },
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            checkUnknown: false,
            ignoredTypeNames: ['Error', 'RegExp', 'URL', 'URLSearchParams'],
        },
    ],
    create(context, [option]) {
        const services = (0, util_1.getParserServices)(context);
        const { program } = services;
        const checker = program.getTypeChecker();
        const ignoredTypeNames = option.ignoredTypeNames ?? [];
        function checkExpression(node, type) {
            if (node.type === utils_1.AST_NODE_TYPES.Literal) {
                return;
            }
            const certainty = collectToStringCertainty(type ?? services.getTypeAtLocation(node), new Set());
            if (certainty === Usefulness.Always) {
                return;
            }
            context.report({
                node,
                messageId: 'baseToString',
                data: {
                    name: context.sourceCode.getText(node),
                    certainty,
                },
            });
        }
        function checkExpressionForArrayJoin(node, type) {
            const certainty = collectJoinCertainty(type, new Set());
            if (certainty === Usefulness.Always) {
                return;
            }
            context.report({
                node,
                messageId: 'baseArrayJoin',
                data: {
                    name: context.sourceCode.getText(node),
                    certainty,
                },
            });
        }
        function collectUnionTypeCertainty(type, collectSubTypeCertainty) {
            const certainties = type.types.map(t => collectSubTypeCertainty(t));
            if (certainties.every(certainty => certainty === Usefulness.Never)) {
                return Usefulness.Never;
            }
            if (certainties.every(certainty => certainty === Usefulness.Always)) {
                return Usefulness.Always;
            }
            return Usefulness.Sometimes;
        }
        function collectIntersectionTypeCertainty(type, collectSubTypeCertainty) {
            for (const subType of type.types) {
                const subtypeUsefulness = collectSubTypeCertainty(subType);
                if (subtypeUsefulness === Usefulness.Always) {
                    return Usefulness.Always;
                }
            }
            return Usefulness.Never;
        }
        function collectTupleCertainty(type, visited) {
            const typeArgs = checker.getTypeArguments(type);
            const certainties = typeArgs.map(t => collectToStringCertainty(t, visited));
            if (certainties.some(certainty => certainty === Usefulness.Never)) {
                return Usefulness.Never;
            }
            if (certainties.some(certainty => certainty === Usefulness.Sometimes)) {
                return Usefulness.Sometimes;
            }
            return Usefulness.Always;
        }
        function collectArrayCertainty(type, visited) {
            const elemType = (0, util_1.nullThrows)(type.getNumberIndexType(), 'array should have number index type');
            return collectToStringCertainty(elemType, visited);
        }
        function collectJoinCertainty(type, visited) {
            if (tsutils.isUnionType(type)) {
                return collectUnionTypeCertainty(type, t => collectJoinCertainty(t, visited));
            }
            if (tsutils.isIntersectionType(type)) {
                return collectIntersectionTypeCertainty(type, t => collectJoinCertainty(t, visited));
            }
            if (checker.isTupleType(type)) {
                return collectTupleCertainty(type, visited);
            }
            if (checker.isArrayType(type)) {
                return collectArrayCertainty(type, visited);
            }
            return Usefulness.Always;
        }
        function collectToStringCertainty(type, visited) {
            if (visited.has(type)) {
                // don't report if this is a self referencing array or tuple type
                return Usefulness.Always;
            }
            if (tsutils.isTypeParameter(type)) {
                const constraint = type.getConstraint();
                if (constraint) {
                    return collectToStringCertainty(constraint, visited);
                }
                // unconstrained generic means `unknown`
                return option.checkUnknown ? Usefulness.Sometimes : Usefulness.Always;
            }
            // the Boolean type definition missing toString()
            if (type.flags & ts.TypeFlags.Boolean ||
                type.flags & ts.TypeFlags.BooleanLiteral) {
                return Usefulness.Always;
            }
            const symbol = type.aliasSymbol ?? type.getSymbol();
            const decl = symbol?.getDeclarations()?.[0];
            if (decl &&
                canHaveTypeParameters(decl) &&
                decl.typeParameters &&
                ignoredTypeNames.includes(symbol.name)) {
                return Usefulness.Always;
            }
            if ((0, util_1.matchesTypeOrBaseType)(services, type => ignoredTypeNames.includes((0, util_1.getTypeName)(checker, type)), type)) {
                return Usefulness.Always;
            }
            if (type.isIntersection()) {
                return collectIntersectionTypeCertainty(type, t => collectToStringCertainty(t, visited));
            }
            if (type.isUnion()) {
                return collectUnionTypeCertainty(type, t => collectToStringCertainty(t, visited));
            }
            if (checker.isTupleType(type)) {
                return collectTupleCertainty(type, new Set([...visited, type]));
            }
            if (checker.isArrayType(type)) {
                return collectArrayCertainty(type, new Set([...visited, type]));
            }
            switch (isToStringLikeFromObject(type)) {
                case undefined:
                    // unknown
                    if (option.checkUnknown && type.flags === ts.TypeFlags.Unknown) {
                        return Usefulness.Sometimes;
                    }
                    // e.g. any
                    return Usefulness.Always;
                case true:
                    return Usefulness.Never;
                case false:
                    return Usefulness.Always;
            }
        }
        function isBuiltInStringCall(node) {
            if (node.callee.type === utils_1.AST_NODE_TYPES.Identifier &&
                // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
                node.callee.name === 'String' &&
                node.arguments[0]) {
                const scope = context.sourceCode.getScope(node);
                // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
                const variable = scope.set.get('String');
                return !variable?.defs.length;
            }
            return false;
        }
        function isSymbolToPrimitiveMethod(node) {
            return (ts.isMethodSignature(node) &&
                ts.isComputedPropertyName(node.name) &&
                ts.isPropertyAccessExpression(node.name.expression) &&
                ts.isIdentifier(node.name.expression.expression) &&
                node.name.expression.expression.text === 'Symbol' &&
                ts.isIdentifier(node.name.expression.name) &&
                node.name.expression.name.text === 'toPrimitive' &&
                checker
                    .getSymbolAtLocation(node.name.expression.expression)
                    ?.valueDeclaration?.getSourceFile().hasNoDefaultLib);
        }
        function isToStringLikeFromObject(type) {
            // An explicit [Symbol.toPrimitive] declaration is always user-defined
            if (type
                .getProperties()
                .some(property => property.valueDeclaration &&
                isSymbolToPrimitiveMethod(property.valueDeclaration))) {
                return false;
            }
            // Otherwise, we check for known methods used in type coercion.
            // We'll try to find one that's not declared on Object itself.
            // Failing that, we'll fall back to one that is.
            let foundFallbackOnObject = false;
            for (const propertyName of ['toLocaleString', 'toString', 'valueOf']) {
                const candidate = checker.getPropertyOfType(type, propertyName);
                if (!candidate) {
                    continue;
                }
                const declarations = candidate.getDeclarations();
                // If there are multiple declarations, at least one of them must not be
                // the default object toString.
                //
                // This may only matter for older versions of TS
                // see https://github.com/typescript-eslint/typescript-eslint/issues/8585
                if (declarations?.length !== 1) {
                    continue;
                }
                // Not being the Object interface means this is user-defined.
                if (!ts.isInterfaceDeclaration(declarations[0].parent) ||
                    declarations[0].parent.name.text !== 'Object') {
                    return false;
                }
                foundFallbackOnObject = true;
            }
            return foundFallbackOnObject ? true : undefined;
        }
        return {
            'AssignmentExpression[operator = "+="], BinaryExpression[operator = "+"]'(node) {
                const leftType = services.getTypeAtLocation(node.left);
                const rightType = services.getTypeAtLocation(node.right);
                if ((0, util_1.getTypeName)(checker, leftType) === 'string') {
                    checkExpression(node.right, rightType);
                }
                else if ((0, util_1.getTypeName)(checker, rightType) === 'string' &&
                    node.left.type !== utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                    checkExpression(node.left, leftType);
                }
            },
            CallExpression(node) {
                if (isBuiltInStringCall(node) &&
                    node.arguments[0].type !== utils_1.AST_NODE_TYPES.SpreadElement) {
                    checkExpression(node.arguments[0]);
                }
            },
            'CallExpression > MemberExpression.callee > Identifier[name = "join"].property'(node) {
                const memberExpr = node.parent;
                const type = (0, util_1.getConstrainedTypeAtLocation)(services, memberExpr.object);
                checkExpressionForArrayJoin(memberExpr.object, type);
            },
            'CallExpression > MemberExpression.callee > Identifier[name = /^(toLocaleString|toString)$/].property'(node) {
                const memberExpr = node.parent;
                checkExpression(memberExpr.object);
            },
            TemplateLiteral(node) {
                if (node.parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {
                    return;
                }
                for (const expression of node.expressions) {
                    checkExpression(expression);
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-confusing-non-null-assertion.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageId = 'confusingAssign' | 'confusingEqual' | 'confusingOperator' | 'notNeedInAssign' | 'notNeedInEqualTest' | 'notNeedInOperator' | 'wrapUpLeft';
declare const _default: TSESLint.RuleModule<MessageId, [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-confusing-non-null-assertion.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const confusingOperators = new Set([
    '=',
    '==',
    '===',
    'in',
    'instanceof',
]);
function isConfusingOperator(operator) {
    return confusingOperators.has(operator);
}
exports.default = (0, util_1.createRule)({
    name: 'no-confusing-non-null-assertion',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow non-null assertion in locations that may be confusing',
            recommended: 'stylistic',
        },
        hasSuggestions: true,
        messages: {
            confusingAssign: 'Confusing combination of non-null assertion and assignment like `a! = b`, which looks very similar to `a != b`.',
            confusingEqual: 'Confusing combination of non-null assertion and equality test like `a! == b`, which looks very similar to `a !== b`.',
            confusingOperator: 'Confusing combination of non-null assertion and `{{operator}}` operator like `a! {{operator}} b`, which might be misinterpreted as `!(a {{operator}} b)`.',
            notNeedInAssign: 'Remove unnecessary non-null assertion (!) in assignment left-hand side.',
            notNeedInEqualTest: 'Remove unnecessary non-null assertion (!) in equality test.',
            notNeedInOperator: 'Remove possibly unnecessary non-null assertion (!) in the left operand of the `{{operator}}` operator.',
            wrapUpLeft: 'Wrap the left-hand side in parentheses to avoid confusion with "{{operator}}" operator.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function confusingOperatorToMessageData(operator) {
            switch (operator) {
                case '=':
                    return {
                        messageId: 'confusingAssign',
                    };
                case '==':
                case '===':
                    return {
                        messageId: 'confusingEqual',
                    };
                case 'in':
                case 'instanceof':
                    return {
                        messageId: 'confusingOperator',
                        data: { operator },
                    };
                // istanbul ignore next
                default:
                    operator;
                    throw new Error(`Unexpected operator ${operator}`);
            }
        }
        return {
            'BinaryExpression, AssignmentExpression'(node) {
                const operator = node.operator;
                if (isConfusingOperator(operator)) {
                    // Look for a non-null assertion as the last token on the left hand side.
                    // That way, we catch things like `1 + two! === 3`, even though the left
                    // hand side isn't a non-null assertion AST node.
                    const leftHandFinalToken = context.sourceCode.getLastToken(node.left);
                    const tokenAfterLeft = context.sourceCode.getTokenAfter(node.left);
                    if (leftHandFinalToken?.type === utils_1.AST_TOKEN_TYPES.Punctuator &&
                        leftHandFinalToken.value === '!' &&
                        tokenAfterLeft?.value !== ')') {
                        if (node.left.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {
                            let suggestions;
                            switch (operator) {
                                case '=':
                                    suggestions = [
                                        {
                                            messageId: 'notNeedInAssign',
                                            fix: (fixer) => fixer.remove(leftHandFinalToken),
                                        },
                                    ];
                                    break;
                                case '==':
                                case '===':
                                    suggestions = [
                                        {
                                            messageId: 'notNeedInEqualTest',
                                            fix: (fixer) => fixer.remove(leftHandFinalToken),
                                        },
                                    ];
                                    break;
                                case 'in':
                                case 'instanceof':
                                    suggestions = [
                                        {
                                            messageId: 'notNeedInOperator',
                                            data: { operator },
                                            fix: (fixer) => fixer.remove(leftHandFinalToken),
                                        },
                                        {
                                            messageId: 'wrapUpLeft',
                                            data: { operator },
                                            fix: wrapUpLeftFixer(node),
                                        },
                                    ];
                                    break;
                                // istanbul ignore next
                                default:
                                    operator;
                                    return;
                            }
                            context.report({
                                node,
                                ...confusingOperatorToMessageData(operator),
                                suggest: suggestions,
                            });
                        }
                        else {
                            context.report({
                                node,
                                ...confusingOperatorToMessageData(operator),
                                suggest: [
                                    {
                                        messageId: 'wrapUpLeft',
                                        data: { operator },
                                        fix: wrapUpLeftFixer(node),
                                    },
                                ],
                            });
                        }
                    }
                }
            },
        };
    },
});
function wrapUpLeftFixer(node) {
    return (fixer) => [
        fixer.insertTextBefore(node.left, '('),
        fixer.insertTextAfter(node.left, ')'),
    ];
}


--------------------------------------------------------------------------------
FILE: no-confusing-void-expression.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        ignoreArrowShorthand?: boolean;
        ignoreVoidOperator?: boolean;
        ignoreVoidReturningFunctions?: boolean;
    }
];
export type MessageId = 'invalidVoidExpr' | 'invalidVoidExprArrow' | 'invalidVoidExprArrowWrapVoid' | 'invalidVoidExprReturn' | 'invalidVoidExprReturnLast' | 'invalidVoidExprReturnWrapVoid' | 'invalidVoidExprWrapVoid' | 'voidExprWrapVoid';
declare const _default: TSESLint.RuleModule<MessageId, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-confusing-void-expression.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const getParentFunctionNode_1 = require("../util/getParentFunctionNode");
exports.default = (0, util_1.createRule)({
    name: 'no-confusing-void-expression',
    meta: {
        type: 'problem',
        docs: {
            description: 'Require expressions of type void to appear in statement position',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            invalidVoidExpr: 'Placing a void expression inside another expression is forbidden. ' +
                'Move it to its own statement instead.',
            invalidVoidExprArrow: 'Returning a void expression from an arrow function shorthand is forbidden. ' +
                'Please add braces to the arrow function.',
            invalidVoidExprArrowWrapVoid: 'Void expressions returned from an arrow function shorthand ' +
                'must be marked explicitly with the `void` operator.',
            invalidVoidExprReturn: 'Returning a void expression from a function is forbidden. ' +
                'Please move it before the `return` statement.',
            invalidVoidExprReturnLast: 'Returning a void expression from a function is forbidden. ' +
                'Please remove the `return` statement.',
            invalidVoidExprReturnWrapVoid: 'Void expressions returned from a function ' +
                'must be marked explicitly with the `void` operator.',
            invalidVoidExprWrapVoid: 'Void expressions used inside another expression ' +
                'must be moved to its own statement ' +
                'or marked explicitly with the `void` operator.',
            voidExprWrapVoid: 'Mark with an explicit `void` operator.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ignoreArrowShorthand: {
                        type: 'boolean',
                        description: 'Whether to ignore "shorthand" `() =>` arrow functions: those without `{ ... }` braces.',
                    },
                    ignoreVoidOperator: {
                        type: 'boolean',
                        description: 'Whether to ignore returns that start with the `void` operator.',
                    },
                    ignoreVoidReturningFunctions: {
                        type: 'boolean',
                        description: 'Whether to ignore returns from functions with explicit `void` return types and functions with contextual `void` return types.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            ignoreArrowShorthand: false,
            ignoreVoidOperator: false,
            ignoreVoidReturningFunctions: false,
        },
    ],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        return {
            'AwaitExpression, CallExpression, TaggedTemplateExpression'(node) {
                const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);
                if (!tsutils.isTypeFlagSet(type, ts.TypeFlags.VoidLike)) {
                    // not a void expression
                    return;
                }
                const invalidAncestor = findInvalidAncestor(node);
                if (invalidAncestor == null) {
                    // void expression is in valid position
                    return;
                }
                const wrapVoidFix = (fixer) => {
                    const nodeText = context.sourceCode.getText(node);
                    const newNodeText = `void ${nodeText}`;
                    return fixer.replaceText(node, newNodeText);
                };
                if (invalidAncestor.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {
                    // handle arrow function shorthand
                    if (options.ignoreVoidReturningFunctions) {
                        const returnsVoid = isVoidReturningFunctionNode(invalidAncestor);
                        if (returnsVoid) {
                            return;
                        }
                    }
                    if (options.ignoreVoidOperator) {
                        // handle wrapping with `void`
                        return context.report({
                            node,
                            messageId: 'invalidVoidExprArrowWrapVoid',
                            fix: wrapVoidFix,
                        });
                    }
                    // handle wrapping with braces
                    const arrowFunction = invalidAncestor;
                    return context.report({
                        node,
                        messageId: 'invalidVoidExprArrow',
                        fix(fixer) {
                            if (!canFix(arrowFunction)) {
                                return null;
                            }
                            const arrowBody = arrowFunction.body;
                            const arrowBodyText = context.sourceCode.getText(arrowBody);
                            const newArrowBodyText = `{ ${arrowBodyText}; }`;
                            if ((0, util_1.isParenthesized)(arrowBody, context.sourceCode)) {
                                const bodyOpeningParen = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(arrowBody, util_1.isOpeningParenToken), util_1.NullThrowsReasons.MissingToken('opening parenthesis', 'arrow body'));
                                const bodyClosingParen = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(arrowBody, util_1.isClosingParenToken), util_1.NullThrowsReasons.MissingToken('closing parenthesis', 'arrow body'));
                                return fixer.replaceTextRange([bodyOpeningParen.range[0], bodyClosingParen.range[1]], newArrowBodyText);
                            }
                            return fixer.replaceText(arrowBody, newArrowBodyText);
                        },
                    });
                }
                if (invalidAncestor.type === utils_1.AST_NODE_TYPES.ReturnStatement) {
                    // handle return statement
                    if (options.ignoreVoidReturningFunctions) {
                        const functionNode = (0, getParentFunctionNode_1.getParentFunctionNode)(invalidAncestor);
                        if (functionNode) {
                            const returnsVoid = isVoidReturningFunctionNode(functionNode);
                            if (returnsVoid) {
                                return;
                            }
                        }
                    }
                    if (options.ignoreVoidOperator) {
                        // handle wrapping with `void`
                        return context.report({
                            node,
                            messageId: 'invalidVoidExprReturnWrapVoid',
                            fix: wrapVoidFix,
                        });
                    }
                    if (isFinalReturn(invalidAncestor)) {
                        // remove the `return` keyword
                        return context.report({
                            node,
                            messageId: 'invalidVoidExprReturnLast',
                            fix(fixer) {
                                if (!canFix(invalidAncestor)) {
                                    return null;
                                }
                                const returnValue = invalidAncestor.argument;
                                const returnValueText = context.sourceCode.getText(returnValue);
                                let newReturnStmtText = `${returnValueText};`;
                                if (isPreventingASI(returnValue)) {
                                    // put a semicolon at the beginning of the line
                                    newReturnStmtText = `;${newReturnStmtText}`;
                                }
                                return fixer.replaceText(invalidAncestor, newReturnStmtText);
                            },
                        });
                    }
                    // move before the `return` keyword
                    return context.report({
                        node,
                        messageId: 'invalidVoidExprReturn',
                        fix(fixer) {
                            const returnValue = invalidAncestor.argument;
                            const returnValueText = context.sourceCode.getText(returnValue);
                            let newReturnStmtText = `${returnValueText}; return;`;
                            if (isPreventingASI(returnValue)) {
                                // put a semicolon at the beginning of the line
                                newReturnStmtText = `;${newReturnStmtText}`;
                            }
                            if (invalidAncestor.parent.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
                                // e.g. `if (cond) return console.error();`
                                // add braces if not inside a block
                                newReturnStmtText = `{ ${newReturnStmtText} }`;
                            }
                            return fixer.replaceText(invalidAncestor, newReturnStmtText);
                        },
                    });
                }
                // handle generic case
                if (options.ignoreVoidOperator) {
                    // this would be reported by this rule btw. such irony
                    return context.report({
                        node,
                        messageId: 'invalidVoidExprWrapVoid',
                        suggest: [{ messageId: 'voidExprWrapVoid', fix: wrapVoidFix }],
                    });
                }
                context.report({
                    node,
                    messageId: 'invalidVoidExpr',
                });
            },
        };
        /**
         * Inspects the void expression's ancestors and finds closest invalid one.
         * By default anything other than an ExpressionStatement is invalid.
         * Parent expressions which can be used for their short-circuiting behavior
         * are ignored and their parents are checked instead.
         * @param node The void expression node to check.
         * @returns Invalid ancestor node if it was found. `null` otherwise.
         */
        function findInvalidAncestor(node) {
            const parent = node.parent;
            if (parent.type === utils_1.AST_NODE_TYPES.SequenceExpression &&
                node !== parent.expressions[parent.expressions.length - 1]) {
                return null;
            }
            if (parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {
                // e.g. `{ console.log("foo"); }`
                // this is always valid
                return null;
            }
            if (parent.type === utils_1.AST_NODE_TYPES.LogicalExpression &&
                parent.right === node) {
                // e.g. `x && console.log(x)`
                // this is valid only if the next ancestor is valid
                return findInvalidAncestor(parent);
            }
            if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression &&
                (parent.consequent === node || parent.alternate === node)) {
                // e.g. `cond ? console.log(true) : console.log(false)`
                // this is valid only if the next ancestor is valid
                return findInvalidAncestor(parent);
            }
            if (parent.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&
                // e.g. `() => console.log("foo")`
                // this is valid with an appropriate option
                options.ignoreArrowShorthand) {
                return null;
            }
            if (parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                parent.operator === 'void' &&
                // e.g. `void console.log("foo")`
                // this is valid with an appropriate option
                options.ignoreVoidOperator) {
                return null;
            }
            if (parent.type === utils_1.AST_NODE_TYPES.ChainExpression) {
                // e.g. `console?.log('foo')`
                return findInvalidAncestor(parent);
            }
            // Any other parent is invalid.
            // We can assume a return statement will have an argument.
            return parent;
        }
        /** Checks whether the return statement is the last statement in a function body. */
        function isFinalReturn(node) {
            // the parent must be a block
            const block = node.parent;
            if (block.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
                // e.g. `if (cond) return;` (not in a block)
                return false;
            }
            // the block's parent must be a function
            const blockParent = block.parent;
            if (![
                utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
                utils_1.AST_NODE_TYPES.FunctionDeclaration,
                utils_1.AST_NODE_TYPES.FunctionExpression,
            ].includes(blockParent.type)) {
                // e.g. `if (cond) { return; }`
                // not in a top-level function block
                return false;
            }
            // must be the last child of the block
            if (block.body.indexOf(node) < block.body.length - 1) {
                // not the last statement in the block
                return false;
            }
            return true;
        }
        /**
         * Checks whether the given node, if placed on its own line,
         * would prevent automatic semicolon insertion on the line before.
         *
         * This happens if the line begins with `(`, `[` or `` ` ``
         */
        function isPreventingASI(node) {
            const startToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node), util_1.NullThrowsReasons.MissingToken('first token', node.type));
            return ['(', '[', '`'].includes(startToken.value);
        }
        function canFix(node) {
            const targetNode = node.type === utils_1.AST_NODE_TYPES.ReturnStatement
                ? node.argument
                : node.body;
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, targetNode);
            return tsutils.isTypeFlagSet(type, ts.TypeFlags.VoidLike);
        }
        function isFunctionReturnTypeIncludesVoid(functionType) {
            const callSignatures = tsutils.getCallSignaturesOfType(functionType);
            return callSignatures.some(signature => {
                const returnType = signature.getReturnType();
                return tsutils
                    .unionConstituents(returnType)
                    .some(tsutils.isIntrinsicVoidType);
            });
        }
        function isVoidReturningFunctionNode(functionNode) {
            // Game plan:
            //   - If the function node has a type annotation, check if it includes `void`.
            //     - If it does then the function is safe to return `void` expressions in.
            //   - Otherwise, check if the function is a function-expression or an arrow-function.
            //   -   If it is, get its contextual type and bail if we cannot.
            //   - Return based on whether the contextual type includes `void` or not
            const functionTSNode = services.esTreeNodeToTSNodeMap.get(functionNode);
            if (functionTSNode.type) {
                const returnType = checker.getTypeFromTypeNode(functionTSNode.type);
                return tsutils
                    .unionConstituents(returnType)
                    .some(tsutils.isIntrinsicVoidType);
            }
            if (ts.isExpression(functionTSNode)) {
                const functionType = checker.getContextualType(functionTSNode);
                if (functionType) {
                    return tsutils
                        .unionConstituents(functionType)
                        .some(isFunctionReturnTypeIncludesVoid);
                }
            }
            return false;
        }
    },
});


--------------------------------------------------------------------------------
FILE: no-deprecated.d.ts
--------------------------------------------------------------------------------

import type { TypeOrValueSpecifier } from '../util';
type MessageIds = 'deprecated' | 'deprecatedWithReason';
type Options = [
    {
        allow?: TypeOrValueSpecifier[];
    }
];
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-deprecated.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-deprecated',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow using code marked as `@deprecated`',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        messages: {
            deprecated: `\`{{name}}\` is deprecated.`,
            deprecatedWithReason: `\`{{name}}\` is deprecated. {{reason}}`,
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allow: {
                        ...util_1.typeOrValueSpecifiersSchema,
                        description: 'Type specifiers that can be allowed.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allow: [],
        },
    ],
    create(context, [options]) {
        const { jsDocParsingMode } = context.parserOptions;
        const allow = options.allow;
        if (jsDocParsingMode === 'none' || jsDocParsingMode === 'type-info') {
            throw new Error(`Cannot be used with jsDocParsingMode: '${jsDocParsingMode}'.`);
        }
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        // Deprecated jsdoc tags can be added on some symbol alias, e.g.
        //
        // export { /** @deprecated */ foo }
        //
        // When we import foo, its symbol is an alias of the exported foo (the one
        // with the deprecated tag), which is itself an alias of the original foo.
        // Therefore, we carefully go through the chain of aliases and check each
        // immediate alias for deprecated tags
        function searchForDeprecationInAliasesChain(symbol, checkDeprecationsOfAliasedSymbol) {
            if (!symbol || !tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)) {
                return checkDeprecationsOfAliasedSymbol
                    ? getJsDocDeprecation(symbol)
                    : undefined;
            }
            const targetSymbol = checker.getAliasedSymbol(symbol);
            while (tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)) {
                const reason = getJsDocDeprecation(symbol);
                if (reason != null) {
                    return reason;
                }
                const immediateAliasedSymbol = symbol.getDeclarations() && checker.getImmediateAliasedSymbol(symbol);
                if (!immediateAliasedSymbol) {
                    break;
                }
                symbol = immediateAliasedSymbol;
                if (checkDeprecationsOfAliasedSymbol && symbol === targetSymbol) {
                    return getJsDocDeprecation(symbol);
                }
            }
            return undefined;
        }
        function isDeclaration(node) {
            const { parent } = node;
            switch (parent.type) {
                case utils_1.AST_NODE_TYPES.ArrayPattern:
                    return parent.elements.includes(node);
                case utils_1.AST_NODE_TYPES.ClassExpression:
                case utils_1.AST_NODE_TYPES.ClassDeclaration:
                case utils_1.AST_NODE_TYPES.VariableDeclarator:
                case utils_1.AST_NODE_TYPES.TSEnumMember:
                    return parent.id === node;
                case utils_1.AST_NODE_TYPES.MethodDefinition:
                case utils_1.AST_NODE_TYPES.PropertyDefinition:
                case utils_1.AST_NODE_TYPES.AccessorProperty:
                    return parent.key === node;
                case utils_1.AST_NODE_TYPES.Property:
                    // foo in "const { foo } = bar" will be processed twice, as parent.key
                    // and parent.value. The second is treated as a declaration.
                    if (parent.shorthand && parent.value === node) {
                        return parent.parent.type === utils_1.AST_NODE_TYPES.ObjectPattern;
                    }
                    if (parent.value === node) {
                        return false;
                    }
                    return parent.parent.type === utils_1.AST_NODE_TYPES.ObjectExpression;
                case utils_1.AST_NODE_TYPES.AssignmentPattern:
                    // foo in "const { foo = "" } = bar" will be processed twice, as parent.parent.key
                    // and parent.left. The second is treated as a declaration.
                    return parent.left === node;
                case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                case utils_1.AST_NODE_TYPES.FunctionDeclaration:
                case utils_1.AST_NODE_TYPES.FunctionExpression:
                case utils_1.AST_NODE_TYPES.TSDeclareFunction:
                case utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression:
                case utils_1.AST_NODE_TYPES.TSEnumDeclaration:
                case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:
                case utils_1.AST_NODE_TYPES.TSMethodSignature:
                case utils_1.AST_NODE_TYPES.TSModuleDeclaration:
                case utils_1.AST_NODE_TYPES.TSParameterProperty:
                case utils_1.AST_NODE_TYPES.TSPropertySignature:
                case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:
                case utils_1.AST_NODE_TYPES.TSTypeParameter:
                    return true;
                // treat `export import Bar = Foo;` (and `import Foo = require('...')`) as declarations
                case utils_1.AST_NODE_TYPES.TSImportEqualsDeclaration:
                    return parent.id === node;
                default:
                    return false;
            }
        }
        function isInsideImport(node) {
            let current = node;
            while (true) {
                switch (current.type) {
                    case utils_1.AST_NODE_TYPES.ImportDeclaration:
                        return true;
                    case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                    case utils_1.AST_NODE_TYPES.ExportAllDeclaration:
                    case utils_1.AST_NODE_TYPES.ExportNamedDeclaration:
                    case utils_1.AST_NODE_TYPES.BlockStatement:
                    case utils_1.AST_NODE_TYPES.ClassDeclaration:
                    case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:
                    case utils_1.AST_NODE_TYPES.FunctionDeclaration:
                    case utils_1.AST_NODE_TYPES.FunctionExpression:
                    case utils_1.AST_NODE_TYPES.Program:
                    case utils_1.AST_NODE_TYPES.TSUnionType:
                    case utils_1.AST_NODE_TYPES.VariableDeclarator:
                        return false;
                    default:
                        current = current.parent;
                }
            }
        }
        function getJsDocDeprecation(symbol) {
            let jsDocTags;
            try {
                jsDocTags = symbol?.getJsDocTags(checker);
            }
            catch {
                // workaround for https://github.com/microsoft/TypeScript/issues/60024
                return;
            }
            const tag = jsDocTags?.find(tag => tag.name === 'deprecated');
            if (!tag) {
                return undefined;
            }
            const displayParts = tag.text;
            return displayParts ? ts.displayPartsToString(displayParts) : '';
        }
        function isNodeCalleeOfParent(node) {
            switch (node.parent?.type) {
                case utils_1.AST_NODE_TYPES.NewExpression:
                case utils_1.AST_NODE_TYPES.CallExpression:
                    return node.parent.callee === node;
                case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:
                    return node.parent.tag === node;
                case utils_1.AST_NODE_TYPES.JSXOpeningElement:
                    return node.parent.name === node;
                default:
                    return false;
            }
        }
        function getCallLikeNode(node) {
            let callee = node;
            while (callee.parent?.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                callee.parent.property === callee) {
                callee = callee.parent;
            }
            return isNodeCalleeOfParent(callee) ? callee : undefined;
        }
        function getCallLikeDeprecation(node) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(node.parent);
            // If the node is a direct function call, we look for its signature.
            const signature = (0, util_1.nullThrows)(checker.getResolvedSignature(tsNode), 'Expected call like node to have signature');
            const symbol = services.getSymbolAtLocation(node);
            const aliasedSymbol = symbol != null && tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)
                ? checker.getAliasedSymbol(symbol)
                : symbol;
            const symbolDeclarationKind = aliasedSymbol?.declarations?.[0].kind;
            // Properties with function-like types have "deprecated" jsdoc
            // on their symbols, not on their signatures:
            //
            // interface Props {
            //   /** @deprecated */
            //   property: () => 'foo'
            //   ^symbol^  ^signature^
            // }
            if (symbolDeclarationKind !== ts.SyntaxKind.MethodDeclaration &&
                symbolDeclarationKind !== ts.SyntaxKind.FunctionDeclaration &&
                symbolDeclarationKind !== ts.SyntaxKind.MethodSignature) {
                return (searchForDeprecationInAliasesChain(symbol, true) ??
                    getJsDocDeprecation(signature) ??
                    getJsDocDeprecation(aliasedSymbol));
            }
            return (searchForDeprecationInAliasesChain(symbol, 
            // Here we're working with a function declaration or method.
            // Both can have 1 or more overloads, each overload creates one
            // ts.Declaration which is placed in symbol.declarations.
            //
            // Imagine the following code:
            //
            // function foo(): void
            // /** @deprecated Some Reason */
            // function foo(arg: string): void
            // function foo(arg?: string): void {}
            //
            // foo()    // <- foo is our symbol
            //
            // If we call getJsDocDeprecation(checker.getAliasedSymbol(symbol)),
            // we get 'Some Reason', but after all, we are calling foo with
            // a signature that is not deprecated!
            // It works this way because symbol.getJsDocTags returns tags from
            // all symbol declarations combined into one array. And AFAIK there is
            // no publicly exported TS function that can tell us if a particular
            // declaration is deprecated or not.
            //
            // So, in case of function and method declarations, we don't check original
            // aliased symbol, but rely on the getJsDocDeprecation(signature) call below.
            false) ?? getJsDocDeprecation(signature));
        }
        function getJSXAttributeDeprecation(openingElement, propertyName) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(openingElement.name);
            const contextualType = (0, util_1.nullThrows)(checker.getContextualType(tsNode), 'Expected JSX opening element name to have contextualType');
            const symbol = contextualType.getProperty(propertyName);
            return getJsDocDeprecation(symbol);
        }
        function getDeprecationReason(node) {
            const callLikeNode = getCallLikeNode(node);
            if (callLikeNode) {
                return getCallLikeDeprecation(callLikeNode);
            }
            if (node.parent.type === utils_1.AST_NODE_TYPES.JSXAttribute &&
                node.type !== utils_1.AST_NODE_TYPES.Super) {
                return getJSXAttributeDeprecation(node.parent.parent, node.name);
            }
            if (node.parent.type === utils_1.AST_NODE_TYPES.Property &&
                node.type !== utils_1.AST_NODE_TYPES.Super) {
                const property = services
                    .getTypeAtLocation(node.parent.parent)
                    .getProperty(node.name);
                const propertySymbol = services.getSymbolAtLocation(node);
                const valueSymbol = checker.getShorthandAssignmentValueSymbol(propertySymbol?.valueDeclaration);
                return (searchForDeprecationInAliasesChain(propertySymbol, true) ??
                    getJsDocDeprecation(property) ??
                    getJsDocDeprecation(propertySymbol) ??
                    getJsDocDeprecation(valueSymbol));
            }
            return searchForDeprecationInAliasesChain(services.getSymbolAtLocation(node), true);
        }
        function checkIdentifier(node) {
            if (isDeclaration(node) || isInsideImport(node)) {
                return;
            }
            const reason = getDeprecationReason(node);
            if (reason == null) {
                return;
            }
            const type = services.getTypeAtLocation(node);
            if ((0, util_1.typeMatchesSomeSpecifier)(type, allow, services.program) ||
                (0, util_1.valueMatchesSomeSpecifier)(node, allow, services.program, type)) {
                return;
            }
            const name = getReportedNodeName(node);
            context.report({
                ...(reason
                    ? {
                        messageId: 'deprecatedWithReason',
                        data: { name, reason },
                    }
                    : {
                        messageId: 'deprecated',
                        data: { name },
                    }),
                node,
            });
        }
        function checkMemberExpression(node) {
            if (!node.computed) {
                return;
            }
            const propertyType = services.getTypeAtLocation(node.property);
            if (propertyType.isLiteral()) {
                const objectType = services.getTypeAtLocation(node.object);
                const propertyName = propertyType.isStringLiteral()
                    ? propertyType.value
                    : String(propertyType.value);
                const property = objectType.getProperty(propertyName);
                const reason = getJsDocDeprecation(property);
                if (reason == null) {
                    return;
                }
                if ((0, util_1.typeMatchesSomeSpecifier)(objectType, allow, services.program)) {
                    return;
                }
                context.report({
                    ...(reason
                        ? {
                            messageId: 'deprecatedWithReason',
                            data: { name: propertyName, reason },
                        }
                        : {
                            messageId: 'deprecated',
                            data: { name: propertyName },
                        }),
                    node: node.property,
                });
            }
        }
        return {
            Identifier(node) {
                const { parent } = node;
                if (parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration ||
                    parent.type === utils_1.AST_NODE_TYPES.ExportAllDeclaration) {
                    return;
                }
                // Computed identifier expressions are handled by checkMemberExpression
                if (parent.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                    parent.computed &&
                    parent.property === node) {
                    return;
                }
                if (parent.type === utils_1.AST_NODE_TYPES.ExportSpecifier) {
                    // only deal with the alias (exported) side, not the local binding
                    if (parent.exported !== node) {
                        return;
                    }
                    const symbol = services.getSymbolAtLocation(node);
                    const aliasDeprecation = getJsDocDeprecation(symbol);
                    if (aliasDeprecation != null) {
                        return;
                    }
                }
                // whether it's a plain identifier or the exported alias
                checkIdentifier(node);
            },
            JSXIdentifier(node) {
                if (node.parent.type !== utils_1.AST_NODE_TYPES.JSXClosingElement) {
                    checkIdentifier(node);
                }
            },
            MemberExpression: checkMemberExpression,
            PrivateIdentifier: checkIdentifier,
            Super: checkIdentifier,
        };
    },
});
function getReportedNodeName(node) {
    if (node.type === utils_1.AST_NODE_TYPES.Super) {
        return 'super';
    }
    if (node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
        return `#${node.name}`;
    }
    return node.name;
}


--------------------------------------------------------------------------------
FILE: no-dupe-class-members.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpected", [], unknown, {
    'ClassBody:exit'(): void;
    'MethodDefinition, PropertyDefinition'(node: TSESTree.MethodDefinition | TSESTree.PropertyDefinition): void;
    ClassBody(): void;
    Program(): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpected", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-dupe-class-members.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-dupe-class-members');
exports.default = (0, util_1.createRule)({
    name: 'no-dupe-class-members',
    meta: {
        type: 'problem',
        // defaultOptions, -- base rule does not use defaultOptions
        docs: {
            description: 'Disallow duplicate class members',
            extendsBaseRule: true,
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: baseRule.meta.schema,
    },
    defaultOptions: [],
    create(context) {
        const rules = baseRule.create(context);
        function wrapMemberDefinitionListener(coreListener) {
            return (node) => {
                if (node.computed) {
                    return;
                }
                if (node.value?.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {
                    return;
                }
                return coreListener(node);
            };
        }
        return {
            ...rules,
            'MethodDefinition, PropertyDefinition': wrapMemberDefinitionListener(rules['MethodDefinition, PropertyDefinition']),
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-duplicate-enum-values.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"duplicateValue", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-duplicate-enum-values.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-duplicate-enum-values',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow duplicate enum member values',
            recommended: 'recommended',
        },
        hasSuggestions: false,
        messages: {
            duplicateValue: 'Duplicate enum member value {{value}}.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function isStringLiteral(node) {
            return (node.type === utils_1.AST_NODE_TYPES.Literal && typeof node.value === 'string');
        }
        function isNumberLiteral(node) {
            return (node.type === utils_1.AST_NODE_TYPES.Literal && typeof node.value === 'number');
        }
        function isSupportedUnary(node) {
            return (node.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                ['-', '+'].includes(node.operator));
        }
        function isStaticTemplateLiteral(node) {
            return (node.type === utils_1.AST_NODE_TYPES.TemplateLiteral &&
                node.expressions.length === 0 &&
                node.quasis.length === 1);
        }
        function getMemberValue(initializer) {
            switch (true) {
                case isStringLiteral(initializer):
                case isNumberLiteral(initializer):
                    return initializer.value;
                case isSupportedUnary(initializer): {
                    const inner = Number(getMemberValue(initializer.argument));
                    if (Number.isNaN(inner)) {
                        return undefined;
                    }
                    return initializer.operator === '-' ? -inner : inner;
                }
                case isStaticTemplateLiteral(initializer):
                    return initializer.quasis[0].value.cooked;
                default:
                    return undefined;
            }
        }
        return {
            TSEnumDeclaration(node) {
                const enumMembers = node.body.members;
                const seenValues = [];
                enumMembers.forEach(member => {
                    if (member.initializer == null) {
                        return;
                    }
                    const value = getMemberValue(member.initializer);
                    if (value == null) {
                        return;
                    }
                    const isAlreadyPresent = seenValues.some(seenValue => Object.is(seenValue, value));
                    if (isAlreadyPresent) {
                        context.report({
                            node: member,
                            messageId: 'duplicateValue',
                            data: {
                                value,
                            },
                        });
                    }
                    else {
                        seenValues.push(value);
                    }
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-duplicate-type-constituents.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        ignoreIntersections?: boolean;
        ignoreUnions?: boolean;
    }
];
export type MessageIds = 'duplicate' | 'unnecessary';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-duplicate-type-constituents.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const astIgnoreKeys = new Set(['loc', 'parent', 'range']);
const isSameAstNode = (actualNode, expectedNode) => {
    if (actualNode === expectedNode) {
        return true;
    }
    if (actualNode &&
        expectedNode &&
        typeof actualNode === 'object' &&
        typeof expectedNode === 'object') {
        if (Array.isArray(actualNode) && Array.isArray(expectedNode)) {
            if (actualNode.length !== expectedNode.length) {
                return false;
            }
            return !actualNode.some((nodeEle, index) => !isSameAstNode(nodeEle, expectedNode[index]));
        }
        const actualNodeKeys = Object.keys(actualNode).filter(key => !astIgnoreKeys.has(key));
        const expectedNodeKeys = Object.keys(expectedNode).filter(key => !astIgnoreKeys.has(key));
        if (actualNodeKeys.length !== expectedNodeKeys.length) {
            return false;
        }
        if (actualNodeKeys.some(actualNodeKey => !Object.hasOwn(expectedNode, actualNodeKey))) {
            return false;
        }
        if (actualNodeKeys.some(actualNodeKey => !isSameAstNode(actualNode[actualNodeKey], expectedNode[actualNodeKey]))) {
            return false;
        }
        return true;
    }
    return false;
};
exports.default = (0, util_1.createRule)({
    name: 'no-duplicate-type-constituents',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow duplicate constituents of union or intersection types',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            duplicate: '{{type}} type constituent is duplicated with {{previous}}.',
            unnecessary: 'Explicit undefined is unnecessary on an optional parameter.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ignoreIntersections: {
                        type: 'boolean',
                        description: 'Whether to ignore `&` intersections.',
                    },
                    ignoreUnions: {
                        type: 'boolean',
                        description: 'Whether to ignore `|` unions.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            ignoreIntersections: false,
            ignoreUnions: false,
        },
    ],
    create(context, [{ ignoreIntersections, ignoreUnions }]) {
        const parserServices = (0, util_1.getParserServices)(context);
        const { sourceCode } = context;
        function report(messageId, constituentNode, data) {
            const getUnionOrIntersectionToken = (where, at) => sourceCode[`getTokens${where}`](constituentNode, {
                filter: token => ['&', '|'].includes(token.value) &&
                    constituentNode.parent.range[0] <= token.range[0] &&
                    token.range[1] <= constituentNode.parent.range[1],
            }).at(at);
            const beforeUnionOrIntersectionToken = getUnionOrIntersectionToken('Before', -1);
            let afterUnionOrIntersectionToken;
            let bracketBeforeTokens;
            let bracketAfterTokens;
            if (beforeUnionOrIntersectionToken) {
                bracketBeforeTokens = sourceCode.getTokensBetween(beforeUnionOrIntersectionToken, constituentNode);
                bracketAfterTokens = sourceCode.getTokensAfter(constituentNode, {
                    count: bracketBeforeTokens.length,
                });
            }
            else {
                afterUnionOrIntersectionToken = (0, util_1.nullThrows)(getUnionOrIntersectionToken('After', 0), util_1.NullThrowsReasons.MissingToken('union or intersection token', 'duplicate type constituent'));
                bracketAfterTokens = sourceCode.getTokensBetween(constituentNode, afterUnionOrIntersectionToken);
                bracketBeforeTokens = sourceCode.getTokensBefore(constituentNode, {
                    count: bracketAfterTokens.length,
                });
            }
            context.report({
                loc: {
                    start: constituentNode.loc.start,
                    end: (bracketAfterTokens.at(-1) ?? constituentNode).loc.end,
                },
                node: constituentNode,
                messageId,
                data,
                fix: fixer => [
                    beforeUnionOrIntersectionToken,
                    ...bracketBeforeTokens,
                    constituentNode,
                    ...bracketAfterTokens,
                    afterUnionOrIntersectionToken,
                ].flatMap(token => (token ? fixer.remove(token) : [])),
            });
        }
        function checkDuplicateRecursively(unionOrIntersection, constituentNode, uniqueConstituents, cachedTypeMap, forEachNodeType) {
            const type = parserServices.getTypeAtLocation(constituentNode);
            if (tsutils.isIntrinsicErrorType(type)) {
                return;
            }
            const duplicatedPrevious = uniqueConstituents.find(ele => isSameAstNode(ele, constituentNode)) ??
                cachedTypeMap.get(type);
            if (duplicatedPrevious) {
                report('duplicate', constituentNode, {
                    type: unionOrIntersection,
                    previous: sourceCode.getText(duplicatedPrevious),
                });
                return;
            }
            forEachNodeType?.(type, constituentNode);
            cachedTypeMap.set(type, constituentNode);
            uniqueConstituents.push(constituentNode);
            if ((unionOrIntersection === 'Union' &&
                constituentNode.type === utils_1.AST_NODE_TYPES.TSUnionType) ||
                (unionOrIntersection === 'Intersection' &&
                    constituentNode.type === utils_1.AST_NODE_TYPES.TSIntersectionType)) {
                for (const constituent of constituentNode.types) {
                    checkDuplicateRecursively(unionOrIntersection, constituent, uniqueConstituents, cachedTypeMap, forEachNodeType);
                }
            }
        }
        function checkDuplicate(node, forEachNodeType) {
            const cachedTypeMap = new Map();
            const uniqueConstituents = [];
            const unionOrIntersection = node.type === utils_1.AST_NODE_TYPES.TSIntersectionType
                ? 'Intersection'
                : 'Union';
            for (const type of node.types) {
                checkDuplicateRecursively(unionOrIntersection, type, uniqueConstituents, cachedTypeMap, forEachNodeType);
            }
        }
        return {
            ...(!ignoreIntersections && {
                TSIntersectionType(node) {
                    if (node.parent.type === utils_1.AST_NODE_TYPES.TSIntersectionType) {
                        return;
                    }
                    checkDuplicate(node);
                },
            }),
            ...(!ignoreUnions && {
                TSUnionType: (node) => {
                    if (node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType) {
                        return;
                    }
                    checkDuplicate(node, (constituentNodeType, constituentNode) => {
                        const maybeTypeAnnotation = node.parent;
                        if (maybeTypeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeAnnotation) {
                            const maybeIdentifier = maybeTypeAnnotation.parent;
                            if (maybeIdentifier.type === utils_1.AST_NODE_TYPES.Identifier &&
                                maybeIdentifier.optional) {
                                const maybeFunction = maybeIdentifier.parent;
                                if ((0, util_1.isFunctionOrFunctionType)(maybeFunction) &&
                                    maybeFunction.params.includes(maybeIdentifier) &&
                                    tsutils.isTypeFlagSet(constituentNodeType, ts.TypeFlags.Undefined)) {
                                    report('unnecessary', constituentNode);
                                }
                            }
                        }
                    });
                },
            }),
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-dynamic-delete.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"dynamicDelete", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-dynamic-delete.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-dynamic-delete',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow using the `delete` operator on computed key expressions',
            recommended: 'strict',
        },
        messages: {
            dynamicDelete: 'Do not delete dynamically computed property keys.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            'UnaryExpression[operator=delete]'(node) {
                if (node.argument.type !== utils_1.AST_NODE_TYPES.MemberExpression ||
                    !node.argument.computed ||
                    isAcceptableIndexExpression(node.argument.property)) {
                    return;
                }
                context.report({
                    node: node.argument.property,
                    messageId: 'dynamicDelete',
                });
            },
        };
    },
});
function isAcceptableIndexExpression(property) {
    return ((property.type === utils_1.AST_NODE_TYPES.Literal &&
        ['number', 'string'].includes(typeof property.value)) ||
        (property.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
            property.operator === '-' &&
            property.argument.type === utils_1.AST_NODE_TYPES.Literal &&
            typeof property.argument.value === 'number'));
}


--------------------------------------------------------------------------------
FILE: no-empty-function.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpected" | "suggestComment", [{
    allow?: string[];
}], unknown, {
    FunctionDeclaration(node: TSESTree.FunctionDeclaration): void;
    FunctionExpression(node: TSESTree.FunctionExpression): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpected" | "suggestComment", [{
    allow?: string[];
}], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-empty-function.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-empty-function');
const defaultOptions = [
    {
        allow: [],
    },
];
const schema = (0, util_1.deepMerge)(
// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- https://github.com/microsoft/TypeScript/issues/17002
Array.isArray(baseRule.meta.schema)
    ? baseRule.meta.schema[0]
    : baseRule.meta.schema, {
    properties: {
        allow: {
            description: 'Locations and kinds of functions that are allowed to be empty.',
            items: {
                type: 'string',
                enum: [
                    'functions',
                    'arrowFunctions',
                    'generatorFunctions',
                    'methods',
                    'generatorMethods',
                    'getters',
                    'setters',
                    'constructors',
                    'private-constructors',
                    'protected-constructors',
                    'asyncFunctions',
                    'asyncMethods',
                    'decoratedFunctions',
                    'overrideMethods',
                ],
            },
        },
    },
});
exports.default = (0, util_1.createRule)({
    name: 'no-empty-function',
    meta: {
        type: 'suggestion',
        defaultOptions,
        docs: {
            description: 'Disallow empty functions',
            extendsBaseRule: true,
            recommended: 'stylistic',
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: [schema],
    },
    defaultOptions,
    create(context, [{ allow = [] }]) {
        const rules = baseRule.create(context);
        const isAllowedProtectedConstructors = allow.includes('protected-constructors');
        const isAllowedPrivateConstructors = allow.includes('private-constructors');
        const isAllowedDecoratedFunctions = allow.includes('decoratedFunctions');
        const isAllowedOverrideMethods = allow.includes('overrideMethods');
        /**
         * Check if the method body is empty
         * @param node the node to be validated
         * @returns true if the body is empty
         * @private
         */
        function isBodyEmpty(node) {
            return node.body.body.length === 0;
        }
        /**
         * Check if method has parameter properties
         * @param node the node to be validated
         * @returns true if the body has parameter properties
         * @private
         */
        function hasParameterProperties(node) {
            return node.params.some(param => param.type === utils_1.AST_NODE_TYPES.TSParameterProperty);
        }
        /**
         * @param node the node to be validated
         * @returns true if the constructor is allowed to be empty
         * @private
         */
        function isAllowedEmptyConstructor(node) {
            const parent = node.parent;
            if (isBodyEmpty(node) &&
                parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                parent.kind === 'constructor') {
                const { accessibility } = parent;
                return (
                // allow protected constructors
                (accessibility === 'protected' && isAllowedProtectedConstructors) ||
                    // allow private constructors
                    (accessibility === 'private' && isAllowedPrivateConstructors) ||
                    // allow constructors which have parameter properties
                    hasParameterProperties(node));
            }
            return false;
        }
        /**
         * @param node the node to be validated
         * @returns true if a function has decorators
         * @private
         */
        function isAllowedEmptyDecoratedFunctions(node) {
            if (isAllowedDecoratedFunctions && isBodyEmpty(node)) {
                const decorators = node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition
                    ? node.parent.decorators
                    : undefined;
                return !!decorators && !!decorators.length;
            }
            return false;
        }
        function isAllowedEmptyOverrideMethod(node) {
            return (isAllowedOverrideMethods &&
                isBodyEmpty(node) &&
                node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                node.parent.override);
        }
        return {
            ...rules,
            FunctionExpression(node) {
                if (isAllowedEmptyConstructor(node) ||
                    isAllowedEmptyDecoratedFunctions(node) ||
                    isAllowedEmptyOverrideMethod(node)) {
                    return;
                }
                rules.FunctionExpression(node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-empty-interface.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        allowSingleExtends?: boolean;
    }
];
export type MessageIds = 'noEmpty' | 'noEmptyWithSuper';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-empty-interface.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-empty-interface',
    meta: {
        type: 'suggestion',
        deprecated: {
            deprecatedSince: '8.0.0',
            replacedBy: [
                {
                    rule: {
                        name: '@typescript-eslint/no-empty-object-type',
                        url: 'https://typescript-eslint.io/rules/no-empty-object-type',
                    },
                },
            ],
            url: 'https://github.com/typescript-eslint/typescript-eslint/pull/8977',
        },
        docs: {
            description: 'Disallow the declaration of empty interfaces',
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            noEmpty: 'An empty interface is equivalent to `{}`.',
            noEmptyWithSuper: 'An interface declaring no members is equivalent to its supertype.',
        },
        replacedBy: ['@typescript-eslint/no-empty-object-type'],
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowSingleExtends: {
                        type: 'boolean',
                        description: 'Whether to allow empty interfaces that extend a single other interface.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowSingleExtends: false,
        },
    ],
    create(context, [{ allowSingleExtends }]) {
        return {
            TSInterfaceDeclaration(node) {
                if (node.body.body.length !== 0) {
                    // interface contains members --> Nothing to report
                    return;
                }
                const extend = node.extends;
                if (extend.length === 0) {
                    context.report({
                        node: node.id,
                        messageId: 'noEmpty',
                    });
                }
                else if (extend.length === 1 &&
                    // interface extends exactly 1 interface --> Report depending on rule setting
                    !allowSingleExtends) {
                    const fix = (fixer) => {
                        let typeParam = '';
                        if (node.typeParameters) {
                            typeParam = context.sourceCode.getText(node.typeParameters);
                        }
                        return fixer.replaceText(node, `type ${context.sourceCode.getText(node.id)}${typeParam} = ${context.sourceCode.getText(extend[0])}`);
                    };
                    const scope = context.sourceCode.getScope(node);
                    const mergedWithClassDeclaration = scope.set
                        .get(node.id.name)
                        ?.defs.some(def => def.node.type === utils_1.AST_NODE_TYPES.ClassDeclaration);
                    const isInAmbientDeclaration = (0, util_1.isDefinitionFile)(context.filename) &&
                        scope.type === scope_manager_1.ScopeType.tsModule &&
                        scope.block.declare;
                    const useAutoFix = !(isInAmbientDeclaration || mergedWithClassDeclaration);
                    context.report({
                        node: node.id,
                        messageId: 'noEmptyWithSuper',
                        ...(useAutoFix
                            ? { fix }
                            : !mergedWithClassDeclaration
                                ? {
                                    suggest: [
                                        {
                                            messageId: 'noEmptyWithSuper',
                                            fix,
                                        },
                                    ],
                                }
                                : null),
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-empty-object-type.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type AllowInterfaces = 'always' | 'never' | 'with-single-extends';
export type AllowObjectTypes = 'always' | 'never';
export type Options = [
    {
        allowInterfaces?: AllowInterfaces;
        allowObjectTypes?: AllowObjectTypes;
        allowWithName?: string;
    }
];
export type MessageIds = 'noEmptyInterface' | 'noEmptyInterfaceWithSuper' | 'noEmptyObject' | 'replaceEmptyInterface' | 'replaceEmptyInterfaceWithSuper' | 'replaceEmptyObjectType';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-empty-object-type.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const noEmptyMessage = (emptyType) => [
    `${emptyType} allows any non-nullish value, including literals like \`0\` and \`""\`.`,
    "- If that's what you want, disable this lint rule with an inline comment or configure the '{{ option }}' rule option.",
    '- If you want a type meaning "any object", you probably want `object` instead.',
    '- If you want a type meaning "any value", you probably want `unknown` instead.',
].join('\n');
exports.default = (0, util_1.createRule)({
    name: 'no-empty-object-type',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow accidentally using the "empty object" type',
            recommended: 'recommended',
        },
        hasSuggestions: true,
        messages: {
            noEmptyInterface: noEmptyMessage('An empty interface declaration'),
            noEmptyInterfaceWithSuper: 'An interface declaring no members is equivalent to its supertype.',
            noEmptyObject: noEmptyMessage('The `{}` ("empty object") type'),
            replaceEmptyInterface: 'Replace empty interface with `{{replacement}}`.',
            replaceEmptyInterfaceWithSuper: 'Replace empty interface with a type alias.',
            replaceEmptyObjectType: 'Replace `{}` with `{{replacement}}`.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowInterfaces: {
                        type: 'string',
                        description: 'Whether to allow empty interfaces.',
                        enum: ['always', 'never', 'with-single-extends'],
                    },
                    allowObjectTypes: {
                        type: 'string',
                        description: 'Whether to allow empty object type literals.',
                        enum: ['always', 'never'],
                    },
                    allowWithName: {
                        type: 'string',
                        description: 'A stringified regular expression to allow interfaces and object type aliases with the configured name.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowInterfaces: 'never',
            allowObjectTypes: 'never',
        },
    ],
    create(context, [{ allowInterfaces, allowObjectTypes, allowWithName }]) {
        const allowWithNameTester = allowWithName
            ? new RegExp(allowWithName, 'u')
            : undefined;
        return {
            ...(allowInterfaces !== 'always' && {
                TSInterfaceDeclaration(node) {
                    if (allowWithNameTester?.test(node.id.name)) {
                        return;
                    }
                    const extend = node.extends;
                    if (node.body.body.length !== 0 ||
                        (extend.length === 1 &&
                            allowInterfaces === 'with-single-extends') ||
                        extend.length > 1) {
                        return;
                    }
                    const scope = context.sourceCode.getScope(node);
                    const mergedWithClassDeclaration = scope.set
                        .get(node.id.name)
                        ?.defs.some(def => def.node.type === utils_1.AST_NODE_TYPES.ClassDeclaration);
                    if (extend.length === 0) {
                        context.report({
                            node: node.id,
                            messageId: 'noEmptyInterface',
                            data: { option: 'allowInterfaces' },
                            ...(!mergedWithClassDeclaration && {
                                suggest: ['object', 'unknown'].map(replacement => ({
                                    messageId: 'replaceEmptyInterface',
                                    data: { replacement },
                                    fix(fixer) {
                                        const id = context.sourceCode.getText(node.id);
                                        const typeParam = node.typeParameters
                                            ? context.sourceCode.getText(node.typeParameters)
                                            : '';
                                        return fixer.replaceText(node, `type ${id}${typeParam} = ${replacement}`);
                                    },
                                })),
                            }),
                        });
                        return;
                    }
                    context.report({
                        node: node.id,
                        messageId: 'noEmptyInterfaceWithSuper',
                        ...(!mergedWithClassDeclaration && {
                            suggest: [
                                {
                                    messageId: 'replaceEmptyInterfaceWithSuper',
                                    fix(fixer) {
                                        const extended = context.sourceCode.getText(extend[0]);
                                        const id = context.sourceCode.getText(node.id);
                                        const typeParam = node.typeParameters
                                            ? context.sourceCode.getText(node.typeParameters)
                                            : '';
                                        return fixer.replaceText(node, `type ${id}${typeParam} = ${extended}`);
                                    },
                                },
                            ],
                        }),
                    });
                },
            }),
            ...(allowObjectTypes !== 'always' && {
                TSTypeLiteral(node) {
                    if (node.members.length ||
                        node.parent.type === utils_1.AST_NODE_TYPES.TSIntersectionType ||
                        (allowWithNameTester &&
                            node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration &&
                            allowWithNameTester.test(node.parent.id.name))) {
                        return;
                    }
                    context.report({
                        node,
                        messageId: 'noEmptyObject',
                        data: { option: 'allowObjectTypes' },
                        suggest: ['object', 'unknown'].map(replacement => ({
                            messageId: 'replaceEmptyObjectType',
                            data: { replacement },
                            fix: (fixer) => fixer.replaceText(node, replacement),
                        })),
                    });
                },
            }),
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-explicit-any.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        fixToUnknown?: boolean;
        ignoreRestArgs?: boolean;
    }
];
export type MessageIds = 'suggestNever' | 'suggestPropertyKey' | 'suggestUnknown' | 'unexpectedAny';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-explicit-any.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-explicit-any',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow the `any` type',
            recommended: 'recommended',
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            suggestNever: "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",
            suggestPropertyKey: 'Use `PropertyKey` instead, this is more explicit than `keyof any`.',
            suggestUnknown: 'Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.',
            unexpectedAny: 'Unexpected any. Specify a different type.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    fixToUnknown: {
                        type: 'boolean',
                        description: 'Whether to enable auto-fixing in which the `any` type is converted to the `unknown` type.',
                    },
                    ignoreRestArgs: {
                        type: 'boolean',
                        description: 'Whether to ignore rest parameter arrays.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            fixToUnknown: false,
            ignoreRestArgs: false,
        },
    ],
    create(context, [{ fixToUnknown, ignoreRestArgs }]) {
        /**
         * Checks if the node is an arrow function, function/constructor declaration or function expression
         * @param node the node to be validated.
         * @returns true if the node is any kind of function declaration or expression
         * @private
         */
        function isNodeValidFunction(node) {
            return [
                utils_1.AST_NODE_TYPES.ArrowFunctionExpression, // const x = (...args: any[]) => {};
                utils_1.AST_NODE_TYPES.FunctionDeclaration, // function f(...args: any[]) {}
                utils_1.AST_NODE_TYPES.FunctionExpression, // const x = function(...args: any[]) {};
                utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration, // type T = {(...args: any[]): unknown};
                utils_1.AST_NODE_TYPES.TSConstructorType, // type T = new (...args: any[]) => unknown
                utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration, // type T = {new (...args: any[]): unknown};
                utils_1.AST_NODE_TYPES.TSDeclareFunction, // declare function _8(...args: any[]): unknown;
                utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression, // declare class A { f(...args: any[]): unknown; }
                utils_1.AST_NODE_TYPES.TSFunctionType, // type T = (...args: any[]) => unknown;
                utils_1.AST_NODE_TYPES.TSMethodSignature, // type T = {f(...args: any[]): unknown};
            ].includes(node.type);
        }
        /**
         * Checks if the node is a rest element child node of a function
         * @param node the node to be validated.
         * @returns true if the node is a rest element child node of a function
         * @private
         */
        function isNodeRestElementInFunction(node) {
            return (node.type === utils_1.AST_NODE_TYPES.RestElement &&
                isNodeValidFunction(node.parent));
        }
        /**
         * Checks if the node is a TSTypeOperator node with a readonly operator
         * @param node the node to be validated.
         * @returns true if the node is a TSTypeOperator node with a readonly operator
         * @private
         */
        function isNodeReadonlyTSTypeOperator(node) {
            return (node.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&
                node.operator === 'readonly');
        }
        /**
         * Checks if the node is a TSTypeReference node with an Array identifier
         * @param node the node to be validated.
         * @returns true if the node is a TSTypeReference node with an Array identifier
         * @private
         */
        function isNodeValidArrayTSTypeReference(node) {
            return (node.type === utils_1.AST_NODE_TYPES.TSTypeReference &&
                node.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
                ['Array', 'ReadonlyArray'].includes(node.typeName.name));
        }
        /**
         * Checks if the node is a valid TSTypeOperator or TSTypeReference node
         * @param node the node to be validated.
         * @returns true if the node is a valid TSTypeOperator or TSTypeReference node
         * @private
         */
        function isNodeValidTSType(node) {
            return (isNodeReadonlyTSTypeOperator(node) ||
                isNodeValidArrayTSTypeReference(node));
        }
        /**
         * Checks if the great grand-parent node is a RestElement node in a function
         * @param node the node to be validated.
         * @returns true if the great grand-parent node is a RestElement node in a function
         * @private
         */
        function isGreatGrandparentRestElement(node) {
            return (node.parent?.parent?.parent != null &&
                isNodeRestElementInFunction(node.parent.parent.parent));
        }
        /**
         * Checks if the great great grand-parent node is a valid RestElement node in a function
         * @param node the node to be validated.
         * @returns true if the great great grand-parent node is a valid RestElement node in a function
         * @private
         */
        function isGreatGreatGrandparentRestElement(node) {
            return (node.parent?.parent?.parent?.parent != null &&
                isNodeValidTSType(node.parent.parent) &&
                isNodeRestElementInFunction(node.parent.parent.parent.parent));
        }
        /**
         * Checks if the great grand-parent or the great great grand-parent node is a RestElement node
         * @param node the node to be validated.
         * @returns true if the great grand-parent or the great great grand-parent node is a RestElement node
         * @private
         */
        function isNodeDescendantOfRestElementInFunction(node) {
            return (isGreatGrandparentRestElement(node) ||
                isGreatGreatGrandparentRestElement(node));
        }
        /**
         * Checks if the node is within a keyof any expression
         * @param node the node to be validated.
         * @returns true if the node is within a keyof any expression, false otherwise
         * @private
         */
        function isNodeWithinKeyofAny(node) {
            return (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&
                node.parent.operator === 'keyof');
        }
        /**
         * Creates a fixer that replaces a keyof any with PropertyKey
         * @param node the node to be fixed.
         * @returns a function that will fix the node.
         * @private
         */
        function createPropertyKeyFixer(node) {
            return (fixer) => {
                return fixer.replaceText(node.parent, 'PropertyKey');
            };
        }
        return {
            TSAnyKeyword(node) {
                const isKeyofAny = isNodeWithinKeyofAny(node);
                if (ignoreRestArgs && isNodeDescendantOfRestElementInFunction(node)) {
                    return;
                }
                const fixOrSuggest = {
                    fix: null,
                    suggest: isKeyofAny
                        ? [
                            {
                                messageId: 'suggestPropertyKey',
                                fix: createPropertyKeyFixer(node),
                            },
                        ]
                        : [
                            {
                                messageId: 'suggestUnknown',
                                fix: fixer => fixer.replaceText(node, 'unknown'),
                            },
                            {
                                messageId: 'suggestNever',
                                fix: fixer => fixer.replaceText(node, 'never'),
                            },
                        ],
                };
                if (fixToUnknown) {
                    fixOrSuggest.fix = isKeyofAny
                        ? createPropertyKeyFixer(node)
                        : fixer => fixer.replaceText(node, 'unknown');
                }
                context.report({
                    node,
                    messageId: 'unexpectedAny',
                    ...fixOrSuggest,
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-extra-non-null-assertion.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noExtraNonNullAssertion", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-extra-non-null-assertion.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-extra-non-null-assertion',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow extra non-null assertions',
            recommended: 'recommended',
        },
        fixable: 'code',
        messages: {
            noExtraNonNullAssertion: 'Forbidden extra non-null assertion.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function checkExtraNonNullAssertion(node) {
            context.report({
                node,
                messageId: 'noExtraNonNullAssertion',
                fix(fixer) {
                    return fixer.removeRange([node.range[1] - 1, node.range[1]]);
                },
            });
        }
        return {
            'CallExpression[optional = true] > TSNonNullExpression.callee': checkExtraNonNullAssertion,
            'MemberExpression[optional = true] > TSNonNullExpression.object': checkExtraNonNullAssertion,
            'TSNonNullExpression > TSNonNullExpression': checkExtraNonNullAssertion,
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-extraneous-class.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowConstructorOnly?: boolean;
        allowEmpty?: boolean;
        allowStaticOnly?: boolean;
        allowWithDecorator?: boolean;
    }
];
export type MessageIds = 'empty' | 'onlyConstructor' | 'onlyStatic';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-extraneous-class.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-extraneous-class',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow classes used as namespaces',
            recommended: 'strict',
        },
        messages: {
            empty: 'Unexpected empty class.',
            onlyConstructor: 'Unexpected class with only a constructor.',
            onlyStatic: 'Unexpected class with only static properties.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowConstructorOnly: {
                        type: 'boolean',
                        description: 'Whether to allow extraneous classes that contain only a constructor.',
                    },
                    allowEmpty: {
                        type: 'boolean',
                        description: 'Whether to allow extraneous classes that have no body (i.e. are empty).',
                    },
                    allowStaticOnly: {
                        type: 'boolean',
                        description: 'Whether to allow extraneous classes that only contain static members.',
                    },
                    allowWithDecorator: {
                        type: 'boolean',
                        description: 'Whether to allow extraneous classes that include a decorator.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowConstructorOnly: false,
            allowEmpty: false,
            allowStaticOnly: false,
            allowWithDecorator: false,
        },
    ],
    create(context, [{ allowConstructorOnly, allowEmpty, allowStaticOnly, allowWithDecorator }]) {
        const isAllowWithDecorator = (node) => {
            return !!(allowWithDecorator &&
                node?.decorators &&
                node.decorators.length !== 0);
        };
        return {
            ClassBody(node) {
                const parent = node.parent;
                if (parent.superClass || isAllowWithDecorator(parent)) {
                    return;
                }
                const reportNode = parent.type === utils_1.AST_NODE_TYPES.ClassDeclaration && parent.id
                    ? parent.id
                    : parent;
                if (node.body.length === 0) {
                    if (allowEmpty) {
                        return;
                    }
                    context.report({
                        node: reportNode,
                        messageId: 'empty',
                    });
                    return;
                }
                let onlyStatic = true;
                let onlyConstructor = true;
                for (const prop of node.body) {
                    if (prop.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                        prop.kind === 'constructor') {
                        if (prop.value.params.some(param => param.type === utils_1.AST_NODE_TYPES.TSParameterProperty)) {
                            onlyConstructor = false;
                            onlyStatic = false;
                        }
                    }
                    else {
                        onlyConstructor = false;
                        if (((prop.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||
                            prop.type === utils_1.AST_NODE_TYPES.MethodDefinition ||
                            prop.type === utils_1.AST_NODE_TYPES.AccessorProperty) &&
                            !prop.static) ||
                            prop.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||
                            prop.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition || // `static abstract` methods and properties are currently not supported. See: https://github.com/microsoft/TypeScript/issues/34516
                            prop.type === utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty) {
                            onlyStatic = false;
                        }
                    }
                    if (!(onlyStatic || onlyConstructor)) {
                        break;
                    }
                }
                if (onlyConstructor) {
                    if (!allowConstructorOnly) {
                        context.report({
                            node: reportNode,
                            messageId: 'onlyConstructor',
                        });
                    }
                    return;
                }
                if (onlyStatic && !allowStaticOnly) {
                    context.report({
                        node: reportNode,
                        messageId: 'onlyStatic',
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-floating-promises.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
import type { TypeOrValueSpecifier } from '../util';
export type Options = [
    {
        allowForKnownSafeCalls?: TypeOrValueSpecifier[];
        allowForKnownSafePromises?: TypeOrValueSpecifier[];
        checkThenables?: boolean;
        ignoreIIFE?: boolean;
        ignoreVoid?: boolean;
    }
];
export type MessageId = 'floating' | 'floatingFixAwait' | 'floatingFixVoid' | 'floatingPromiseArray' | 'floatingPromiseArrayVoid' | 'floatingUselessRejectionHandler' | 'floatingUselessRejectionHandlerVoid' | 'floatingVoid';
declare const _default: TSESLint.RuleModule<MessageId, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-floating-promises.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
const promiseUtils_1 = require("../util/promiseUtils");
const messageBase = 'Promises must be awaited, end with a call to .catch, or end with a call to .then with a rejection handler.';
const messageBaseVoid = 'Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler' +
    ' or be explicitly marked as ignored with the `void` operator.';
const messageRejectionHandler = 'A rejection handler that is not a function will be ignored.';
const messagePromiseArray = "An array of Promises may be unintentional. Consider handling the promises' fulfillment or rejection with Promise.all or similar.";
const messagePromiseArrayVoid = "An array of Promises may be unintentional. Consider handling the promises' fulfillment or rejection with Promise.all or similar," +
    ' or explicitly marking the expression as ignored with the `void` operator.';
exports.default = (0, util_1.createRule)({
    name: 'no-floating-promises',
    meta: {
        type: 'problem',
        docs: {
            description: 'Require Promise-like statements to be handled appropriately',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            floating: messageBase,
            floatingFixAwait: 'Add await operator.',
            floatingFixVoid: 'Add void operator to ignore.',
            floatingPromiseArray: messagePromiseArray,
            floatingPromiseArrayVoid: messagePromiseArrayVoid,
            floatingUselessRejectionHandler: `${messageBase} ${messageRejectionHandler}`,
            floatingUselessRejectionHandlerVoid: `${messageBaseVoid} ${messageRejectionHandler}`,
            floatingVoid: messageBaseVoid,
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowForKnownSafeCalls: {
                        ...util_1.readonlynessOptionsSchema.properties.allow,
                        description: 'Type specifiers of functions whose calls are safe to float.',
                    },
                    allowForKnownSafePromises: {
                        ...util_1.readonlynessOptionsSchema.properties.allow,
                        description: 'Type specifiers that are known to be safe to float.',
                    },
                    checkThenables: {
                        type: 'boolean',
                        description: 'Whether to check all "Thenable"s, not just the built-in Promise type.',
                    },
                    ignoreIIFE: {
                        type: 'boolean',
                        description: 'Whether to ignore async IIFEs (Immediately Invoked Function Expressions).',
                    },
                    ignoreVoid: {
                        type: 'boolean',
                        description: 'Whether to ignore `void` expressions.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowForKnownSafeCalls: util_1.readonlynessOptionsDefaults.allow,
            allowForKnownSafePromises: util_1.readonlynessOptionsDefaults.allow,
            checkThenables: false,
            ignoreIIFE: false,
            ignoreVoid: true,
        },
    ],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const { checkThenables } = options;
        // TODO: #5439
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        const allowForKnownSafePromises = options.allowForKnownSafePromises;
        const allowForKnownSafeCalls = options.allowForKnownSafeCalls;
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
        return {
            ExpressionStatement(node) {
                if (options.ignoreIIFE && isAsyncIife(node)) {
                    return;
                }
                const expression = (0, util_1.skipChainExpression)(node.expression);
                if (isKnownSafePromiseCall(expression)) {
                    return;
                }
                const { isUnhandled, nonFunctionHandler, promiseArray } = isUnhandledPromise(checker, expression);
                if (isUnhandled) {
                    if (promiseArray) {
                        context.report({
                            node,
                            messageId: options.ignoreVoid
                                ? 'floatingPromiseArrayVoid'
                                : 'floatingPromiseArray',
                        });
                    }
                    else if (options.ignoreVoid) {
                        context.report({
                            node,
                            messageId: nonFunctionHandler
                                ? 'floatingUselessRejectionHandlerVoid'
                                : 'floatingVoid',
                            suggest: [
                                {
                                    messageId: 'floatingFixVoid',
                                    fix(fixer) {
                                        if ((0, util_1.isParenthesized)(expression, context.sourceCode) ||
                                            (0, util_1.getOperatorPrecedenceForNode)(expression) >
                                                util_1.OperatorPrecedence.Unary) {
                                            return fixer.insertTextBefore(node, 'void ');
                                        }
                                        return [
                                            fixer.insertTextBefore(node, 'void ('),
                                            fixer.insertTextAfterRange([expression.range[1], expression.range[1]], ')'),
                                        ];
                                    },
                                },
                                {
                                    messageId: 'floatingFixAwait',
                                    fix: (fixer) => addAwait(fixer, expression, node),
                                },
                            ],
                        });
                    }
                    else {
                        context.report({
                            node,
                            messageId: nonFunctionHandler
                                ? 'floatingUselessRejectionHandler'
                                : 'floating',
                            suggest: [
                                {
                                    messageId: 'floatingFixAwait',
                                    fix: (fixer) => addAwait(fixer, expression, node),
                                },
                            ],
                        });
                    }
                }
            },
        };
        function addAwait(fixer, expression, node) {
            if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                expression.operator === 'void') {
                return fixer.replaceTextRange([expression.range[0], expression.range[0] + 4], 'await');
            }
            if ((0, util_1.isParenthesized)(expression, context.sourceCode) ||
                (0, util_1.getOperatorPrecedenceForNode)(expression) > util_1.OperatorPrecedence.Unary) {
                return fixer.insertTextBefore(node, 'await ');
            }
            return [
                fixer.insertTextBefore(node, 'await ('),
                fixer.insertTextAfterRange([expression.range[1], expression.range[1]], ')'),
            ];
        }
        function isKnownSafePromiseCall(node) {
            if (node.type !== utils_1.AST_NODE_TYPES.CallExpression) {
                return false;
            }
            const type = services.getTypeAtLocation(node.callee);
            if ((0, util_1.valueMatchesSomeSpecifier)(node.callee, allowForKnownSafeCalls, services.program, type)) {
                return true;
            }
            return (0, util_1.typeMatchesSomeSpecifier)(type, allowForKnownSafeCalls, services.program);
        }
        function isAsyncIife(node) {
            if (node.expression.type !== utils_1.AST_NODE_TYPES.CallExpression) {
                return false;
            }
            return (node.expression.callee.type ===
                utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                node.expression.callee.type === utils_1.AST_NODE_TYPES.FunctionExpression);
        }
        function isValidRejectionHandler(rejectionHandler) {
            return (services.program
                .getTypeChecker()
                .getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(rejectionHandler))
                .getCallSignatures().length > 0);
        }
        function isUnhandledPromise(checker, node) {
            if (node.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {
                return { isUnhandled: false };
            }
            // First, check expressions whose resulting types may not be promise-like
            if (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {
                // Any child in a comma expression could return a potentially unhandled
                // promise, so we check them all regardless of whether the final returned
                // value is promise-like.
                return (node.expressions
                    .map(item => isUnhandledPromise(checker, item))
                    .find(result => result.isUnhandled) ?? { isUnhandled: false });
            }
            if (!options.ignoreVoid &&
                node.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                node.operator === 'void') {
                // Similarly, a `void` expression always returns undefined, so we need to
                // see what's inside it without checking the type of the overall expression.
                return isUnhandledPromise(checker, node.argument);
            }
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            // Check the type. At this point it can't be unhandled if it isn't a promise
            // or array thereof.
            if (isPromiseArray(tsNode)) {
                return { isUnhandled: true, promiseArray: true };
            }
            // await expression addresses promises, but not promise arrays.
            if (node.type === utils_1.AST_NODE_TYPES.AwaitExpression) {
                // you would think this wouldn't be strictly necessary, since we're
                // anyway checking the type of the expression, but, unfortunately TS
                // reports the result of `await (promise as Promise<number> & number)`
                // as `Promise<number> & number` instead of `number`.
                return { isUnhandled: false };
            }
            if (!isPromiseLike(tsNode)) {
                return { isUnhandled: false };
            }
            if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {
                // If the outer expression is a call, a `.catch()` or `.then()` with
                // rejection handler handles the promise.
                const promiseHandlingMethodCall = (0, promiseUtils_1.parseCatchCall)(node, context) ?? (0, promiseUtils_1.parseThenCall)(node, context);
                if (promiseHandlingMethodCall != null) {
                    const onRejected = promiseHandlingMethodCall.onRejected;
                    if (onRejected != null) {
                        if (isValidRejectionHandler(onRejected)) {
                            return { isUnhandled: false };
                        }
                        return { isUnhandled: true, nonFunctionHandler: true };
                    }
                    return { isUnhandled: true };
                }
                const promiseFinallyCall = (0, promiseUtils_1.parseFinallyCall)(node, context);
                if (promiseFinallyCall != null) {
                    return isUnhandledPromise(checker, promiseFinallyCall.object);
                }
                // All other cases are unhandled.
                return { isUnhandled: true };
            }
            if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {
                // We must be getting the promise-like value from one of the branches of the
                // ternary. Check them directly.
                const alternateResult = isUnhandledPromise(checker, node.alternate);
                if (alternateResult.isUnhandled) {
                    return alternateResult;
                }
                return isUnhandledPromise(checker, node.consequent);
            }
            if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression) {
                const leftResult = isUnhandledPromise(checker, node.left);
                if (leftResult.isUnhandled) {
                    return leftResult;
                }
                return isUnhandledPromise(checker, node.right);
            }
            // Anything else is unhandled.
            return { isUnhandled: true };
        }
        function isPromiseArray(node) {
            const type = checker.getTypeAtLocation(node);
            for (const ty of tsutils
                .unionConstituents(type)
                .map(t => checker.getApparentType(t))) {
                if (checker.isArrayType(ty)) {
                    const arrayType = checker.getTypeArguments(ty)[0];
                    if (isPromiseLike(node, arrayType)) {
                        return true;
                    }
                }
                if (checker.isTupleType(ty)) {
                    for (const tupleElementType of checker.getTypeArguments(ty)) {
                        if (isPromiseLike(node, tupleElementType)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        function isPromiseLike(node, type) {
            type ??= checker.getTypeAtLocation(node);
            // The highest priority is to allow anything allowlisted
            if ((0, util_1.typeMatchesSomeSpecifier)(type, allowForKnownSafePromises, services.program)) {
                return false;
            }
            // Otherwise, we always consider the built-in Promise to be Promise-like...
            const typeParts = tsutils.unionConstituents(checker.getApparentType(type));
            if (typeParts.some(typePart => (0, util_1.isBuiltinSymbolLike)(services.program, typePart, 'Promise'))) {
                return true;
            }
            // ...and only check all Thenables if explicitly told to
            if (!checkThenables) {
                return false;
            }
            // Modified from tsutils.isThenable() to only consider thenables which can be
            // rejected/caught via a second parameter. Original source (MIT licensed):
            //
            //   https://github.com/ajafff/tsutils/blob/49d0d31050b44b81e918eae4fbaf1dfe7b7286af/util/type.ts#L95-L125
            for (const ty of typeParts) {
                const then = ty.getProperty('then');
                if (then == null) {
                    continue;
                }
                const thenType = checker.getTypeOfSymbolAtLocation(then, node);
                if (hasMatchingSignature(thenType, signature => signature.parameters.length >= 2 &&
                    isFunctionParam(checker, signature.parameters[0], node) &&
                    isFunctionParam(checker, signature.parameters[1], node))) {
                    return true;
                }
            }
            return false;
        }
    },
});
function hasMatchingSignature(type, matcher) {
    for (const t of tsutils.unionConstituents(type)) {
        if (t.getCallSignatures().some(matcher)) {
            return true;
        }
    }
    return false;
}
function isFunctionParam(checker, param, node) {
    const type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));
    for (const t of tsutils.unionConstituents(type)) {
        if (t.getCallSignatures().length !== 0) {
            return true;
        }
    }
    return false;
}


--------------------------------------------------------------------------------
FILE: no-for-in-array.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"forInViolation", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-for-in-array.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const getForStatementHeadLoc_1 = require("../util/getForStatementHeadLoc");
exports.default = (0, util_1.createRule)({
    name: 'no-for-in-array',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow iterating over an array with a for-in loop',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            forInViolation: 'For-in loops over arrays skips holes, returns indices as strings, and may visit the prototype chain or other enumerable properties. Use a more robust iteration method such as for-of or array.forEach instead.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            ForInStatement(node) {
                const services = (0, util_1.getParserServices)(context);
                const checker = services.program.getTypeChecker();
                const type = (0, util_1.getConstrainedTypeAtLocation)(services, node.right);
                if (isArrayLike(checker, type)) {
                    context.report({
                        loc: (0, getForStatementHeadLoc_1.getForStatementHeadLoc)(context.sourceCode, node),
                        messageId: 'forInViolation',
                    });
                }
            },
        };
    },
});
function isArrayLike(checker, type) {
    return isTypeRecurser(type, t => t.getNumberIndexType() != null && hasArrayishLength(checker, t));
}
function hasArrayishLength(checker, type) {
    const lengthProperty = type.getProperty('length');
    if (lengthProperty == null) {
        return false;
    }
    return tsutils.isTypeFlagSet(checker.getTypeOfSymbol(lengthProperty), ts.TypeFlags.NumberLike);
}
function isTypeRecurser(type, predicate) {
    if (type.isUnionOrIntersection()) {
        return type.types.some(t => isTypeRecurser(t, predicate));
    }
    return predicate(type);
}


--------------------------------------------------------------------------------
FILE: no-implied-eval.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noFunctionConstructor" | "noImpliedEvalError", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-implied-eval.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const FUNCTION_CONSTRUCTOR = 'Function';
const GLOBAL_CANDIDATES = new Set(['global', 'globalThis', 'window']);
const EVAL_LIKE_FUNCTIONS = new Set([
    'execScript',
    'setImmediate',
    'setInterval',
    'setTimeout',
]);
exports.default = (0, util_1.createRule)({
    name: 'no-implied-eval',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow the use of `eval()`-like functions',
            extendsBaseRule: true,
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            noFunctionConstructor: 'Implied eval. Do not use the Function constructor to create functions.',
            noImpliedEvalError: 'Implied eval. Consider passing a function.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function getCalleeName(node) {
            if (node.type === utils_1.AST_NODE_TYPES.Identifier) {
                return node.name;
            }
            if (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                node.object.type === utils_1.AST_NODE_TYPES.Identifier &&
                GLOBAL_CANDIDATES.has(node.object.name)) {
                if (node.property.type === utils_1.AST_NODE_TYPES.Identifier) {
                    return node.property.name;
                }
                if (node.property.type === utils_1.AST_NODE_TYPES.Literal &&
                    typeof node.property.value === 'string') {
                    return node.property.value;
                }
            }
            return null;
        }
        function isFunctionType(node) {
            const type = services.getTypeAtLocation(node);
            const symbol = type.getSymbol();
            if (symbol &&
                tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Function | ts.SymbolFlags.Method)) {
                return true;
            }
            if ((0, util_1.isBuiltinSymbolLike)(services.program, type, FUNCTION_CONSTRUCTOR)) {
                return true;
            }
            const signatures = checker.getSignaturesOfType(type, ts.SignatureKind.Call);
            return signatures.length > 0;
        }
        function isBind(node) {
            return node.type === utils_1.AST_NODE_TYPES.MemberExpression
                ? isBind(node.property)
                : node.type === utils_1.AST_NODE_TYPES.Identifier && node.name === 'bind';
        }
        function isFunction(node) {
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                case utils_1.AST_NODE_TYPES.FunctionDeclaration:
                case utils_1.AST_NODE_TYPES.FunctionExpression:
                    return true;
                case utils_1.AST_NODE_TYPES.Literal:
                case utils_1.AST_NODE_TYPES.TemplateLiteral:
                    return false;
                case utils_1.AST_NODE_TYPES.CallExpression:
                    return isBind(node.callee) || isFunctionType(node);
                default:
                    return isFunctionType(node);
            }
        }
        function checkImpliedEval(node) {
            const calleeName = getCalleeName(node.callee);
            if (calleeName == null) {
                return;
            }
            if (calleeName === FUNCTION_CONSTRUCTOR) {
                const type = services.getTypeAtLocation(node.callee);
                const symbol = type.getSymbol();
                if (symbol) {
                    if ((0, util_1.isBuiltinSymbolLike)(services.program, type, 'FunctionConstructor')) {
                        context.report({ node, messageId: 'noFunctionConstructor' });
                        return;
                    }
                }
                else {
                    context.report({ node, messageId: 'noFunctionConstructor' });
                    return;
                }
            }
            if (node.arguments.length === 0) {
                return;
            }
            const [handler] = node.arguments;
            if (EVAL_LIKE_FUNCTIONS.has(calleeName) &&
                !isFunction(handler) &&
                (0, util_1.isReferenceToGlobalFunction)(calleeName, node, context.sourceCode)) {
                context.report({ node: handler, messageId: 'noImpliedEvalError' });
            }
        }
        return {
            CallExpression: checkImpliedEval,
            NewExpression: checkImpliedEval,
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-import-type-side-effects.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [];
export type MessageIds = 'useTopLevelQualifier';
declare const _default: TSESLint.RuleModule<"useTopLevelQualifier", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-import-type-side-effects.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-import-type-side-effects',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce the use of top-level import type qualifier when an import only has specifiers with inline type qualifiers',
        },
        fixable: 'code',
        messages: {
            useTopLevelQualifier: 'TypeScript will only remove the inline type specifiers which will leave behind a side effect import at runtime. Convert this to a top-level type qualifier to properly remove the entire import.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            'ImportDeclaration[importKind!="type"]'(node) {
                if (node.specifiers.length === 0) {
                    return;
                }
                const specifiers = [];
                for (const specifier of node.specifiers) {
                    if (specifier.type !== utils_1.AST_NODE_TYPES.ImportSpecifier ||
                        specifier.importKind !== 'type') {
                        return;
                    }
                    specifiers.push(specifier);
                }
                context.report({
                    node,
                    messageId: 'useTopLevelQualifier',
                    fix(fixer) {
                        const fixes = [];
                        for (const specifier of specifiers) {
                            const qualifier = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(specifier, util_1.isTypeKeyword), util_1.NullThrowsReasons.MissingToken('type keyword', 'import specifier'));
                            fixes.push(fixer.removeRange([
                                qualifier.range[0],
                                specifier.imported.range[0],
                            ]));
                        }
                        const importKeyword = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken('import keyword', 'import'));
                        fixes.push(fixer.insertTextAfter(importKeyword, ' type'));
                        return fixes;
                    },
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-inferrable-types.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        ignoreParameters?: boolean;
        ignoreProperties?: boolean;
    }
];
export type MessageIds = 'noInferrableType';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noInferrableType", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-inferrable-types.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-inferrable-types',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow explicit type declarations for variables or parameters initialized to a number, string, or boolean',
            recommended: 'stylistic',
        },
        fixable: 'code',
        messages: {
            noInferrableType: 'Type {{type}} trivially inferred from a {{type}} literal, remove type annotation.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ignoreParameters: {
                        type: 'boolean',
                        description: 'Whether to ignore function parameters.',
                    },
                    ignoreProperties: {
                        type: 'boolean',
                        description: 'Whether to ignore class properties.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            ignoreParameters: false,
            ignoreProperties: false,
        },
    ],
    create(context, [{ ignoreParameters, ignoreProperties }]) {
        function isFunctionCall(init, callName) {
            const node = (0, util_1.skipChainExpression)(init);
            return (node.type === utils_1.AST_NODE_TYPES.CallExpression &&
                node.callee.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.callee.name === callName);
        }
        function isLiteral(init, typeName) {
            return (init.type === utils_1.AST_NODE_TYPES.Literal && typeof init.value === typeName);
        }
        function isIdentifier(init, ...names) {
            return (init.type === utils_1.AST_NODE_TYPES.Identifier && names.includes(init.name));
        }
        function hasUnaryPrefix(init, ...operators) {
            return (init.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                operators.includes(init.operator));
        }
        const keywordMap = {
            [utils_1.AST_NODE_TYPES.TSBigIntKeyword]: 'bigint',
            [utils_1.AST_NODE_TYPES.TSBooleanKeyword]: 'boolean',
            [utils_1.AST_NODE_TYPES.TSNullKeyword]: 'null',
            [utils_1.AST_NODE_TYPES.TSNumberKeyword]: 'number',
            [utils_1.AST_NODE_TYPES.TSStringKeyword]: 'string',
            [utils_1.AST_NODE_TYPES.TSSymbolKeyword]: 'symbol',
            [utils_1.AST_NODE_TYPES.TSUndefinedKeyword]: 'undefined',
        };
        /**
         * Returns whether a node has an inferrable value or not
         */
        function isInferrable(annotation, init) {
            switch (annotation.type) {
                case utils_1.AST_NODE_TYPES.TSBigIntKeyword: {
                    // note that bigint cannot have + prefixed to it
                    const unwrappedInit = hasUnaryPrefix(init, '-')
                        ? init.argument
                        : init;
                    return (isFunctionCall(unwrappedInit, 'BigInt') ||
                        unwrappedInit.type === utils_1.AST_NODE_TYPES.Literal);
                }
                case utils_1.AST_NODE_TYPES.TSBooleanKeyword:
                    return (hasUnaryPrefix(init, '!') ||
                        isFunctionCall(init, 'Boolean') ||
                        isLiteral(init, 'boolean'));
                case utils_1.AST_NODE_TYPES.TSNumberKeyword: {
                    const unwrappedInit = hasUnaryPrefix(init, '+', '-')
                        ? init.argument
                        : init;
                    return (isIdentifier(unwrappedInit, 'Infinity', 'NaN') ||
                        isFunctionCall(unwrappedInit, 'Number') ||
                        isLiteral(unwrappedInit, 'number'));
                }
                case utils_1.AST_NODE_TYPES.TSNullKeyword:
                    return init.type === utils_1.AST_NODE_TYPES.Literal && init.value == null;
                case utils_1.AST_NODE_TYPES.TSStringKeyword:
                    return (isFunctionCall(init, 'String') ||
                        isLiteral(init, 'string') ||
                        init.type === utils_1.AST_NODE_TYPES.TemplateLiteral);
                case utils_1.AST_NODE_TYPES.TSSymbolKeyword:
                    return isFunctionCall(init, 'Symbol');
                case utils_1.AST_NODE_TYPES.TSTypeReference: {
                    if (annotation.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
                        annotation.typeName.name === 'RegExp') {
                        const isRegExpLiteral = init.type === utils_1.AST_NODE_TYPES.Literal &&
                            init.value instanceof RegExp;
                        const isRegExpNewCall = init.type === utils_1.AST_NODE_TYPES.NewExpression &&
                            init.callee.type === utils_1.AST_NODE_TYPES.Identifier &&
                            init.callee.name === 'RegExp';
                        const isRegExpCall = isFunctionCall(init, 'RegExp');
                        return isRegExpLiteral || isRegExpCall || isRegExpNewCall;
                    }
                    return false;
                }
                case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
                    return (hasUnaryPrefix(init, 'void') || isIdentifier(init, 'undefined'));
            }
            return false;
        }
        /**
         * Reports an inferrable type declaration, if any
         */
        function reportInferrableType(node, typeNode, initNode) {
            if (!typeNode || !initNode) {
                return;
            }
            if (!isInferrable(typeNode.typeAnnotation, initNode)) {
                return;
            }
            const type = typeNode.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference
                ? // TODO - if we add more references
                    'RegExp'
                : keywordMap[typeNode.typeAnnotation.type];
            context.report({
                node,
                messageId: 'noInferrableType',
                data: {
                    type,
                },
                *fix(fixer) {
                    if ((node.type === utils_1.AST_NODE_TYPES.AssignmentPattern &&
                        node.left.optional) ||
                        (node.type === utils_1.AST_NODE_TYPES.PropertyDefinition && node.definite)) {
                        yield fixer.remove((0, util_1.nullThrows)(context.sourceCode.getTokenBefore(typeNode), util_1.NullThrowsReasons.MissingToken('token before', 'type node')));
                    }
                    yield fixer.remove(typeNode);
                },
            });
        }
        function inferrableVariableVisitor(node) {
            reportInferrableType(node, node.id.typeAnnotation, node.init);
        }
        function inferrableParameterVisitor(node) {
            if (ignoreParameters) {
                return;
            }
            node.params.forEach(param => {
                if (param.type === utils_1.AST_NODE_TYPES.TSParameterProperty) {
                    param = param.parameter;
                }
                if (param.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {
                    reportInferrableType(param, param.left.typeAnnotation, param.right);
                }
            });
        }
        function inferrablePropertyVisitor(node) {
            // We ignore `readonly` because of Microsoft/TypeScript#14416
            // Essentially a readonly property without a type
            // will result in its value being the type, leading to
            // compile errors if the type is stripped.
            if (ignoreProperties || node.readonly || node.optional) {
                return;
            }
            reportInferrableType(node, node.typeAnnotation, node.value);
        }
        return {
            AccessorProperty: inferrablePropertyVisitor,
            ArrowFunctionExpression: inferrableParameterVisitor,
            FunctionDeclaration: inferrableParameterVisitor,
            FunctionExpression: inferrableParameterVisitor,
            PropertyDefinition: inferrablePropertyVisitor,
            VariableDeclarator: inferrableVariableVisitor,
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-invalid-this.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpectedThis", [({
    capIsConstructor?: boolean;
} | undefined)?], unknown, {
    ThisExpression(node: TSESTree.ThisExpression): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unexpectedThis", [({
    capIsConstructor?: boolean;
} | undefined)?], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-invalid-this.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-invalid-this');
const defaultOptions = [{ capIsConstructor: true }];
exports.default = (0, util_1.createRule)({
    name: 'no-invalid-this',
    meta: {
        type: 'suggestion',
        defaultOptions,
        docs: {
            description: 'Disallow `this` keywords outside of classes or class-like objects',
            extendsBaseRule: true,
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: baseRule.meta.schema,
    },
    defaultOptions,
    create(context) {
        const rules = baseRule.create(context);
        /**
         * Since function definitions can be nested we use a stack storing if "this" is valid in the current context.
         *
         * Example:
         *
         * function a(this: number) { // valid "this"
         *     function b() {
         *         console.log(this); // invalid "this"
         *     }
         * }
         *
         * When parsing the function declaration of "a" the stack will be: [true]
         * When parsing the function declaration of "b" the stack will be: [true, false]
         */
        const thisIsValidStack = [];
        return {
            ...rules,
            AccessorProperty() {
                thisIsValidStack.push(true);
            },
            'AccessorProperty:exit'() {
                thisIsValidStack.pop();
            },
            FunctionDeclaration(node) {
                thisIsValidStack.push(node.params.some(param => param.type === utils_1.AST_NODE_TYPES.Identifier && param.name === 'this'));
            },
            'FunctionDeclaration:exit'() {
                thisIsValidStack.pop();
            },
            FunctionExpression(node) {
                thisIsValidStack.push(node.params.some(param => param.type === utils_1.AST_NODE_TYPES.Identifier && param.name === 'this'));
            },
            'FunctionExpression:exit'() {
                thisIsValidStack.pop();
            },
            PropertyDefinition() {
                thisIsValidStack.push(true);
            },
            'PropertyDefinition:exit'() {
                thisIsValidStack.pop();
            },
            ThisExpression(node) {
                const thisIsValidHere = thisIsValidStack[thisIsValidStack.length - 1];
                if (thisIsValidHere) {
                    return;
                }
                // baseRule's work
                rules.ThisExpression(node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-invalid-void-type.d.ts
--------------------------------------------------------------------------------

export interface Options {
    allowAsThisParameter?: boolean;
    allowInGenericTypeArguments?: boolean | [string, ...string[]];
}
export type MessageIds = 'invalidVoidForGeneric' | 'invalidVoidNotReturn' | 'invalidVoidNotReturnOrGeneric' | 'invalidVoidNotReturnOrThisParam' | 'invalidVoidNotReturnOrThisParamOrGeneric' | 'invalidVoidUnionConstituent';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, [Options], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-invalid-void-type.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-invalid-void-type',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow `void` type outside of generic or return types',
            recommended: 'strict',
        },
        messages: {
            invalidVoidForGeneric: '{{ generic }} may not have void as a type argument.',
            invalidVoidNotReturn: 'void is only valid as a return type.',
            invalidVoidNotReturnOrGeneric: 'void is only valid as a return type or generic type argument.',
            invalidVoidNotReturnOrThisParam: 'void is only valid as return type or type of `this` parameter.',
            invalidVoidNotReturnOrThisParamOrGeneric: 'void is only valid as a return type or generic type argument or the type of a `this` parameter.',
            invalidVoidUnionConstituent: 'void is not valid as a constituent in a union type',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowAsThisParameter: {
                        type: 'boolean',
                        description: 'Whether a `this` parameter of a function may be `void`.',
                    },
                    allowInGenericTypeArguments: {
                        description: 'Whether `void` can be used as a valid value for generic type parameters.',
                        oneOf: [
                            {
                                type: 'boolean',
                                description: 'Whether `void` can be used as a valid value for all generic type parameters.',
                            },
                            {
                                type: 'array',
                                description: 'Allowlist of types that may accept `void` as a generic type parameter.',
                                items: { type: 'string' },
                                minItems: 1,
                            },
                        ],
                    },
                },
            },
        ],
    },
    defaultOptions: [
        { allowAsThisParameter: false, allowInGenericTypeArguments: true },
    ],
    create(context, [{ allowAsThisParameter, allowInGenericTypeArguments }]) {
        const validParents = [
            utils_1.AST_NODE_TYPES.TSTypeAnnotation, //
        ];
        const invalidGrandParents = [
            utils_1.AST_NODE_TYPES.TSPropertySignature,
            utils_1.AST_NODE_TYPES.CallExpression,
            utils_1.AST_NODE_TYPES.PropertyDefinition,
            utils_1.AST_NODE_TYPES.AccessorProperty,
            utils_1.AST_NODE_TYPES.Identifier,
        ];
        const validUnionMembers = [
            utils_1.AST_NODE_TYPES.TSVoidKeyword,
            utils_1.AST_NODE_TYPES.TSNeverKeyword,
        ];
        if (allowInGenericTypeArguments === true) {
            validParents.push(utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation);
        }
        /**
         * @brief check if the given void keyword is used as a valid generic type
         *
         * reports if the type parametrized by void is not in the allowlist, or
         * allowInGenericTypeArguments is false.
         * no-op if the given void keyword is not used as generic type
         */
        function checkGenericTypeArgument(node) {
            // only matches T<..., void, ...>
            // extra check for precaution
            /* istanbul ignore next */
            if (node.parent.type !== utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation ||
                node.parent.parent.type !== utils_1.AST_NODE_TYPES.TSTypeReference) {
                return;
            }
            // check allowlist
            if (Array.isArray(allowInGenericTypeArguments)) {
                const fullyQualifiedName = context.sourceCode
                    .getText(node.parent.parent.typeName)
                    .replaceAll(' ', '');
                if (!allowInGenericTypeArguments
                    .map(s => s.replaceAll(' ', ''))
                    .includes(fullyQualifiedName)) {
                    context.report({
                        node,
                        messageId: 'invalidVoidForGeneric',
                        data: { generic: fullyQualifiedName },
                    });
                }
                return;
            }
            if (!allowInGenericTypeArguments) {
                context.report({
                    node,
                    messageId: allowAsThisParameter
                        ? 'invalidVoidNotReturnOrThisParam'
                        : 'invalidVoidNotReturn',
                });
            }
        }
        /**
         * @brief checks if the generic type parameter defaults to void
         */
        function checkDefaultVoid(node, parentNode) {
            if (parentNode.default !== node) {
                context.report({
                    node,
                    messageId: getNotReturnOrGenericMessageId(node),
                });
            }
        }
        /**
         * @brief checks that a union containing void is valid
         * @return true if every member of the union is specified as a valid type in
         * validUnionMembers, or is a valid generic type parametrized by void
         */
        function isValidUnionType(node) {
            return node.types.every(member => validUnionMembers.includes(member.type) ||
                // allows any T<..., void, ...> here, checked by checkGenericTypeArgument
                (member.type === utils_1.AST_NODE_TYPES.TSTypeReference &&
                    member.typeArguments?.type ===
                        utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation &&
                    member.typeArguments.params
                        .map(param => param.type)
                        .includes(utils_1.AST_NODE_TYPES.TSVoidKeyword)));
        }
        return {
            TSVoidKeyword(node) {
                // checks T<..., void, ...> against specification of allowInGenericArguments option
                if (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation &&
                    node.parent.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference) {
                    checkGenericTypeArgument(node);
                    return;
                }
                // allow <T = void> if allowInGenericTypeArguments is specified, and report if the generic type parameter extends void
                if (allowInGenericTypeArguments &&
                    node.parent.type === utils_1.AST_NODE_TYPES.TSTypeParameter &&
                    node.parent.default?.type === utils_1.AST_NODE_TYPES.TSVoidKeyword) {
                    checkDefaultVoid(node, node.parent);
                    return;
                }
                // union w/ void must contain types from validUnionMembers, or a valid generic void type
                if (node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType &&
                    isValidUnionType(node.parent)) {
                    return;
                }
                // using `void` as part of the return type of function overloading implementation
                if (node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType) {
                    const declaringFunction = getParentFunctionDeclarationNode(node.parent);
                    if (declaringFunction &&
                        (0, util_1.hasOverloadSignatures)(declaringFunction, context)) {
                        return;
                    }
                }
                // this parameter is ok to be void.
                if (allowAsThisParameter &&
                    node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAnnotation &&
                    node.parent.parent.type === utils_1.AST_NODE_TYPES.Identifier &&
                    node.parent.parent.name === 'this') {
                    return;
                }
                // default cases
                if (validParents.includes(node.parent.type) &&
                    // https://github.com/typescript-eslint/typescript-eslint/issues/6225
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    !invalidGrandParents.includes(node.parent.parent.type)) {
                    return;
                }
                context.report({
                    node,
                    messageId: allowInGenericTypeArguments && allowAsThisParameter
                        ? 'invalidVoidNotReturnOrThisParamOrGeneric'
                        : allowInGenericTypeArguments
                            ? getNotReturnOrGenericMessageId(node)
                            : allowAsThisParameter
                                ? 'invalidVoidNotReturnOrThisParam'
                                : 'invalidVoidNotReturn',
                });
            },
        };
    },
});
function getNotReturnOrGenericMessageId(node) {
    return node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType
        ? 'invalidVoidUnionConstituent'
        : 'invalidVoidNotReturnOrGeneric';
}
function getParentFunctionDeclarationNode(node) {
    let current = node.parent;
    while (current) {
        if (current.type === utils_1.AST_NODE_TYPES.FunctionDeclaration) {
            return current;
        }
        if (current.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
            current.value.body != null) {
            return current;
        }
        current = current.parent;
    }
    return null;
}


--------------------------------------------------------------------------------
FILE: no-loop-func.d.ts
--------------------------------------------------------------------------------

import type { TSESLint, TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: TSESLint.RuleModule<"unsafeRefs", [], unknown, {
    ArrowFunctionExpression(node: TSESTree.ArrowFunctionExpression): void;
    FunctionDeclaration(node: TSESTree.FunctionDeclaration): void;
    FunctionExpression(node: TSESTree.FunctionExpression): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: TSESLint.RuleModule<"unsafeRefs", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-loop-func.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-loop-func');
exports.default = (0, util_1.createRule)({
    name: 'no-loop-func',
    meta: {
        type: 'suggestion',
        // defaultOptions, -- base rule does not use defaultOptions
        docs: {
            description: 'Disallow function declarations that contain unsafe references inside loop statements',
            extendsBaseRule: true,
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const SKIPPED_IIFE_NODES = new Set();
        /**
         * Gets the containing loop node of a specified node.
         *
         * We don't need to check nested functions, so this ignores those.
         * `Scope.through` contains references of nested functions.
         *
         * @param node An AST node to get.
         * @returns The containing loop node of the specified node, or `null`.
         */
        function getContainingLoopNode(node) {
            for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {
                const parent = currentNode.parent;
                switch (parent.type) {
                    case utils_1.AST_NODE_TYPES.WhileStatement:
                    case utils_1.AST_NODE_TYPES.DoWhileStatement:
                        return parent;
                    case utils_1.AST_NODE_TYPES.ForStatement:
                        // `init` is outside of the loop.
                        if (parent.init !== currentNode) {
                            return parent;
                        }
                        break;
                    case utils_1.AST_NODE_TYPES.ForInStatement:
                    case utils_1.AST_NODE_TYPES.ForOfStatement:
                        // `right` is outside of the loop.
                        if (parent.right !== currentNode) {
                            return parent;
                        }
                        break;
                    case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                    case utils_1.AST_NODE_TYPES.FunctionExpression:
                    case utils_1.AST_NODE_TYPES.FunctionDeclaration:
                        // We don't need to check nested functions.
                        // We need to check nested functions only in case of IIFE.
                        if (SKIPPED_IIFE_NODES.has(parent)) {
                            break;
                        }
                        return null;
                    default:
                        break;
                }
            }
            return null;
        }
        /**
         * Gets the containing loop node of a given node.
         * If the loop was nested, this returns the most outer loop.
         * @param node A node to get. This is a loop node.
         * @param excludedNode A node that the result node should not include.
         * @returns The most outer loop node.
         */
        function getTopLoopNode(node, excludedNode) {
            const border = excludedNode ? excludedNode.range[1] : 0;
            let retv = node;
            let containingLoopNode = node;
            while (containingLoopNode && containingLoopNode.range[0] >= border) {
                retv = containingLoopNode;
                containingLoopNode = getContainingLoopNode(containingLoopNode);
            }
            return retv;
        }
        /**
         * Checks whether a given reference which refers to an upper scope's variable is
         * safe or not.
         * @param loopNode A containing loop node.
         * @param reference A reference to check.
         * @returns `true` if the reference is safe or not.
         */
        function isSafe(loopNode, reference) {
            const variable = reference.resolved;
            const definition = variable?.defs[0];
            const declaration = definition?.parent;
            const kind = declaration?.type === utils_1.AST_NODE_TYPES.VariableDeclaration
                ? declaration.kind
                : '';
            // type references are all safe
            // this only really matters for global types that haven't been configured
            if (reference.isTypeReference) {
                return true;
            }
            // Variables which are declared by `const` is safe.
            if (kind === 'const') {
                return true;
            }
            /*
             * Variables which are declared by `let` in the loop is safe.
             * It's a different instance from the next loop step's.
             */
            if (kind === 'let' &&
                declaration &&
                declaration.range[0] > loopNode.range[0] &&
                declaration.range[1] < loopNode.range[1]) {
                return true;
            }
            /*
             * WriteReferences which exist after this border are unsafe because those
             * can modify the variable.
             */
            const border = getTopLoopNode(loopNode, kind === 'let' ? declaration : null).range[0];
            /**
             * Checks whether a given reference is safe or not.
             * The reference is every reference of the upper scope's variable we are
             * looking now.
             *
             * It's safe if the reference matches one of the following condition.
             * - is readonly.
             * - doesn't exist inside a local function and after the border.
             *
             * @param upperRef A reference to check.
             * @returns `true` if the reference is safe.
             */
            function isSafeReference(upperRef) {
                const id = upperRef.identifier;
                return (!upperRef.isWrite() ||
                    (variable?.scope.variableScope === upperRef.from.variableScope &&
                        id.range[0] < border));
            }
            return variable?.references.every(isSafeReference) ?? false;
        }
        /**
         * Reports functions which match the following condition:
         * - has a loop node in ancestors.
         * - has any references which refers to an unsafe variable.
         *
         * @param node The AST node to check.
         */
        function checkForLoops(node) {
            const loopNode = getContainingLoopNode(node);
            if (!loopNode) {
                return;
            }
            const references = context.sourceCode.getScope(node).through;
            if (!(node.async || node.generator) && isIIFE(node)) {
                const isFunctionExpression = node.type === utils_1.AST_NODE_TYPES.FunctionExpression;
                // Check if the function is referenced elsewhere in the code
                const isFunctionReferenced = isFunctionExpression && node.id
                    ? references.some(r => r.identifier.name === node.id?.name)
                    : false;
                if (!isFunctionReferenced) {
                    SKIPPED_IIFE_NODES.add(node);
                    return;
                }
            }
            const unsafeRefs = references
                .filter(r => r.resolved && !isSafe(loopNode, r))
                .map(r => r.identifier.name);
            if (unsafeRefs.length > 0) {
                context.report({
                    node,
                    messageId: 'unsafeRefs',
                    data: { varNames: `'${unsafeRefs.join("', '")}'` },
                });
            }
        }
        return {
            ArrowFunctionExpression: checkForLoops,
            FunctionDeclaration: checkForLoops,
            FunctionExpression: checkForLoops,
        };
    },
});
function isIIFE(node) {
    return (node.parent.type === utils_1.AST_NODE_TYPES.CallExpression &&
        node.parent.callee === node);
}


--------------------------------------------------------------------------------
FILE: no-loss-of-precision.d.ts
--------------------------------------------------------------------------------

import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
import { getESLintCoreRule } from '../util/getESLintCoreRule';
declare const baseRule: ReturnType<typeof getESLintCoreRule>;
export type Options = InferOptionsTypeFromRule<NonNullable<typeof baseRule>>;
export type MessageIds = InferMessageIdsTypeFromRule<NonNullable<typeof baseRule>>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noLossOfPrecision", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-loss-of-precision.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-loss-of-precision');
exports.default = (0, util_1.createRule)({
    name: 'no-loss-of-precision',
    meta: {
        type: 'problem',
        // defaultOptions, -- base rule does not use defaultOptions
        deprecated: {
            deprecatedSince: '8.0.0',
            replacedBy: [
                {
                    rule: {
                        name: 'no-loss-of-precision',
                        url: 'https://eslint.org/docs/latest/rules/no-loss-of-precision',
                    },
                },
            ],
            url: 'https://github.com/typescript-eslint/typescript-eslint/pull/8832',
        },
        docs: {
            description: 'Disallow literal numbers that lose precision',
            extendsBaseRule: true,
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return baseRule.create(context);
    },
});


--------------------------------------------------------------------------------
FILE: no-magic-numbers.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noMagic", [{
    detectObjects?: boolean;
    enforceConst?: boolean;
    ignore?: (number | string)[];
    ignoreArrayIndexes?: boolean;
    ignoreEnums?: boolean;
    ignoreNumericLiteralTypes?: boolean;
    ignoreReadonlyClassProperties?: boolean;
    ignoreTypeIndexes?: boolean;
}], unknown, {
    Literal(node: TSESTree.Literal): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noMagic", [{
    detectObjects?: boolean;
    enforceConst?: boolean;
    ignore?: (number | string)[];
    ignoreArrayIndexes?: boolean;
    ignoreEnums?: boolean;
    ignoreNumericLiteralTypes?: boolean;
    ignoreReadonlyClassProperties?: boolean;
    ignoreTypeIndexes?: boolean;
}], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-magic-numbers.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-magic-numbers');
// Extend base schema with additional property to ignore TS numeric literal types
const schema = (0, util_1.deepMerge)(
// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- https://github.com/microsoft/TypeScript/issues/17002
Array.isArray(baseRule.meta.schema)
    ? baseRule.meta.schema[0]
    : baseRule.meta.schema, {
    properties: {
        ignoreEnums: {
            type: 'boolean',
            description: 'Whether enums used in TypeScript are considered okay.',
        },
        ignoreNumericLiteralTypes: {
            type: 'boolean',
            description: 'Whether numbers used in TypeScript numeric literal types are considered okay.',
        },
        ignoreReadonlyClassProperties: {
            type: 'boolean',
            description: 'Whether `readonly` class properties are considered okay.',
        },
        ignoreTypeIndexes: {
            type: 'boolean',
            description: 'Whether numbers used to index types are okay.',
        },
    },
});
exports.default = (0, util_1.createRule)({
    name: 'no-magic-numbers',
    meta: {
        type: 'suggestion',
        // defaultOptions, -- base rule does not use defaultOptions
        docs: {
            description: 'Disallow magic numbers',
            extendsBaseRule: true,
            frozen: true,
        },
        messages: baseRule.meta.messages,
        schema: [schema],
    },
    defaultOptions: [
        {
            detectObjects: false,
            enforceConst: false,
            ignore: [],
            ignoreArrayIndexes: false,
            ignoreEnums: false,
            ignoreNumericLiteralTypes: false,
            ignoreReadonlyClassProperties: false,
            ignoreTypeIndexes: false,
        },
    ],
    create(context, [options]) {
        const rules = baseRule.create(context);
        const ignored = new Set((options.ignore ?? []).map(normalizeIgnoreValue));
        return {
            Literal(node) {
                // If it’s not a numeric literal we’re not interested
                if (typeof node.value !== 'number' && typeof node.value !== 'bigint') {
                    return;
                }
                // This will be `true` if we’re configured to ignore this case (eg. it’s
                // an enum and `ignoreEnums` is `true`). It will be `false` if we’re not
                // configured to ignore this case. It will remain `undefined` if this is
                // not one of our exception cases, and we’ll fall back to the base rule.
                let isAllowed;
                // Check if the node is ignored
                if (ignored.has(normalizeLiteralValue(node, node.value))) {
                    isAllowed = true;
                }
                // Check if the node is a TypeScript enum declaration
                else if (isParentTSEnumDeclaration(node)) {
                    isAllowed = options.ignoreEnums === true;
                }
                // Check TypeScript specific nodes for Numeric Literal
                else if (isTSNumericLiteralType(node)) {
                    isAllowed = options.ignoreNumericLiteralTypes === true;
                }
                // Check if the node is a type index
                else if (isAncestorTSIndexedAccessType(node)) {
                    isAllowed = options.ignoreTypeIndexes === true;
                }
                // Check if the node is a readonly class property
                else if (isParentTSReadonlyPropertyDefinition(node)) {
                    isAllowed = options.ignoreReadonlyClassProperties === true;
                }
                // If we’ve hit a case where the ignore option is true we can return now
                if (isAllowed === true) {
                    return;
                }
                // If the ignore option is *not* set we can report it now
                if (isAllowed === false) {
                    let fullNumberNode = node;
                    let raw = node.raw;
                    if (node.parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                        // the base rule only shows the operator for negative numbers
                        // https://github.com/eslint/eslint/blob/9dfc8501fb1956c90dc11e6377b4cb38a6bea65d/lib/rules/no-magic-numbers.js#L126
                        node.parent.operator === '-') {
                        fullNumberNode = node.parent;
                        raw = `${node.parent.operator}${node.raw}`;
                    }
                    context.report({
                        node: fullNumberNode,
                        messageId: 'noMagic',
                        data: { raw },
                    });
                    return;
                }
                // Let the base rule deal with the rest
                rules.Literal(node);
            },
        };
    },
});
/**
 * Convert the value to bigint if it's a string. Otherwise, return the value as-is.
 * @param value The value to normalize.
 * @returns The normalized value.
 */
function normalizeIgnoreValue(value) {
    if (typeof value === 'string') {
        return BigInt(value.slice(0, -1));
    }
    return value;
}
/**
 * Converts the node to its numeric value, handling prefixed numbers (-1 / +1)
 * @param node the node to normalize.
 * @param value the node's value.
 */
function normalizeLiteralValue(node, value) {
    if (node.parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
        ['-', '+'].includes(node.parent.operator) &&
        node.parent.operator === '-') {
        return -value;
    }
    return value;
}
/**
 * Gets the true parent of the literal, handling prefixed numbers (-1 / +1)
 */
function getLiteralParent(node) {
    if (node.parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
        ['-', '+'].includes(node.parent.operator)) {
        return node.parent.parent;
    }
    return node.parent;
}
/**
 * Checks if the node grandparent is a Typescript type alias declaration
 * @param node the node to be validated.
 * @returns true if the node grandparent is a Typescript type alias declaration
 * @private
 */
function isGrandparentTSTypeAliasDeclaration(node) {
    return node.parent?.parent?.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration;
}
/**
 * Checks if the node grandparent is a Typescript union type and its parent is a type alias declaration
 * @param node the node to be validated.
 * @returns true if the node grandparent is a Typescript union type and its parent is a type alias declaration
 * @private
 */
function isGrandparentTSUnionType(node) {
    if (node.parent?.parent?.type === utils_1.AST_NODE_TYPES.TSUnionType) {
        return isGrandparentTSTypeAliasDeclaration(node.parent);
    }
    return false;
}
/**
 * Checks if the node parent is a Typescript enum member
 * @param node the node to be validated.
 * @returns true if the node parent is a Typescript enum member
 * @private
 */
function isParentTSEnumDeclaration(node) {
    const parent = getLiteralParent(node);
    return parent?.type === utils_1.AST_NODE_TYPES.TSEnumMember;
}
/**
 * Checks if the node parent is a Typescript literal type
 * @param node the node to be validated.
 * @returns true if the node parent is a Typescript literal type
 * @private
 */
function isParentTSLiteralType(node) {
    return node.parent?.type === utils_1.AST_NODE_TYPES.TSLiteralType;
}
/**
 * Checks if the node is a valid TypeScript numeric literal type.
 * @param node the node to be validated.
 * @returns true if the node is a TypeScript numeric literal type.
 * @private
 */
function isTSNumericLiteralType(node) {
    // For negative numbers, use the parent node
    if (node.parent?.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
        node.parent.operator === '-') {
        node = node.parent;
    }
    // If the parent node is not a TSLiteralType, early return
    if (!isParentTSLiteralType(node)) {
        return false;
    }
    // If the grandparent is a TSTypeAliasDeclaration, ignore
    if (isGrandparentTSTypeAliasDeclaration(node)) {
        return true;
    }
    // If the grandparent is a TSUnionType and it's parent is a TSTypeAliasDeclaration, ignore
    if (isGrandparentTSUnionType(node)) {
        return true;
    }
    return false;
}
/**
 * Checks if the node parent is a readonly class property
 * @param node the node to be validated.
 * @returns true if the node parent is a readonly class property
 * @private
 */
function isParentTSReadonlyPropertyDefinition(node) {
    const parent = getLiteralParent(node);
    if (parent?.type === utils_1.AST_NODE_TYPES.PropertyDefinition && parent.readonly) {
        return true;
    }
    return false;
}
/**
 * Checks if the node is part of a type indexed access (eg. Foo[4])
 * @param node the node to be validated.
 * @returns true if the node is part of an indexed access
 * @private
 */
function isAncestorTSIndexedAccessType(node) {
    // Handle unary expressions (eg. -4)
    let ancestor = getLiteralParent(node);
    // Go up another level while we’re part of a type union (eg. 1 | 2) or
    // intersection (eg. 1 & 2)
    while (ancestor?.parent?.type === utils_1.AST_NODE_TYPES.TSUnionType ||
        ancestor?.parent?.type === utils_1.AST_NODE_TYPES.TSIntersectionType) {
        ancestor = ancestor.parent;
    }
    return ancestor?.parent?.type === utils_1.AST_NODE_TYPES.TSIndexedAccessType;
}


--------------------------------------------------------------------------------
FILE: no-meaningless-void-operator.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        checkNever: boolean;
    }
];
declare const _default: TSESLint.RuleModule<"meaninglessVoidOperator" | "removeVoid", Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-meaningless-void-operator.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-meaningless-void-operator',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow the `void` operator except when used to discard a value',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            meaninglessVoidOperator: "void operator shouldn't be used on {{type}}; it should convey that a return value is being ignored",
            removeVoid: "Remove 'void'",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    checkNever: {
                        type: 'boolean',
                        description: 'Whether to suggest removing `void` when the argument has type `never`.',
                    },
                },
            },
        ],
    },
    defaultOptions: [{ checkNever: false }],
    create(context, [{ checkNever }]) {
        const services = utils_1.ESLintUtils.getParserServices(context);
        const checker = services.program.getTypeChecker();
        return {
            'UnaryExpression[operator="void"]'(node) {
                const fix = (fixer) => {
                    return fixer.removeRange([
                        context.sourceCode.getTokens(node)[0].range[0],
                        context.sourceCode.getTokens(node)[1].range[0],
                    ]);
                };
                const argType = services.getTypeAtLocation(node.argument);
                const unionParts = tsutils.unionConstituents(argType);
                if (unionParts.every(part => part.flags & (ts.TypeFlags.Void | ts.TypeFlags.Undefined))) {
                    context.report({
                        node,
                        messageId: 'meaninglessVoidOperator',
                        data: { type: checker.typeToString(argType) },
                        fix,
                    });
                }
                else if (checkNever &&
                    unionParts.every(part => part.flags &
                        (ts.TypeFlags.Void | ts.TypeFlags.Undefined | ts.TypeFlags.Never))) {
                    context.report({
                        node,
                        messageId: 'meaninglessVoidOperator',
                        data: { type: checker.typeToString(argType) },
                        suggest: [{ messageId: 'removeVoid', fix }],
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-misused-new.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"errorMessageClass" | "errorMessageInterface", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-misused-new.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-misused-new',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce valid definition of `new` and `constructor`',
            recommended: 'recommended',
        },
        messages: {
            errorMessageClass: 'Class cannot have method named `new`.',
            errorMessageInterface: 'Interfaces cannot be constructed, only classes.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        /**
         * @param node type to be inspected.
         * @returns name of simple type or null
         */
        function getTypeReferenceName(node) {
            if (node) {
                switch (node.type) {
                    case utils_1.AST_NODE_TYPES.TSTypeAnnotation:
                        return getTypeReferenceName(node.typeAnnotation);
                    case utils_1.AST_NODE_TYPES.TSTypeReference:
                        return getTypeReferenceName(node.typeName);
                    case utils_1.AST_NODE_TYPES.Identifier:
                        return node.name;
                    default:
                        break;
                }
            }
            return null;
        }
        /**
         * @param parent parent node.
         * @param returnType type to be compared
         */
        function isMatchingParentType(parent, returnType) {
            if (parent &&
                (parent.type === utils_1.AST_NODE_TYPES.ClassDeclaration ||
                    parent.type === utils_1.AST_NODE_TYPES.ClassExpression ||
                    parent.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) &&
                parent.id) {
                return getTypeReferenceName(returnType) === parent.id.name;
            }
            return false;
        }
        return {
            "ClassBody > MethodDefinition[key.name='new']"(node) {
                if (node.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression &&
                    isMatchingParentType(node.parent.parent, node.value.returnType)) {
                    context.report({
                        node,
                        messageId: 'errorMessageClass',
                    });
                }
            },
            'TSInterfaceBody > TSConstructSignatureDeclaration'(node) {
                if (isMatchingParentType(node.parent.parent, node.returnType)) {
                    // constructor
                    context.report({
                        node,
                        messageId: 'errorMessageInterface',
                    });
                }
            },
            "TSMethodSignature[key.name='constructor']"(node) {
                context.report({
                    node,
                    messageId: 'errorMessageInterface',
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-misused-promises.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        checksConditionals?: boolean;
        checksSpreads?: boolean;
        checksVoidReturn?: boolean | ChecksVoidReturnOptions;
    }
];
export interface ChecksVoidReturnOptions {
    arguments?: boolean;
    attributes?: boolean;
    inheritedMethods?: boolean;
    properties?: boolean;
    returns?: boolean;
    variables?: boolean;
}
export type MessageId = 'conditional' | 'predicate' | 'spread' | 'voidReturnArgument' | 'voidReturnAttribute' | 'voidReturnInheritedMethod' | 'voidReturnProperty' | 'voidReturnReturnValue' | 'voidReturnVariable';
declare const _default: TSESLint.RuleModule<MessageId, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-misused-promises.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const promiseUtils_1 = require("../util/promiseUtils");
function parseChecksVoidReturn(checksVoidReturn) {
    switch (checksVoidReturn) {
        case false:
            return false;
        case true:
        case undefined:
            return {
                arguments: true,
                attributes: true,
                inheritedMethods: true,
                properties: true,
                returns: true,
                variables: true,
            };
        default:
            return {
                arguments: checksVoidReturn.arguments ?? true,
                attributes: checksVoidReturn.attributes ?? true,
                inheritedMethods: checksVoidReturn.inheritedMethods ?? true,
                properties: checksVoidReturn.properties ?? true,
                returns: checksVoidReturn.returns ?? true,
                variables: checksVoidReturn.variables ?? true,
            };
    }
}
exports.default = (0, util_1.createRule)({
    name: 'no-misused-promises',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow Promises in places not designed to handle them',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            conditional: 'Expected non-Promise value in a boolean conditional.',
            predicate: 'Expected a non-Promise value to be returned.',
            spread: 'Expected a non-Promise value to be spread in an object.',
            voidReturnArgument: 'Promise returned in function argument where a void return was expected.',
            voidReturnAttribute: 'Promise-returning function provided to attribute where a void return was expected.',
            voidReturnInheritedMethod: "Promise-returning method provided where a void return was expected by extended/implemented type '{{ heritageTypeName }}'.",
            voidReturnProperty: 'Promise-returning function provided to property where a void return was expected.',
            voidReturnReturnValue: 'Promise-returning function provided to return value where a void return was expected.',
            voidReturnVariable: 'Promise-returning function provided to variable where a void return was expected.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    checksConditionals: {
                        type: 'boolean',
                        description: 'Whether to warn when a Promise is provided to conditional statements.',
                    },
                    checksSpreads: {
                        type: 'boolean',
                        description: 'Whether to warn when `...` spreading a `Promise`.',
                    },
                    checksVoidReturn: {
                        description: 'Whether to warn when a Promise is returned from a function typed as returning `void`.',
                        oneOf: [
                            {
                                type: 'boolean',
                                description: 'Whether to disable checking all asynchronous functions.',
                            },
                            {
                                type: 'object',
                                additionalProperties: false,
                                description: 'Which forms of functions may have checking disabled.',
                                properties: {
                                    arguments: {
                                        type: 'boolean',
                                        description: 'Disables checking an asynchronous function passed as argument where the parameter type expects a function that returns `void`.',
                                    },
                                    attributes: {
                                        type: 'boolean',
                                        description: 'Disables checking an asynchronous function passed as a JSX attribute expected to be a function that returns `void`.',
                                    },
                                    inheritedMethods: {
                                        type: 'boolean',
                                        description: 'Disables checking an asynchronous method in a type that extends or implements another type expecting that method to return `void`.',
                                    },
                                    properties: {
                                        type: 'boolean',
                                        description: 'Disables checking an asynchronous function passed as an object property expected to be a function that returns `void`.',
                                    },
                                    returns: {
                                        type: 'boolean',
                                        description: 'Disables checking an asynchronous function returned in a function whose return type is a function that returns `void`.',
                                    },
                                    variables: {
                                        type: 'boolean',
                                        description: 'Disables checking an asynchronous function used as a variable whose return type is a function that returns `void`.',
                                    },
                                },
                            },
                        ],
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            checksConditionals: true,
            checksSpreads: true,
            checksVoidReturn: true,
        },
    ],
    create(context, [{ checksConditionals, checksSpreads, checksVoidReturn }]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const checkedNodes = new Set();
        const conditionalChecks = {
            'CallExpression > MemberExpression': checkArrayPredicates,
            ConditionalExpression: checkTestConditional,
            DoWhileStatement: checkTestConditional,
            ForStatement: checkTestConditional,
            IfStatement: checkTestConditional,
            LogicalExpression: checkConditional,
            'UnaryExpression[operator="!"]'(node) {
                checkConditional(node.argument, true);
            },
            WhileStatement: checkTestConditional,
        };
        checksVoidReturn = parseChecksVoidReturn(checksVoidReturn);
        const voidReturnChecks = checksVoidReturn
            ? {
                ...(checksVoidReturn.arguments && {
                    CallExpression: checkArguments,
                    NewExpression: checkArguments,
                }),
                ...(checksVoidReturn.attributes && {
                    JSXAttribute: checkJSXAttribute,
                }),
                ...(checksVoidReturn.inheritedMethods && {
                    ClassDeclaration: checkClassLikeOrInterfaceNode,
                    ClassExpression: checkClassLikeOrInterfaceNode,
                    TSInterfaceDeclaration: checkClassLikeOrInterfaceNode,
                }),
                ...(checksVoidReturn.properties && {
                    Property: checkProperty,
                }),
                ...(checksVoidReturn.returns && {
                    ReturnStatement: checkReturnStatement,
                }),
                ...(checksVoidReturn.variables && {
                    AssignmentExpression: checkAssignment,
                    VariableDeclarator: checkVariableDeclaration,
                }),
            }
            : {};
        const spreadChecks = {
            SpreadElement: checkSpread,
        };
        /**
         * A syntactic check to see if an annotated type is maybe a function type.
         * This is a perf optimization to help avoid requesting types where possible
         */
        function isPossiblyFunctionType(node) {
            switch (node.typeAnnotation.type) {
                case utils_1.AST_NODE_TYPES.TSConditionalType:
                case utils_1.AST_NODE_TYPES.TSConstructorType:
                case utils_1.AST_NODE_TYPES.TSFunctionType:
                case utils_1.AST_NODE_TYPES.TSImportType:
                case utils_1.AST_NODE_TYPES.TSIndexedAccessType:
                case utils_1.AST_NODE_TYPES.TSInferType:
                case utils_1.AST_NODE_TYPES.TSIntersectionType:
                case utils_1.AST_NODE_TYPES.TSQualifiedName:
                case utils_1.AST_NODE_TYPES.TSThisType:
                case utils_1.AST_NODE_TYPES.TSTypeOperator:
                case utils_1.AST_NODE_TYPES.TSTypeQuery:
                case utils_1.AST_NODE_TYPES.TSTypeReference:
                case utils_1.AST_NODE_TYPES.TSUnionType:
                    return true;
                case utils_1.AST_NODE_TYPES.TSTypeLiteral:
                    return node.typeAnnotation.members.some(member => member.type === utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration ||
                        member.type === utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration);
                case utils_1.AST_NODE_TYPES.TSAbstractKeyword:
                case utils_1.AST_NODE_TYPES.TSAnyKeyword:
                case utils_1.AST_NODE_TYPES.TSArrayType:
                case utils_1.AST_NODE_TYPES.TSAsyncKeyword:
                case utils_1.AST_NODE_TYPES.TSBigIntKeyword:
                case utils_1.AST_NODE_TYPES.TSBooleanKeyword:
                case utils_1.AST_NODE_TYPES.TSDeclareKeyword:
                case utils_1.AST_NODE_TYPES.TSExportKeyword:
                case utils_1.AST_NODE_TYPES.TSIntrinsicKeyword:
                case utils_1.AST_NODE_TYPES.TSLiteralType:
                case utils_1.AST_NODE_TYPES.TSMappedType:
                case utils_1.AST_NODE_TYPES.TSNamedTupleMember:
                case utils_1.AST_NODE_TYPES.TSNeverKeyword:
                case utils_1.AST_NODE_TYPES.TSNullKeyword:
                case utils_1.AST_NODE_TYPES.TSNumberKeyword:
                case utils_1.AST_NODE_TYPES.TSObjectKeyword:
                case utils_1.AST_NODE_TYPES.TSOptionalType:
                case utils_1.AST_NODE_TYPES.TSPrivateKeyword:
                case utils_1.AST_NODE_TYPES.TSProtectedKeyword:
                case utils_1.AST_NODE_TYPES.TSPublicKeyword:
                case utils_1.AST_NODE_TYPES.TSReadonlyKeyword:
                case utils_1.AST_NODE_TYPES.TSRestType:
                case utils_1.AST_NODE_TYPES.TSStaticKeyword:
                case utils_1.AST_NODE_TYPES.TSStringKeyword:
                case utils_1.AST_NODE_TYPES.TSSymbolKeyword:
                case utils_1.AST_NODE_TYPES.TSTemplateLiteralType:
                case utils_1.AST_NODE_TYPES.TSTupleType:
                case utils_1.AST_NODE_TYPES.TSTypePredicate:
                case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
                case utils_1.AST_NODE_TYPES.TSUnknownKeyword:
                case utils_1.AST_NODE_TYPES.TSVoidKeyword:
                    return false;
            }
        }
        function checkTestConditional(node) {
            if (node.test) {
                checkConditional(node.test, true);
            }
        }
        /**
         * This function analyzes the type of a node and checks if it is a Promise in a boolean conditional.
         * It uses recursion when checking nested logical operators.
         * @param node The AST node to check.
         * @param isTestExpr Whether the node is a descendant of a test expression.
         */
        function checkConditional(node, isTestExpr = false) {
            // prevent checking the same node multiple times
            if (checkedNodes.has(node)) {
                return;
            }
            checkedNodes.add(node);
            if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression) {
                // ignore the left operand for nullish coalescing expressions not in a context of a test expression
                if (node.operator !== '??' || isTestExpr) {
                    checkConditional(node.left, isTestExpr);
                }
                // we ignore the right operand when not in a context of a test expression
                if (isTestExpr) {
                    checkConditional(node.right, isTestExpr);
                }
                return;
            }
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            if (isAlwaysThenable(checker, tsNode)) {
                context.report({
                    node,
                    messageId: 'conditional',
                });
            }
        }
        function checkArrayPredicates(node) {
            const parent = node.parent;
            if (parent.type === utils_1.AST_NODE_TYPES.CallExpression) {
                const callback = parent.arguments.at(0);
                if (callback &&
                    (0, util_1.isArrayMethodCallWithPredicate)(context, services, parent)) {
                    const type = services.esTreeNodeToTSNodeMap.get(callback);
                    if (returnsThenable(checker, type)) {
                        context.report({
                            node: callback,
                            messageId: 'predicate',
                        });
                    }
                }
            }
        }
        function checkArguments(node) {
            if (node.type === utils_1.AST_NODE_TYPES.CallExpression &&
                isPromiseFinallyMethod(node)) {
                return;
            }
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            const voidArgs = voidFunctionArguments(checker, tsNode);
            if (voidArgs.size === 0) {
                return;
            }
            for (const [index, argument] of node.arguments.entries()) {
                if (!voidArgs.has(index)) {
                    continue;
                }
                const tsNode = services.esTreeNodeToTSNodeMap.get(argument);
                if (returnsThenable(checker, tsNode)) {
                    context.report({
                        node: argument,
                        messageId: 'voidReturnArgument',
                    });
                }
            }
        }
        function checkAssignment(node) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            const varType = services.getTypeAtLocation(node.left);
            if (!isVoidReturningFunctionType(checker, tsNode.left, varType)) {
                return;
            }
            if (returnsThenable(checker, tsNode.right)) {
                context.report({
                    node: node.right,
                    messageId: 'voidReturnVariable',
                });
            }
        }
        function checkVariableDeclaration(node) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            if (tsNode.initializer == null ||
                node.init == null ||
                node.id.typeAnnotation == null) {
                return;
            }
            // syntactically ignore some known-good cases to avoid touching type info
            if (!isPossiblyFunctionType(node.id.typeAnnotation)) {
                return;
            }
            const varType = services.getTypeAtLocation(node.id);
            if (!isVoidReturningFunctionType(checker, tsNode.initializer, varType)) {
                return;
            }
            if (returnsThenable(checker, tsNode.initializer)) {
                context.report({
                    node: node.init,
                    messageId: 'voidReturnVariable',
                });
            }
        }
        function checkProperty(node) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            if (ts.isPropertyAssignment(tsNode)) {
                const contextualType = checker.getContextualType(tsNode.initializer);
                if (contextualType != null &&
                    isVoidReturningFunctionType(checker, tsNode.initializer, contextualType) &&
                    returnsThenable(checker, tsNode.initializer)) {
                    if ((0, util_1.isFunction)(node.value)) {
                        const functionNode = node.value;
                        if (functionNode.returnType) {
                            context.report({
                                node: functionNode.returnType.typeAnnotation,
                                messageId: 'voidReturnProperty',
                            });
                        }
                        else {
                            context.report({
                                loc: (0, util_1.getFunctionHeadLoc)(functionNode, context.sourceCode),
                                messageId: 'voidReturnProperty',
                            });
                        }
                    }
                    else {
                        context.report({
                            node: node.value,
                            messageId: 'voidReturnProperty',
                        });
                    }
                }
            }
            else if (ts.isShorthandPropertyAssignment(tsNode)) {
                const contextualType = checker.getContextualType(tsNode.name);
                if (contextualType != null &&
                    isVoidReturningFunctionType(checker, tsNode.name, contextualType) &&
                    returnsThenable(checker, tsNode.name)) {
                    context.report({
                        node: node.value,
                        messageId: 'voidReturnProperty',
                    });
                }
            }
            else if (ts.isMethodDeclaration(tsNode)) {
                if (ts.isComputedPropertyName(tsNode.name)) {
                    return;
                }
                const obj = tsNode.parent;
                // Below condition isn't satisfied unless something goes wrong,
                // but is needed for type checking.
                // 'node' does not include class method declaration so 'obj' is
                // always an object literal expression, but after converting 'node'
                // to TypeScript AST, its type includes MethodDeclaration which
                // does include the case of class method declaration.
                if (!ts.isObjectLiteralExpression(obj)) {
                    return;
                }
                if (!returnsThenable(checker, tsNode)) {
                    return;
                }
                const objType = checker.getContextualType(obj);
                if (objType == null) {
                    return;
                }
                const propertySymbol = tsutils
                    .unionConstituents(objType)
                    .map(t => checker.getPropertyOfType(t, tsNode.name.getText()))
                    .find(p => p);
                if (propertySymbol == null) {
                    return;
                }
                const contextualType = checker.getTypeOfSymbolAtLocation(propertySymbol, tsNode.name);
                if (isVoidReturningFunctionType(checker, tsNode.name, contextualType)) {
                    const functionNode = node.value;
                    if (functionNode.returnType) {
                        context.report({
                            node: functionNode.returnType.typeAnnotation,
                            messageId: 'voidReturnProperty',
                        });
                    }
                    else {
                        context.report({
                            loc: (0, util_1.getFunctionHeadLoc)(functionNode, context.sourceCode),
                            messageId: 'voidReturnProperty',
                        });
                    }
                }
                return;
            }
        }
        function checkReturnStatement(node) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            if (tsNode.expression == null || node.argument == null) {
                return;
            }
            // syntactically ignore some known-good cases to avoid touching type info
            const functionNode = (() => {
                let current = node.parent;
                while (current && !(0, util_1.isFunction)(current)) {
                    current = current.parent;
                }
                return (0, util_1.nullThrows)(current, util_1.NullThrowsReasons.MissingParent);
            })();
            if (functionNode.returnType &&
                !isPossiblyFunctionType(functionNode.returnType)) {
                return;
            }
            const contextualType = checker.getContextualType(tsNode.expression);
            if (contextualType != null &&
                isVoidReturningFunctionType(checker, tsNode.expression, contextualType) &&
                returnsThenable(checker, tsNode.expression)) {
                context.report({
                    node: node.argument,
                    messageId: 'voidReturnReturnValue',
                });
            }
        }
        function isPromiseFinallyMethod(node) {
            const promiseFinallyCall = (0, promiseUtils_1.parseFinallyCall)(node, context);
            return (promiseFinallyCall != null &&
                (0, util_1.isPromiseLike)(services.program, (0, util_1.getConstrainedTypeAtLocation)(services, promiseFinallyCall.object)));
        }
        function checkClassLikeOrInterfaceNode(node) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            const heritageTypes = getHeritageTypes(checker, tsNode);
            if (!heritageTypes?.length) {
                return;
            }
            for (const nodeMember of tsNode.members) {
                const memberName = nodeMember.name?.getText();
                if (memberName == null) {
                    // Call/construct/index signatures don't have names. TS allows call signatures to mismatch,
                    // and construct signatures can't be async.
                    // TODO - Once we're able to use `checker.isTypeAssignableTo` (v8), we can check an index
                    // signature here against its compatible index signatures in `heritageTypes`
                    continue;
                }
                if (!returnsThenable(checker, nodeMember)) {
                    continue;
                }
                const node = services.tsNodeToESTreeNodeMap.get(nodeMember);
                if (isStaticMember(node)) {
                    continue;
                }
                for (const heritageType of heritageTypes) {
                    checkHeritageTypeForMemberReturningVoid(nodeMember, heritageType, memberName);
                }
            }
        }
        /**
         * Checks `heritageType` for a member named `memberName` that returns void; reports the
         * 'voidReturnInheritedMethod' message if found.
         * @param nodeMember Node member that returns a Promise
         * @param heritageType Heritage type to check against
         * @param memberName Name of the member to check for
         */
        function checkHeritageTypeForMemberReturningVoid(nodeMember, heritageType, memberName) {
            const heritageMember = getMemberIfExists(heritageType, memberName);
            if (heritageMember == null) {
                return;
            }
            const memberType = checker.getTypeOfSymbolAtLocation(heritageMember, nodeMember);
            if (!isVoidReturningFunctionType(checker, nodeMember, memberType)) {
                return;
            }
            context.report({
                node: services.tsNodeToESTreeNodeMap.get(nodeMember),
                messageId: 'voidReturnInheritedMethod',
                data: { heritageTypeName: checker.typeToString(heritageType) },
            });
        }
        function checkJSXAttribute(node) {
            if (node.value?.type !== utils_1.AST_NODE_TYPES.JSXExpressionContainer) {
                return;
            }
            const expressionContainer = services.esTreeNodeToTSNodeMap.get(node.value);
            const expression = services.esTreeNodeToTSNodeMap.get(node.value.expression);
            const contextualType = checker.getContextualType(expressionContainer);
            if (contextualType != null &&
                isVoidReturningFunctionType(checker, expressionContainer, contextualType) &&
                returnsThenable(checker, expression)) {
                context.report({
                    node: node.value,
                    messageId: 'voidReturnAttribute',
                });
            }
        }
        function checkSpread(node) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            if (isSometimesThenable(checker, tsNode.expression)) {
                context.report({
                    node: node.argument,
                    messageId: 'spread',
                });
            }
        }
        return {
            ...(checksConditionals ? conditionalChecks : {}),
            ...(checksVoidReturn ? voidReturnChecks : {}),
            ...(checksSpreads ? spreadChecks : {}),
        };
    },
});
function isSometimesThenable(checker, node) {
    const type = checker.getTypeAtLocation(node);
    for (const subType of tsutils.unionConstituents(checker.getApparentType(type))) {
        if (tsutils.isThenableType(checker, node, subType)) {
            return true;
        }
    }
    return false;
}
// Variation on the thenable check which requires all forms of the type (read:
// alternates in a union) to be thenable. Otherwise, you might be trying to
// check if something is defined or undefined and get caught because one of the
// branches is thenable.
function isAlwaysThenable(checker, node) {
    const type = checker.getTypeAtLocation(node);
    for (const subType of tsutils.unionConstituents(checker.getApparentType(type))) {
        const thenProp = subType.getProperty('then');
        // If one of the alternates has no then property, it is not thenable in all
        // cases.
        if (thenProp == null) {
            return false;
        }
        // We walk through each variation of the then property. Since we know it
        // exists at this point, we just need at least one of the alternates to
        // be of the right form to consider it thenable.
        const thenType = checker.getTypeOfSymbolAtLocation(thenProp, node);
        let hasThenableSignature = false;
        for (const subType of tsutils.unionConstituents(thenType)) {
            for (const signature of subType.getCallSignatures()) {
                if (signature.parameters.length !== 0 &&
                    isFunctionParam(checker, signature.parameters[0], node)) {
                    hasThenableSignature = true;
                    break;
                }
            }
            // We only need to find one variant of the then property that has a
            // function signature for it to be thenable.
            if (hasThenableSignature) {
                break;
            }
        }
        // If no flavors of the then property are thenable, we don't consider the
        // overall type to be thenable
        if (!hasThenableSignature) {
            return false;
        }
    }
    // If all variants are considered thenable (i.e. haven't returned false), we
    // consider the overall type thenable
    return true;
}
function isFunctionParam(checker, param, node) {
    const type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));
    for (const subType of tsutils.unionConstituents(type)) {
        if (subType.getCallSignatures().length !== 0) {
            return true;
        }
    }
    return false;
}
function checkThenableOrVoidArgument(checker, node, type, index, thenableReturnIndices, voidReturnIndices) {
    if (isThenableReturningFunctionType(checker, node.expression, type)) {
        thenableReturnIndices.add(index);
    }
    else if (isVoidReturningFunctionType(checker, node.expression, type) &&
        // If a certain argument accepts both thenable and void returns,
        // a promise-returning function is valid
        !thenableReturnIndices.has(index)) {
        voidReturnIndices.add(index);
    }
    const contextualType = checker.getContextualTypeForArgumentAtIndex(node, index);
    if (contextualType !== type) {
        checkThenableOrVoidArgument(checker, node, contextualType, index, thenableReturnIndices, voidReturnIndices);
    }
}
// Get the positions of arguments which are void functions (and not also
// thenable functions). These are the candidates for the void-return check at
// the current call site.
// If the function parameters end with a 'rest' parameter, then we consider
// the array type parameter (e.g. '...args:Array<SomeType>') when determining
// if trailing arguments are candidates.
function voidFunctionArguments(checker, node) {
    // 'new' can be used without any arguments, as in 'let b = new Object;'
    // In this case, there are no argument positions to check, so return early.
    if (!node.arguments) {
        return new Set();
    }
    const thenableReturnIndices = new Set();
    const voidReturnIndices = new Set();
    const type = checker.getTypeAtLocation(node.expression);
    // We can't use checker.getResolvedSignature because it prefers an early '() => void' over a later '() => Promise<void>'
    // See https://github.com/microsoft/TypeScript/issues/48077
    for (const subType of tsutils.unionConstituents(type)) {
        // Standard function calls and `new` have two different types of signatures
        const signatures = ts.isCallExpression(node)
            ? subType.getCallSignatures()
            : subType.getConstructSignatures();
        for (const signature of signatures) {
            for (const [index, parameter] of signature.parameters.entries()) {
                const decl = parameter.valueDeclaration;
                let type = checker.getTypeOfSymbolAtLocation(parameter, node.expression);
                // If this is a array 'rest' parameter, check all of the argument indices
                // from the current argument to the end.
                if (decl && (0, util_1.isRestParameterDeclaration)(decl)) {
                    if (checker.isArrayType(type)) {
                        // Unwrap 'Array<MaybeVoidFunction>' to 'MaybeVoidFunction',
                        // so that we'll handle it in the same way as a non-rest
                        // 'param: MaybeVoidFunction'
                        type = checker.getTypeArguments(type)[0];
                        for (let i = index; i < node.arguments.length; i++) {
                            checkThenableOrVoidArgument(checker, node, type, i, thenableReturnIndices, voidReturnIndices);
                        }
                    }
                    else if (checker.isTupleType(type)) {
                        // Check each type in the tuple - for example, [boolean, () => void] would
                        // add the index of the second tuple parameter to 'voidReturnIndices'
                        const typeArgs = checker.getTypeArguments(type);
                        for (let i = index; i < node.arguments.length && i - index < typeArgs.length; i++) {
                            checkThenableOrVoidArgument(checker, node, typeArgs[i - index], i, thenableReturnIndices, voidReturnIndices);
                        }
                    }
                }
                else {
                    checkThenableOrVoidArgument(checker, node, type, index, thenableReturnIndices, voidReturnIndices);
                }
            }
        }
    }
    for (const index of thenableReturnIndices) {
        voidReturnIndices.delete(index);
    }
    return voidReturnIndices;
}
/**
 * @returns Whether any call signature of the type has a thenable return type.
 */
function anySignatureIsThenableType(checker, node, type) {
    for (const signature of type.getCallSignatures()) {
        const returnType = signature.getReturnType();
        if (tsutils.isThenableType(checker, node, returnType)) {
            return true;
        }
    }
    return false;
}
/**
 * @returns Whether type is a thenable-returning function.
 */
function isThenableReturningFunctionType(checker, node, type) {
    for (const subType of tsutils.unionConstituents(type)) {
        if (anySignatureIsThenableType(checker, node, subType)) {
            return true;
        }
    }
    return false;
}
/**
 * @returns Whether type is a void-returning function.
 */
function isVoidReturningFunctionType(checker, node, type) {
    let hadVoidReturn = false;
    for (const subType of tsutils.unionConstituents(type)) {
        for (const signature of subType.getCallSignatures()) {
            const returnType = signature.getReturnType();
            // If a certain positional argument accepts both thenable and void returns,
            // a promise-returning function is valid
            if (tsutils.isThenableType(checker, node, returnType)) {
                return false;
            }
            hadVoidReturn ||= tsutils.isTypeFlagSet(returnType, ts.TypeFlags.Void);
        }
    }
    return hadVoidReturn;
}
/**
 * @returns Whether expression is a function that returns a thenable.
 */
function returnsThenable(checker, node) {
    const type = checker.getApparentType(checker.getTypeAtLocation(node));
    return tsutils
        .unionConstituents(type)
        .some(t => anySignatureIsThenableType(checker, node, t));
}
function getHeritageTypes(checker, tsNode) {
    return tsNode.heritageClauses
        ?.flatMap(clause => clause.types)
        .map(typeExpression => checker.getTypeAtLocation(typeExpression));
}
/**
 * @returns The member with the given name in `type`, if it exists.
 */
function getMemberIfExists(type, memberName) {
    const escapedMemberName = ts.escapeLeadingUnderscores(memberName);
    const symbolMemberMatch = type.getSymbol()?.members?.get(escapedMemberName);
    return (symbolMemberMatch ?? tsutils.getPropertyOfType(type, escapedMemberName));
}
function isStaticMember(node) {
    return ((node.type === utils_1.AST_NODE_TYPES.MethodDefinition ||
        node.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||
        node.type === utils_1.AST_NODE_TYPES.AccessorProperty) &&
        node.static);
}


--------------------------------------------------------------------------------
FILE: no-misused-spread.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
import type { TypeOrValueSpecifier } from '../util';
type Options = [
    {
        allow?: TypeOrValueSpecifier[];
    }
];
type MessageIds = 'addAwait' | 'noArraySpreadInObject' | 'noClassDeclarationSpreadInObject' | 'noClassInstanceSpreadInObject' | 'noFunctionSpreadInObject' | 'noIterableSpreadInObject' | 'noMapSpreadInObject' | 'noPromiseSpreadInObject' | 'noStringSpread' | 'replaceMapSpreadInObject';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-misused-spread.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-misused-spread',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow using the spread operator when it might cause unexpected behavior',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            addAwait: 'Add await operator.',
            noArraySpreadInObject: 'Using the spread operator on an array in an object will result in a list of indices.',
            noClassDeclarationSpreadInObject: 'Using the spread operator on class declarations will spread only their static properties, and will lose their class prototype.',
            noClassInstanceSpreadInObject: 'Using the spread operator on class instances will lose their class prototype.',
            noFunctionSpreadInObject: 'Using the spread operator on a function without additional properties can cause unexpected behavior. Did you forget to call the function?',
            noIterableSpreadInObject: 'Using the spread operator on an Iterable in an object can cause unexpected behavior.',
            noMapSpreadInObject: 'Using the spread operator on a Map in an object will result in an empty object. Did you mean to use `Object.fromEntries(map)` instead?',
            noPromiseSpreadInObject: 'Using the spread operator on Promise in an object can cause unexpected behavior. Did you forget to await the promise?',
            noStringSpread: [
                'Using the spread operator on a string can mishandle special characters, as can `.split("")`.',
                '- `...` produces Unicode code points, which will decompose complex emojis into individual emojis',
                '- .split("") produces UTF-16 code units, which breaks rich characters in many languages',
                'Consider using `Intl.Segmenter` for locale-aware string decomposition.',
                "Otherwise, if you don't need to preserve emojis or other non-Ascii characters, disable this lint rule on this line or configure the 'allow' rule option.",
            ].join('\n'),
            replaceMapSpreadInObject: 'Replace map spread in object with `Object.fromEntries()`',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allow: {
                        ...util_1.readonlynessOptionsSchema.properties.allow,
                        description: 'An array of type specifiers that are known to be safe to spread.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allow: [],
        },
    ],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function checkArrayOrCallSpread(node) {
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node.argument);
            if (!(0, util_1.typeMatchesSomeSpecifier)(type, options.allow, services.program) &&
                isString(type)) {
                context.report({
                    node,
                    messageId: 'noStringSpread',
                });
            }
        }
        function getMapSpreadSuggestions(node, type) {
            const types = tsutils.unionConstituents(type);
            if (types.some(t => !isMap(services.program, t))) {
                return null;
            }
            if (node.parent.type === utils_1.AST_NODE_TYPES.ObjectExpression &&
                node.parent.properties.length === 1) {
                return [
                    {
                        messageId: 'replaceMapSpreadInObject',
                        fix: (0, util_1.getWrappingFixer)({
                            node: node.parent,
                            innerNode: node.argument,
                            sourceCode: context.sourceCode,
                            wrap: code => `Object.fromEntries(${code})`,
                        }),
                    },
                ];
            }
            return [
                {
                    messageId: 'replaceMapSpreadInObject',
                    fix: (0, util_1.getWrappingFixer)({
                        node: node.argument,
                        sourceCode: context.sourceCode,
                        wrap: code => `Object.fromEntries(${code})`,
                    }),
                },
            ];
        }
        function getPromiseSpreadSuggestions(node) {
            const isHighPrecedence = (0, util_1.isHigherPrecedenceThanAwait)(services.esTreeNodeToTSNodeMap.get(node));
            return [
                {
                    messageId: 'addAwait',
                    fix: fixer => isHighPrecedence
                        ? fixer.insertTextBefore(node, 'await ')
                        : [
                            fixer.insertTextBefore(node, 'await ('),
                            fixer.insertTextAfter(node, ')'),
                        ],
                },
            ];
        }
        function checkObjectSpread(node) {
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node.argument);
            if ((0, util_1.typeMatchesSomeSpecifier)(type, options.allow, services.program)) {
                return;
            }
            if (isPromise(services.program, type)) {
                context.report({
                    node,
                    messageId: 'noPromiseSpreadInObject',
                    suggest: getPromiseSpreadSuggestions(node.argument),
                });
                return;
            }
            if (isFunctionWithoutProps(type)) {
                context.report({
                    node,
                    messageId: 'noFunctionSpreadInObject',
                });
                return;
            }
            if (isMap(services.program, type)) {
                context.report({
                    node,
                    messageId: 'noMapSpreadInObject',
                    suggest: getMapSpreadSuggestions(node, type),
                });
                return;
            }
            if (isArray(checker, type)) {
                context.report({
                    node,
                    messageId: 'noArraySpreadInObject',
                });
                return;
            }
            if (isIterable(type, checker) &&
                // Don't report when the type is string, since TS will flag it already
                !isString(type)) {
                context.report({
                    node,
                    messageId: 'noIterableSpreadInObject',
                });
                return;
            }
            if (isClassInstance(checker, type)) {
                context.report({
                    node,
                    messageId: 'noClassInstanceSpreadInObject',
                });
                return;
            }
            if (isClassDeclaration(type)) {
                context.report({
                    node,
                    messageId: 'noClassDeclarationSpreadInObject',
                });
            }
        }
        return {
            'ArrayExpression > SpreadElement': checkArrayOrCallSpread,
            'CallExpression > SpreadElement': checkArrayOrCallSpread,
            JSXSpreadAttribute: checkObjectSpread,
            'ObjectExpression > SpreadElement': checkObjectSpread,
        };
    },
});
function isIterable(type, checker) {
    return tsutils
        .typeConstituents(type)
        .some(t => !!tsutils.getWellKnownSymbolPropertyOfType(t, 'iterator', checker));
}
function isArray(checker, type) {
    return isTypeRecurser(type, t => checker.isArrayType(t) || checker.isTupleType(t));
}
function isString(type) {
    return isTypeRecurser(type, t => (0, util_1.isTypeFlagSet)(t, ts.TypeFlags.StringLike));
}
function isFunctionWithoutProps(type) {
    return isTypeRecurser(type, t => t.getCallSignatures().length > 0 && t.getProperties().length === 0);
}
function isPromise(program, type) {
    return isTypeRecurser(type, t => (0, util_1.isPromiseLike)(program, t));
}
function isClassInstance(checker, type) {
    return isTypeRecurser(type, t => {
        // If the type itself has a construct signature, it's a class(-like)
        if (t.getConstructSignatures().length) {
            return false;
        }
        const symbol = t.getSymbol();
        // If the type's symbol has a construct signature, the type is an instance
        return !!symbol
            ?.getDeclarations()
            ?.some(declaration => checker
            .getTypeOfSymbolAtLocation(symbol, declaration)
            .getConstructSignatures().length);
    });
}
function isClassDeclaration(type) {
    return isTypeRecurser(type, t => {
        if (tsutils.isObjectType(t) &&
            tsutils.isObjectFlagSet(t, ts.ObjectFlags.InstantiationExpressionType)) {
            return true;
        }
        const kind = t.getSymbol()?.valueDeclaration?.kind;
        return (kind === ts.SyntaxKind.ClassDeclaration ||
            kind === ts.SyntaxKind.ClassExpression);
    });
}
function isMap(program, type) {
    return isTypeRecurser(type, t => (0, util_1.isBuiltinSymbolLike)(program, t, ['Map', 'ReadonlyMap', 'WeakMap']));
}
function isTypeRecurser(type, predicate) {
    if (type.isUnionOrIntersection()) {
        return type.types.some(t => isTypeRecurser(t, predicate));
    }
    return predicate(type);
}


--------------------------------------------------------------------------------
FILE: no-mixed-enums.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"mixed", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-mixed-enums.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
var AllowedType;
(function (AllowedType) {
    AllowedType[AllowedType["Number"] = 0] = "Number";
    AllowedType[AllowedType["String"] = 1] = "String";
    AllowedType[AllowedType["Unknown"] = 2] = "Unknown";
})(AllowedType || (AllowedType = {}));
exports.default = (0, util_1.createRule)({
    name: 'no-mixed-enums',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow enums from having both number and string members',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        messages: {
            mixed: `Mixing number and string enums can be confusing.`,
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const parserServices = (0, util_1.getParserServices)(context);
        const typeChecker = parserServices.program.getTypeChecker();
        function collectNodeDefinitions(node) {
            const { name } = node.id;
            const found = {
                imports: [],
                previousSibling: undefined,
            };
            let scope = context.sourceCode.getScope(node);
            for (const definition of scope.upper?.set.get(name)?.defs ?? []) {
                if (definition.node.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration &&
                    definition.node.range[0] < node.range[0] &&
                    definition.node.body.members.length > 0) {
                    found.previousSibling = definition.node;
                    break;
                }
            }
            while (scope) {
                scope.set.get(name)?.defs.forEach(definition => {
                    if (definition.type === scope_manager_1.DefinitionType.ImportBinding) {
                        found.imports.push(definition.node);
                    }
                });
                scope = scope.upper;
            }
            return found;
        }
        function getAllowedTypeForNode(node) {
            return tsutils.isTypeFlagSet(typeChecker.getTypeAtLocation(node), ts.TypeFlags.StringLike)
                ? AllowedType.String
                : AllowedType.Number;
        }
        function getTypeFromImported(imported) {
            const type = typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(imported));
            const valueDeclaration = type.getSymbol()?.valueDeclaration;
            if (!valueDeclaration ||
                !ts.isEnumDeclaration(valueDeclaration) ||
                valueDeclaration.members.length === 0) {
                return undefined;
            }
            return getAllowedTypeForNode(valueDeclaration.members[0]);
        }
        function getMemberType(member) {
            if (!member.initializer) {
                return AllowedType.Number;
            }
            switch (member.initializer.type) {
                case utils_1.AST_NODE_TYPES.Literal:
                    switch (typeof member.initializer.value) {
                        case 'number':
                            return AllowedType.Number;
                        case 'string':
                            return AllowedType.String;
                        default:
                            return AllowedType.Unknown;
                    }
                case utils_1.AST_NODE_TYPES.TemplateLiteral:
                    return AllowedType.String;
                default:
                    return getAllowedTypeForNode(parserServices.esTreeNodeToTSNodeMap.get(member.initializer));
            }
        }
        function getDesiredTypeForDefinition(node) {
            const { imports, previousSibling } = collectNodeDefinitions(node);
            // Case: Merged ambiently via module augmentation
            // import { MyEnum } from 'other-module';
            // declare module 'other-module' {
            //   enum MyEnum { A }
            // }
            for (const imported of imports) {
                const typeFromImported = getTypeFromImported(imported);
                if (typeFromImported != null) {
                    return typeFromImported;
                }
            }
            // Case: Multiple enum declarations in the same file
            // enum MyEnum { A }
            // enum MyEnum { B }
            if (previousSibling) {
                return getMemberType(previousSibling.body.members[0]);
            }
            // Case: Namespace declaration merging
            // namespace MyNamespace {
            //   export enum MyEnum { A }
            // }
            // namespace MyNamespace {
            //   export enum MyEnum { B }
            // }
            if (node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration &&
                node.parent.parent.type === utils_1.AST_NODE_TYPES.TSModuleBlock) {
                // https://github.com/typescript-eslint/typescript-eslint/issues/8352
                // TODO: We don't need to dip into the TypeScript type checker here!
                // Merged namespaces must all exist in the same file.
                // We could instead compare this file's nodes to find the merges.
                const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node.id);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const declarations = typeChecker
                    .getSymbolAtLocation(tsNode)
                    .getDeclarations();
                const [{ initializer }] = declarations[0]
                    .members;
                return initializer &&
                    tsutils.isTypeFlagSet(typeChecker.getTypeAtLocation(initializer), ts.TypeFlags.StringLike)
                    ? AllowedType.String
                    : AllowedType.Number;
            }
            // Finally, we default to the type of the first enum member
            return getMemberType(node.body.members[0]);
        }
        return {
            TSEnumDeclaration(node) {
                if (!node.body.members.length) {
                    return;
                }
                let desiredType = getDesiredTypeForDefinition(node);
                if (desiredType === ts.TypeFlags.Unknown) {
                    return;
                }
                for (const member of node.body.members) {
                    const currentType = getMemberType(member);
                    if (currentType === AllowedType.Unknown) {
                        return;
                    }
                    if (currentType === AllowedType.Number) {
                        desiredType ??= currentType;
                    }
                    if (currentType !== desiredType) {
                        context.report({
                            node: member.initializer ?? member,
                            messageId: 'mixed',
                        });
                        return;
                    }
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-namespace.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowDeclarations?: boolean;
        allowDefinitionFiles?: boolean;
    }
];
export type MessageIds = 'moduleSyntaxIsPreferred';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"moduleSyntaxIsPreferred", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-namespace.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-namespace',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow TypeScript namespaces',
            recommended: 'recommended',
        },
        messages: {
            moduleSyntaxIsPreferred: 'ES2015 module syntax is preferred over namespaces.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowDeclarations: {
                        type: 'boolean',
                        description: 'Whether to allow `declare` with custom TypeScript namespaces.',
                    },
                    allowDefinitionFiles: {
                        type: 'boolean',
                        description: 'Whether to allow `declare` with custom TypeScript namespaces inside definition files.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowDeclarations: false,
            allowDefinitionFiles: true,
        },
    ],
    create(context, [{ allowDeclarations, allowDefinitionFiles }]) {
        function isDeclaration(node) {
            if (node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration && node.declare) {
                return true;
            }
            return node.parent != null && isDeclaration(node.parent);
        }
        return {
            "TSModuleDeclaration[global!=true][id.type!='Literal']"(node) {
                if (node.parent.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration ||
                    (allowDefinitionFiles && (0, util_1.isDefinitionFile)(context.filename)) ||
                    (allowDeclarations && isDeclaration(node))) {
                    return;
                }
                context.report({
                    node,
                    messageId: 'moduleSyntaxIsPreferred',
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-non-null-asserted-nullish-coalescing.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"noNonNullAssertedNullishCoalescing" | "suggestRemovingNonNull", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-non-null-asserted-nullish-coalescing.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
function hasAssignmentBeforeNode(variable, node) {
    return (variable.references.some(ref => ref.isWrite() && ref.identifier.range[1] < node.range[1]) ||
        variable.defs.some(def => isDefinitionWithAssignment(def) && def.node.range[1] < node.range[1]));
}
function isDefinitionWithAssignment(definition) {
    if (definition.type !== scope_manager_1.DefinitionType.Variable) {
        return false;
    }
    const variableDeclarator = definition.node;
    return variableDeclarator.definite || variableDeclarator.init != null;
}
exports.default = (0, util_1.createRule)({
    name: 'no-non-null-asserted-nullish-coalescing',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow non-null assertions in the left operand of a nullish coalescing operator',
            recommended: 'strict',
        },
        hasSuggestions: true,
        messages: {
            noNonNullAssertedNullishCoalescing: 'The nullish coalescing operator is designed to handle undefined and null - using a non-null assertion is not needed.',
            suggestRemovingNonNull: 'Remove the non-null assertion.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            'LogicalExpression[operator = "??"] > TSNonNullExpression.left'(node) {
                if (node.expression.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
                    const scope = context.sourceCode.getScope(node);
                    const identifier = node.expression;
                    const variable = utils_1.ASTUtils.findVariable(scope, identifier.name);
                    if (variable && !hasAssignmentBeforeNode(variable, node)) {
                        return;
                    }
                }
                context.report({
                    node,
                    messageId: 'noNonNullAssertedNullishCoalescing',
                    /*
                    Use a suggestion instead of a fixer, because this can break type checks.
                    The resulting type of the nullish coalesce is only influenced by the right operand if the left operand can be `null` or `undefined`.
                    After removing the non-null assertion the type of the left operand might contain `null` or `undefined` and then the type of the right operand
                    might change the resulting type of the nullish coalesce.
                    See the following example:
          
                    function test(x?: string): string {
                      const bar = x! ?? false; // type analysis reports `bar` has type `string`
                      //          x  ?? false; // type analysis reports `bar` has type `string | false`
                      return bar;
                    }
                    */
                    suggest: [
                        {
                            messageId: 'suggestRemovingNonNull',
                            fix(fixer) {
                                const exclamationMark = (0, util_1.nullThrows)(context.sourceCode.getLastToken(node, utils_1.ASTUtils.isNonNullAssertionPunctuator), util_1.NullThrowsReasons.MissingToken('!', 'Non-null Assertion'));
                                return fixer.remove(exclamationMark);
                            },
                        },
                    ],
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-non-null-asserted-optional-chain.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"suggestRemovingNonNull" | "noNonNullOptionalChain", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-non-null-asserted-optional-chain.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-non-null-asserted-optional-chain',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow non-null assertions after an optional chain expression',
            recommended: 'recommended',
        },
        hasSuggestions: true,
        messages: {
            noNonNullOptionalChain: 'Optional chain expressions can return undefined by design - using a non-null assertion is unsafe and wrong.',
            suggestRemovingNonNull: 'You should remove the non-null assertion.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            // non-nulling a wrapped chain will scrub all nulls introduced by the chain
            // (x?.y)!
            // (x?.())!
            'TSNonNullExpression > ChainExpression'(node) {
                // selector guarantees this assertion
                const parent = node.parent;
                context.report({
                    node,
                    messageId: 'noNonNullOptionalChain',
                    // use a suggestion instead of a fixer, because this can obviously break type checks
                    suggest: [
                        {
                            messageId: 'suggestRemovingNonNull',
                            fix(fixer) {
                                return fixer.removeRange([
                                    parent.range[1] - 1,
                                    parent.range[1],
                                ]);
                            },
                        },
                    ],
                });
            },
            // non-nulling at the end of a chain will scrub all nulls introduced by the chain
            // x?.y!
            // x?.()!
            'ChainExpression > TSNonNullExpression'(node) {
                context.report({
                    node,
                    messageId: 'noNonNullOptionalChain',
                    // use a suggestion instead of a fixer, because this can obviously break type checks
                    suggest: [
                        {
                            messageId: 'suggestRemovingNonNull',
                            fix(fixer) {
                                return fixer.removeRange([node.range[1] - 1, node.range[1]]);
                            },
                        },
                    ],
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-non-null-assertion.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageIds = 'noNonNull' | 'suggestOptionalChain';
declare const _default: TSESLint.RuleModule<MessageIds, [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-non-null-assertion.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-non-null-assertion',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow non-null assertions using the `!` postfix operator',
            recommended: 'strict',
        },
        hasSuggestions: true,
        messages: {
            noNonNull: 'Forbidden non-null assertion.',
            suggestOptionalChain: 'Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            TSNonNullExpression(node) {
                const suggest = [];
                // it always exists in non-null assertion
                const nonNullOperator = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.expression, util_1.isNonNullAssertionPunctuator), util_1.NullThrowsReasons.MissingToken('!', 'expression'));
                function replaceTokenWithOptional() {
                    return fixer => fixer.replaceText(nonNullOperator, '?.');
                }
                function removeToken() {
                    return fixer => fixer.remove(nonNullOperator);
                }
                if (node.parent.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                    node.parent.object === node &&
                    !(0, util_1.isAssignee)(node.parent)) {
                    if (!node.parent.optional) {
                        if (node.parent.computed) {
                            // it is x![y]?.z
                            suggest.push({
                                messageId: 'suggestOptionalChain',
                                fix: replaceTokenWithOptional(),
                            });
                        }
                        else {
                            // it is x!.y?.z
                            suggest.push({
                                messageId: 'suggestOptionalChain',
                                fix(fixer) {
                                    // x!.y?.z
                                    //   ^ punctuator
                                    const punctuator = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(nonNullOperator), util_1.NullThrowsReasons.MissingToken('.', '!'));
                                    return [
                                        fixer.remove(nonNullOperator),
                                        fixer.insertTextBefore(punctuator, '?'),
                                    ];
                                },
                            });
                        }
                    }
                    else {
                        // it is x!?.[y].z or  x!?.y.z
                        suggest.push({
                            messageId: 'suggestOptionalChain',
                            fix: removeToken(),
                        });
                    }
                }
                else if (node.parent.type === utils_1.AST_NODE_TYPES.CallExpression &&
                    node.parent.callee === node) {
                    if (!node.parent.optional) {
                        // it is x.y?.z!()
                        suggest.push({
                            messageId: 'suggestOptionalChain',
                            fix: replaceTokenWithOptional(),
                        });
                    }
                    else {
                        // it is x.y.z!?.()
                        suggest.push({
                            messageId: 'suggestOptionalChain',
                            fix: removeToken(),
                        });
                    }
                }
                context.report({
                    node,
                    messageId: 'noNonNull',
                    suggest,
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-redeclare.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageIds = 'redeclared' | 'redeclaredAsBuiltin' | 'redeclaredBySyntax';
export type Options = [
    {
        builtinGlobals?: boolean;
        ignoreDeclarationMerge?: boolean;
    }
];
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-redeclare.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-redeclare',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow variable redeclaration',
            extendsBaseRule: true,
        },
        messages: {
            redeclared: "'{{id}}' is already defined.",
            redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.",
            redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    builtinGlobals: {
                        type: 'boolean',
                        description: 'Whether to report shadowing of built-in global variables.',
                    },
                    ignoreDeclarationMerge: {
                        type: 'boolean',
                        description: 'Whether to ignore declaration merges between certain TypeScript declaration types.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            builtinGlobals: true,
            ignoreDeclarationMerge: true,
        },
    ],
    create(context, [options]) {
        const CLASS_DECLARATION_MERGE_NODES = new Set([
            utils_1.AST_NODE_TYPES.ClassDeclaration,
            utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,
            utils_1.AST_NODE_TYPES.TSModuleDeclaration,
        ]);
        const FUNCTION_DECLARATION_MERGE_NODES = new Set([
            utils_1.AST_NODE_TYPES.FunctionDeclaration,
            utils_1.AST_NODE_TYPES.TSModuleDeclaration,
        ]);
        const ENUM_DECLARATION_MERGE_NODES = new Set([
            utils_1.AST_NODE_TYPES.TSEnumDeclaration,
            utils_1.AST_NODE_TYPES.TSModuleDeclaration,
        ]);
        function* iterateDeclarations(variable) {
            if (options.builtinGlobals &&
                'eslintImplicitGlobalSetting' in variable &&
                (variable.eslintImplicitGlobalSetting === 'readonly' ||
                    variable.eslintImplicitGlobalSetting === 'writable')) {
                yield { type: 'builtin' };
            }
            if ('eslintExplicitGlobalComments' in variable &&
                variable.eslintExplicitGlobalComments) {
                for (const comment of variable.eslintExplicitGlobalComments) {
                    yield {
                        loc: (0, util_1.getNameLocationInGlobalDirectiveComment)(context.sourceCode, comment, variable.name),
                        node: comment,
                        type: 'comment',
                    };
                }
            }
            const identifiers = variable.identifiers
                .map(id => ({
                identifier: id,
                parent: id.parent,
            }))
                // ignore function declarations because TS will treat them as an overload
                .filter(({ parent }) => parent.type !== utils_1.AST_NODE_TYPES.TSDeclareFunction);
            if (options.ignoreDeclarationMerge && identifiers.length > 1) {
                if (
                // interfaces merging
                identifiers.every(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration)) {
                    return;
                }
                if (
                // namespace/module merging
                identifiers.every(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration)) {
                    return;
                }
                if (
                // class + interface/namespace merging
                identifiers.every(({ parent }) => CLASS_DECLARATION_MERGE_NODES.has(parent.type))) {
                    const classDecls = identifiers.filter(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.ClassDeclaration);
                    if (classDecls.length === 1) {
                        // safe declaration merging
                        return;
                    }
                    // there's more than one class declaration, which needs to be reported
                    for (const { identifier } of classDecls) {
                        yield { loc: identifier.loc, node: identifier, type: 'syntax' };
                    }
                    return;
                }
                if (
                // class + interface/namespace merging
                identifiers.every(({ parent }) => FUNCTION_DECLARATION_MERGE_NODES.has(parent.type))) {
                    const functionDecls = identifiers.filter(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.FunctionDeclaration);
                    if (functionDecls.length === 1) {
                        // safe declaration merging
                        return;
                    }
                    // there's more than one function declaration, which needs to be reported
                    for (const { identifier } of functionDecls) {
                        yield { loc: identifier.loc, node: identifier, type: 'syntax' };
                    }
                    return;
                }
                if (
                // enum + namespace merging
                identifiers.every(({ parent }) => ENUM_DECLARATION_MERGE_NODES.has(parent.type))) {
                    const enumDecls = identifiers.filter(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration);
                    if (enumDecls.length === 1) {
                        // safe declaration merging
                        return;
                    }
                    // there's more than one enum declaration, which needs to be reported
                    for (const { identifier } of enumDecls) {
                        yield { loc: identifier.loc, node: identifier, type: 'syntax' };
                    }
                    return;
                }
            }
            for (const { identifier } of identifiers) {
                yield { loc: identifier.loc, node: identifier, type: 'syntax' };
            }
        }
        function findVariablesInScope(scope) {
            for (const variable of scope.variables) {
                const [declaration, ...extraDeclarations] = iterateDeclarations(variable);
                if (extraDeclarations.length === 0) {
                    continue;
                }
                /*
                 * If the type of a declaration is different from the type of
                 * the first declaration, it shows the location of the first
                 * declaration.
                 */
                const detailMessageId = declaration.type === 'builtin'
                    ? 'redeclaredAsBuiltin'
                    : 'redeclaredBySyntax';
                const data = { id: variable.name };
                // Report extra declarations.
                for (const { loc, node, type } of extraDeclarations) {
                    const messageId = type === declaration.type ? 'redeclared' : detailMessageId;
                    if (node) {
                        context.report({ loc, node, messageId, data });
                    }
                    else if (loc) {
                        context.report({ loc, messageId, data });
                    }
                }
            }
        }
        /**
         * Find variables in the current scope.
         */
        function checkForBlock(node) {
            const scope = context.sourceCode.getScope(node);
            /*
             * In ES5, some node type such as `BlockStatement` doesn't have that scope.
             * `scope.block` is a different node in such a case.
             */
            if (scope.block === node) {
                findVariablesInScope(scope);
            }
        }
        return {
            ArrowFunctionExpression: checkForBlock,
            BlockStatement: checkForBlock,
            ForInStatement: checkForBlock,
            ForOfStatement: checkForBlock,
            ForStatement: checkForBlock,
            FunctionDeclaration: checkForBlock,
            FunctionExpression: checkForBlock,
            Program(node) {
                const scope = context.sourceCode.getScope(node);
                findVariablesInScope(scope);
                // Node.js or ES modules has a special scope.
                if (scope.type === scope_manager_1.ScopeType.global &&
                    // The special scope's block is the Program node.
                    scope.block === scope.childScopes[0]?.block) {
                    findVariablesInScope(scope.childScopes[0]);
                }
            },
            SwitchStatement: checkForBlock,
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-redundant-type-constituents.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"overrides" | "errorTypeOverrides" | "literalOverridden" | "overridden" | "primitiveOverridden", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-redundant-type-constituents.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const literalToPrimitiveTypeFlags = {
    [ts.TypeFlags.BigIntLiteral]: ts.TypeFlags.BigInt,
    [ts.TypeFlags.BooleanLiteral]: ts.TypeFlags.Boolean,
    [ts.TypeFlags.NumberLiteral]: ts.TypeFlags.Number,
    [ts.TypeFlags.StringLiteral]: ts.TypeFlags.String,
    [ts.TypeFlags.TemplateLiteral]: ts.TypeFlags.String,
};
const literalTypeFlags = [
    ts.TypeFlags.BigIntLiteral,
    ts.TypeFlags.BooleanLiteral,
    ts.TypeFlags.NumberLiteral,
    ts.TypeFlags.StringLiteral,
    ts.TypeFlags.TemplateLiteral,
];
const primitiveTypeFlags = [
    ts.TypeFlags.BigInt,
    ts.TypeFlags.Boolean,
    ts.TypeFlags.Number,
    ts.TypeFlags.String,
];
const primitiveTypeFlagNames = {
    [ts.TypeFlags.BigInt]: 'bigint',
    [ts.TypeFlags.Boolean]: 'boolean',
    [ts.TypeFlags.Number]: 'number',
    [ts.TypeFlags.String]: 'string',
};
const primitiveTypeFlagTypes = {
    bigint: ts.TypeFlags.BigIntLiteral,
    boolean: ts.TypeFlags.BooleanLiteral,
    number: ts.TypeFlags.NumberLiteral,
    string: ts.TypeFlags.StringLiteral,
};
const keywordNodeTypesToTsTypes = new Map([
    [utils_1.TSESTree.AST_NODE_TYPES.TSAnyKeyword, ts.TypeFlags.Any],
    [utils_1.TSESTree.AST_NODE_TYPES.TSBigIntKeyword, ts.TypeFlags.BigInt],
    [utils_1.TSESTree.AST_NODE_TYPES.TSBooleanKeyword, ts.TypeFlags.Boolean],
    [utils_1.TSESTree.AST_NODE_TYPES.TSNeverKeyword, ts.TypeFlags.Never],
    [utils_1.TSESTree.AST_NODE_TYPES.TSNumberKeyword, ts.TypeFlags.Number],
    [utils_1.TSESTree.AST_NODE_TYPES.TSStringKeyword, ts.TypeFlags.String],
    [utils_1.TSESTree.AST_NODE_TYPES.TSUnknownKeyword, ts.TypeFlags.Unknown],
]);
function addToMapGroup(map, key, value) {
    const existing = map.get(key);
    if (existing) {
        existing.push(value);
    }
    else {
        map.set(key, [value]);
    }
}
function describeLiteralType(type) {
    if (type.isStringLiteral()) {
        return JSON.stringify(type.value);
    }
    if ((0, util_1.isTypeBigIntLiteralType)(type)) {
        return `${type.value.negative ? '-' : ''}${type.value.base10Value}n`;
    }
    if (type.isLiteral()) {
        // eslint-disable-next-line @typescript-eslint/no-base-to-string
        return type.value.toString();
    }
    if (tsutils.isIntrinsicErrorType(type) && type.aliasSymbol) {
        return type.aliasSymbol.escapedName.toString();
    }
    if ((0, util_1.isTypeAnyType)(type)) {
        return 'any';
    }
    if ((0, util_1.isTypeNeverType)(type)) {
        return 'never';
    }
    if ((0, util_1.isTypeUnknownType)(type)) {
        return 'unknown';
    }
    if ((0, util_1.isTypeTemplateLiteralType)(type)) {
        return 'template literal type';
    }
    if ((0, util_1.isTypeBigIntLiteralType)(type)) {
        return `${type.value.negative ? '-' : ''}${type.value.base10Value}n`;
    }
    if (tsutils.isTrueLiteralType(type)) {
        return 'true';
    }
    if (tsutils.isFalseLiteralType(type)) {
        return 'false';
    }
    return 'literal type';
}
function describeLiteralTypeNode(typeNode) {
    switch (typeNode.type) {
        case utils_1.AST_NODE_TYPES.TSAnyKeyword:
            return 'any';
        case utils_1.AST_NODE_TYPES.TSBooleanKeyword:
            return 'boolean';
        case utils_1.AST_NODE_TYPES.TSNeverKeyword:
            return 'never';
        case utils_1.AST_NODE_TYPES.TSNumberKeyword:
            return 'number';
        case utils_1.AST_NODE_TYPES.TSStringKeyword:
            return 'string';
        case utils_1.AST_NODE_TYPES.TSUnknownKeyword:
            return 'unknown';
        case utils_1.AST_NODE_TYPES.TSLiteralType:
            switch (typeNode.literal.type) {
                case utils_1.TSESTree.AST_NODE_TYPES.Literal:
                    switch (typeof typeNode.literal.value) {
                        case 'bigint':
                            return `${typeNode.literal.value < 0 ? '-' : ''}${typeNode.literal.value}n`;
                        case 'string':
                            return JSON.stringify(typeNode.literal.value);
                        default:
                            return `${typeNode.literal.value}`;
                    }
                case utils_1.TSESTree.AST_NODE_TYPES.TemplateLiteral:
                    return 'template literal type';
            }
    }
    return 'literal type';
}
function isNodeInsideReturnType(node) {
    return (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAnnotation &&
        (0, util_1.isFunctionOrFunctionType)(node.parent.parent));
}
/**
 * @remarks TypeScript stores boolean types as the union false | true, always.
 */
function unionTypePartsUnlessBoolean(type) {
    return type.isUnion() &&
        type.types.length === 2 &&
        tsutils.isFalseLiteralType(type.types[0]) &&
        tsutils.isTrueLiteralType(type.types[1])
        ? [type]
        : tsutils.unionConstituents(type);
}
exports.default = (0, util_1.createRule)({
    name: 'no-redundant-type-constituents',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow members of unions and intersections that do nothing or override type information',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            errorTypeOverrides: `'{{typeName}}' is an 'error' type that acts as 'any' and overrides all other types in this {{container}} type.`,
            literalOverridden: `{{literal}} is overridden by {{primitive}} in this union type.`,
            overridden: `'{{typeName}}' is overridden by other types in this {{container}} type.`,
            overrides: `'{{typeName}}' overrides all other types in this {{container}} type.`,
            primitiveOverridden: `{{primitive}} is overridden by the {{literal}} in this intersection type.`,
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const typesCache = new Map();
        function getTypeNodeTypePartFlags(typeNode) {
            const keywordTypeFlags = keywordNodeTypesToTsTypes.get(typeNode.type);
            if (keywordTypeFlags) {
                return [
                    {
                        typeFlags: keywordTypeFlags,
                        typeName: describeLiteralTypeNode(typeNode),
                    },
                ];
            }
            if (typeNode.type === utils_1.AST_NODE_TYPES.TSLiteralType &&
                typeNode.literal.type === utils_1.AST_NODE_TYPES.Literal) {
                return [
                    {
                        typeFlags: primitiveTypeFlagTypes[typeof typeNode.literal
                            .value],
                        typeName: describeLiteralTypeNode(typeNode),
                    },
                ];
            }
            if (typeNode.type === utils_1.AST_NODE_TYPES.TSUnionType) {
                return typeNode.types.flatMap(getTypeNodeTypePartFlags);
            }
            const nodeType = services.getTypeAtLocation(typeNode);
            const typeParts = unionTypePartsUnlessBoolean(nodeType);
            return typeParts.map(typePart => ({
                typeFlags: typePart.flags,
                typeName: describeLiteralType(typePart),
            }));
        }
        function getTypeNodeTypePartFlagsCached(typeNode) {
            const existing = typesCache.get(typeNode);
            if (existing) {
                return existing;
            }
            const created = getTypeNodeTypePartFlags(typeNode);
            typesCache.set(typeNode, created);
            return created;
        }
        return {
            'TSIntersectionType:exit'(node) {
                const seenLiteralTypes = new Map();
                const seenPrimitiveTypes = new Map();
                const seenUnionTypes = new Map();
                function checkIntersectionBottomAndTopTypes({ typeFlags, typeName }, typeNode) {
                    for (const [messageId, checkFlag] of [
                        ['overrides', ts.TypeFlags.Any],
                        ['overrides', ts.TypeFlags.Never],
                        ['overridden', ts.TypeFlags.Unknown],
                    ]) {
                        if (typeFlags === checkFlag) {
                            context.report({
                                node: typeNode,
                                messageId: typeFlags === ts.TypeFlags.Any && typeName !== 'any'
                                    ? 'errorTypeOverrides'
                                    : messageId,
                                data: {
                                    container: 'intersection',
                                    typeName,
                                },
                            });
                            return true;
                        }
                    }
                    return false;
                }
                for (const typeNode of node.types) {
                    const typePartFlags = getTypeNodeTypePartFlagsCached(typeNode);
                    for (const typePart of typePartFlags) {
                        if (checkIntersectionBottomAndTopTypes(typePart, typeNode)) {
                            continue;
                        }
                        for (const literalTypeFlag of literalTypeFlags) {
                            if (typePart.typeFlags === literalTypeFlag) {
                                addToMapGroup(seenLiteralTypes, literalToPrimitiveTypeFlags[literalTypeFlag], typePart.typeName);
                                break;
                            }
                        }
                        for (const primitiveTypeFlag of primitiveTypeFlags) {
                            if (typePart.typeFlags === primitiveTypeFlag) {
                                addToMapGroup(seenPrimitiveTypes, primitiveTypeFlag, typeNode);
                            }
                        }
                    }
                    // if any typeNode is TSTypeReference and typePartFlags have more than 1 element, than the referenced type is definitely a union.
                    if (typePartFlags.length >= 2) {
                        seenUnionTypes.set(typeNode, typePartFlags);
                    }
                }
                /**
                 * @example
                 * ```ts
                 * type F = "a"|2|"b";
                 * type I = F & string;
                 * ```
                 * This function checks if all the union members of `F` are assignable to the other member of `I`. If every member is assignable, then its reported else not.
                 */
                const checkIfUnionsAreAssignable = () => {
                    for (const [typeRef, typeValues] of seenUnionTypes) {
                        let primitive = undefined;
                        for (const { typeFlags } of typeValues) {
                            if (seenPrimitiveTypes.has(literalToPrimitiveTypeFlags[typeFlags])) {
                                primitive =
                                    literalToPrimitiveTypeFlags[typeFlags];
                            }
                            else {
                                primitive = undefined;
                                break;
                            }
                        }
                        if (Number.isInteger(primitive)) {
                            context.report({
                                node: typeRef,
                                messageId: 'primitiveOverridden',
                                data: {
                                    literal: typeValues.map(name => name.typeName).join(' | '),
                                    primitive: primitiveTypeFlagNames[primitive],
                                },
                            });
                        }
                    }
                };
                if (seenUnionTypes.size > 0) {
                    checkIfUnionsAreAssignable();
                    return;
                }
                // For each primitive type of all the seen primitive types,
                // if there was a literal type seen that overrides it,
                // report each of the primitive type's type nodes
                for (const [primitiveTypeFlag, typeNodes] of seenPrimitiveTypes) {
                    const matchedLiteralTypes = seenLiteralTypes.get(primitiveTypeFlag);
                    if (matchedLiteralTypes) {
                        for (const typeNode of typeNodes) {
                            context.report({
                                node: typeNode,
                                messageId: 'primitiveOverridden',
                                data: {
                                    literal: matchedLiteralTypes.join(' | '),
                                    primitive: primitiveTypeFlagNames[primitiveTypeFlag],
                                },
                            });
                        }
                    }
                }
            },
            'TSUnionType:exit'(node) {
                const seenLiteralTypes = new Map();
                const seenPrimitiveTypes = new Set();
                function checkUnionBottomAndTopTypes({ typeFlags, typeName }, typeNode) {
                    for (const checkFlag of [
                        ts.TypeFlags.Any,
                        ts.TypeFlags.Unknown,
                    ]) {
                        if (typeFlags === checkFlag) {
                            context.report({
                                node: typeNode,
                                messageId: typeFlags === ts.TypeFlags.Any && typeName !== 'any'
                                    ? 'errorTypeOverrides'
                                    : 'overrides',
                                data: {
                                    container: 'union',
                                    typeName,
                                },
                            });
                            return true;
                        }
                    }
                    if (typeFlags === ts.TypeFlags.Never &&
                        !isNodeInsideReturnType(node)) {
                        context.report({
                            node: typeNode,
                            messageId: 'overridden',
                            data: {
                                container: 'union',
                                typeName: 'never',
                            },
                        });
                        return true;
                    }
                    return false;
                }
                for (const typeNode of node.types) {
                    const typePartFlags = getTypeNodeTypePartFlagsCached(typeNode);
                    for (const typePart of typePartFlags) {
                        if (checkUnionBottomAndTopTypes(typePart, typeNode)) {
                            continue;
                        }
                        for (const literalTypeFlag of literalTypeFlags) {
                            if (typePart.typeFlags === literalTypeFlag) {
                                addToMapGroup(seenLiteralTypes, literalToPrimitiveTypeFlags[literalTypeFlag], {
                                    literalValue: typePart.typeName,
                                    typeNode,
                                });
                                break;
                            }
                        }
                        for (const primitiveTypeFlag of primitiveTypeFlags) {
                            if ((typePart.typeFlags & primitiveTypeFlag) !== 0) {
                                seenPrimitiveTypes.add(primitiveTypeFlag);
                            }
                        }
                    }
                }
                const overriddenTypeNodes = new Map();
                // For each primitive type of all the seen literal types,
                // if there was a primitive type seen that overrides it,
                // upsert the literal text and primitive type under the backing type node
                for (const [primitiveTypeFlag, typeNodesWithText] of seenLiteralTypes) {
                    if (seenPrimitiveTypes.has(primitiveTypeFlag)) {
                        for (const { literalValue, typeNode } of typeNodesWithText) {
                            addToMapGroup(overriddenTypeNodes, typeNode, {
                                literalValue,
                                primitiveTypeFlag,
                            });
                        }
                    }
                }
                // For each type node that had at least one overridden literal,
                // group those literals by their primitive type,
                // then report each primitive type with all its literals
                for (const [typeNode, typeFlagsWithText] of overriddenTypeNodes) {
                    const grouped = (0, util_1.arrayGroupByToMap)(typeFlagsWithText, pair => pair.primitiveTypeFlag);
                    for (const [primitiveTypeFlag, pairs] of grouped) {
                        context.report({
                            node: typeNode,
                            messageId: 'literalOverridden',
                            data: {
                                literal: pairs.map(pair => pair.literalValue).join(' | '),
                                primitive: primitiveTypeFlagNames[primitiveTypeFlag],
                            },
                        });
                    }
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-require-imports.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allow?: string[];
        allowAsImport?: boolean;
    }
];
export type MessageIds = 'noRequireImports';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noRequireImports", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-require-imports.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util = __importStar(require("../util"));
exports.default = util.createRule({
    name: 'no-require-imports',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow invocation of `require()`',
            recommended: 'recommended',
        },
        messages: {
            noRequireImports: 'A `require()` style import is forbidden.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allow: {
                        type: 'array',
                        description: 'Patterns of import paths to allow requiring from.',
                        items: { type: 'string' },
                    },
                    allowAsImport: {
                        type: 'boolean',
                        description: 'Allows `require` statements in import declarations.',
                    },
                },
            },
        ],
    },
    defaultOptions: [{ allow: [], allowAsImport: false }],
    create(context, options) {
        const allowAsImport = options[0].allowAsImport;
        const allowPatterns = options[0].allow?.map(pattern => new RegExp(pattern, 'u'));
        function isImportPathAllowed(importPath) {
            return allowPatterns?.some(pattern => importPath.match(pattern));
        }
        function isStringOrTemplateLiteral(node) {
            return ((node.type === utils_1.AST_NODE_TYPES.Literal &&
                typeof node.value === 'string') ||
                node.type === utils_1.AST_NODE_TYPES.TemplateLiteral);
        }
        return {
            'CallExpression[callee.name="require"]'(node) {
                if (node.arguments[0] && isStringOrTemplateLiteral(node.arguments[0])) {
                    const argValue = util.getStaticStringValue(node.arguments[0]);
                    if (typeof argValue === 'string' && isImportPathAllowed(argValue)) {
                        return;
                    }
                }
                const variable = utils_1.ASTUtils.findVariable(context.sourceCode.getScope(node), 'require');
                // ignore non-global require usage as it's something user-land custom instead
                // of the commonjs standard
                if (!variable?.identifiers.length) {
                    context.report({
                        node,
                        messageId: 'noRequireImports',
                    });
                }
            },
            TSExternalModuleReference(node) {
                if (isStringOrTemplateLiteral(node.expression)) {
                    const argValue = util.getStaticStringValue(node.expression);
                    if (typeof argValue === 'string' && isImportPathAllowed(argValue)) {
                        return;
                    }
                }
                if (allowAsImport &&
                    node.parent.type === utils_1.AST_NODE_TYPES.TSImportEqualsDeclaration) {
                    return;
                }
                context.report({
                    node,
                    messageId: 'noRequireImports',
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-restricted-imports.d.ts
--------------------------------------------------------------------------------

import type { ArrayOfStringOrObject, RuleListener } from 'eslint/lib/rules/no-restricted-imports';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"everything" | "everythingWithCustomMessage" | "importName" | "importNameWithCustomMessage" | "path" | "pathWithCustomMessage" | "patterns" | "patternWithCustomMessage", [import("eslint/lib/rules/no-restricted-imports").ObjectOfPathsAndPatterns] | ArrayOfStringOrObject, unknown, RuleListener>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"everything" | "everythingWithCustomMessage" | "importName" | "importNameWithCustomMessage" | "path" | "pathWithCustomMessage" | "patterns" | "patternWithCustomMessage", [import("eslint/lib/rules/no-restricted-imports").ObjectOfPathsAndPatterns] | ArrayOfStringOrObject, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-restricted-imports.js
--------------------------------------------------------------------------------

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const ignore_1 = __importDefault(require("ignore"));
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-restricted-imports');
// In some versions of eslint, the base rule has a completely incompatible schema
// This helper function is to safely try to get parts of the schema. If it's not
// possible, we'll fallback to less strict checks.
const tryAccess = (getter, fallback) => {
    try {
        return getter();
    }
    catch {
        return fallback;
    }
};
const baseSchema = baseRule.meta.schema;
const allowTypeImportsOptionSchema = {
    allowTypeImports: {
        type: 'boolean',
        description: 'Whether to allow type-only imports for a path.',
    },
};
const arrayOfStringsOrObjects = {
    type: 'array',
    items: {
        anyOf: [
            { type: 'string' },
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ...tryAccess(() => baseSchema.anyOf[1].items[0].properties.paths.items.anyOf[1]
                        .properties, undefined),
                    ...allowTypeImportsOptionSchema,
                },
                required: tryAccess(() => baseSchema.anyOf[1].items[0].properties.paths.items.anyOf[1]
                    .required, undefined),
            },
        ],
    },
    uniqueItems: true,
};
const arrayOfStringsOrObjectPatterns = {
    anyOf: [
        {
            type: 'array',
            items: {
                type: 'string',
            },
            uniqueItems: true,
        },
        {
            type: 'array',
            items: {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ...tryAccess(() => baseSchema.anyOf[1].items[0].properties.patterns.anyOf[1].items
                        .properties, undefined),
                    ...allowTypeImportsOptionSchema,
                },
                required: tryAccess(() => baseSchema.anyOf[1].items[0].properties.patterns.anyOf[1].items
                    .required, []),
            },
            uniqueItems: true,
        },
    ],
};
const schema = {
    anyOf: [
        arrayOfStringsOrObjects,
        {
            type: 'array',
            additionalItems: false,
            items: [
                {
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        paths: arrayOfStringsOrObjects,
                        patterns: arrayOfStringsOrObjectPatterns,
                    },
                },
            ],
        },
    ],
};
function isObjectOfPaths(obj) {
    return !!obj && Object.hasOwn(obj, 'paths');
}
function isObjectOfPatterns(obj) {
    return !!obj && Object.hasOwn(obj, 'patterns');
}
function isOptionsArrayOfStringOrObject(options) {
    if (isObjectOfPaths(options[0])) {
        return false;
    }
    if (isObjectOfPatterns(options[0])) {
        return false;
    }
    return true;
}
function getRestrictedPaths(options) {
    if (isOptionsArrayOfStringOrObject(options)) {
        return options;
    }
    if (isObjectOfPaths(options[0])) {
        return options[0].paths;
    }
    return [];
}
function getRestrictedPatterns(options) {
    if (isObjectOfPatterns(options[0])) {
        return options[0].patterns;
    }
    return [];
}
function shouldCreateRule(baseRules, options) {
    if (Object.keys(baseRules).length === 0 || options.length === 0) {
        return false;
    }
    if (!isOptionsArrayOfStringOrObject(options)) {
        return !!(options[0].paths?.length || options[0].patterns?.length);
    }
    return true;
}
exports.default = (0, util_1.createRule)({
    name: 'no-restricted-imports',
    meta: {
        type: 'suggestion',
        // defaultOptions, -- base rule does not use defaultOptions
        docs: {
            description: 'Disallow specified modules when loaded by `import`',
            extendsBaseRule: true,
        },
        fixable: baseRule.meta.fixable,
        messages: baseRule.meta.messages,
        schema,
    },
    defaultOptions: [],
    create(context) {
        const rules = baseRule.create(context);
        const { options } = context;
        if (!shouldCreateRule(rules, options)) {
            return {};
        }
        const restrictedPaths = getRestrictedPaths(options);
        const allowedTypeImportPathNameSet = new Set();
        for (const restrictedPath of restrictedPaths) {
            if (typeof restrictedPath === 'object' &&
                restrictedPath.allowTypeImports) {
                allowedTypeImportPathNameSet.add(restrictedPath.name);
            }
        }
        function isAllowedTypeImportPath(importSource) {
            return allowedTypeImportPathNameSet.has(importSource);
        }
        const restrictedPatterns = getRestrictedPatterns(options);
        const allowedImportTypeMatchers = [];
        const allowedImportTypeRegexMatchers = [];
        for (const restrictedPattern of restrictedPatterns) {
            if (typeof restrictedPattern === 'object' &&
                restrictedPattern.allowTypeImports) {
                // Following how ignore is configured in the base rule
                if (restrictedPattern.group) {
                    allowedImportTypeMatchers.push((0, ignore_1.default)({
                        allowRelativePaths: true,
                        ignoreCase: !restrictedPattern.caseSensitive,
                    }).add(restrictedPattern.group));
                }
                if (restrictedPattern.regex) {
                    allowedImportTypeRegexMatchers.push(new RegExp(restrictedPattern.regex, restrictedPattern.caseSensitive ? 'u' : 'iu'));
                }
            }
        }
        function isAllowedTypeImportPattern(importSource) {
            return (
            // As long as there's one matching pattern that allows type import
            allowedImportTypeMatchers.some(matcher => matcher.ignores(importSource)) ||
                allowedImportTypeRegexMatchers.some(regex => regex.test(importSource)));
        }
        function checkImportNode(node) {
            if (node.importKind === 'type' ||
                (node.specifiers.length > 0 &&
                    node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &&
                        specifier.importKind === 'type'))) {
                const importSource = node.source.value.trim();
                if (!isAllowedTypeImportPath(importSource) &&
                    !isAllowedTypeImportPattern(importSource)) {
                    return rules.ImportDeclaration(node);
                }
            }
            else {
                return rules.ImportDeclaration(node);
            }
        }
        return {
            ExportAllDeclaration: rules.ExportAllDeclaration,
            'ExportNamedDeclaration[source]'(node) {
                if (node.exportKind === 'type' ||
                    (node.specifiers.length > 0 &&
                        node.specifiers.every(specifier => specifier.exportKind === 'type'))) {
                    const importSource = node.source.value.trim();
                    if (!isAllowedTypeImportPath(importSource) &&
                        !isAllowedTypeImportPattern(importSource)) {
                        return rules.ExportNamedDeclaration(node);
                    }
                }
                else {
                    return rules.ExportNamedDeclaration(node);
                }
            },
            ImportDeclaration: checkImportNode,
            TSImportEqualsDeclaration(node) {
                if (node.moduleReference.type === utils_1.AST_NODE_TYPES.TSExternalModuleReference) {
                    const synthesizedImport = {
                        ...node,
                        type: utils_1.AST_NODE_TYPES.ImportDeclaration,
                        assertions: [],
                        attributes: [],
                        source: node.moduleReference.expression,
                        specifiers: [
                            {
                                ...node.id,
                                type: utils_1.AST_NODE_TYPES.ImportDefaultSpecifier,
                                local: node.id,
                                // @ts-expect-error -- parent types are incompatible but it's fine for the purposes of this extension
                                parent: node.id.parent,
                            },
                        ],
                    };
                    return checkImportNode(synthesizedImport);
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-restricted-types.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
type Types = Record<string, boolean | string | {
    fixWith?: string;
    message: string;
    suggest?: readonly string[];
} | null>;
export type Options = [
    {
        types?: Types;
    }
];
export type MessageIds = 'bannedTypeMessage' | 'bannedTypeReplacement';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-restricted-types.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
function removeSpaces(str) {
    return str.replaceAll(/\s/g, '');
}
function stringifyNode(node, sourceCode) {
    return removeSpaces(sourceCode.getText(node));
}
function getCustomMessage(bannedType) {
    if (!bannedType || bannedType === true) {
        return '';
    }
    if (typeof bannedType === 'string') {
        return ` ${bannedType}`;
    }
    if (bannedType.message) {
        return ` ${bannedType.message}`;
    }
    return '';
}
const TYPE_KEYWORDS = {
    bigint: utils_1.AST_NODE_TYPES.TSBigIntKeyword,
    boolean: utils_1.AST_NODE_TYPES.TSBooleanKeyword,
    never: utils_1.AST_NODE_TYPES.TSNeverKeyword,
    null: utils_1.AST_NODE_TYPES.TSNullKeyword,
    number: utils_1.AST_NODE_TYPES.TSNumberKeyword,
    object: utils_1.AST_NODE_TYPES.TSObjectKeyword,
    string: utils_1.AST_NODE_TYPES.TSStringKeyword,
    symbol: utils_1.AST_NODE_TYPES.TSSymbolKeyword,
    undefined: utils_1.AST_NODE_TYPES.TSUndefinedKeyword,
    unknown: utils_1.AST_NODE_TYPES.TSUnknownKeyword,
    void: utils_1.AST_NODE_TYPES.TSVoidKeyword,
};
exports.default = (0, util_1.createRule)({
    name: 'no-restricted-types',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow certain types',
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            bannedTypeMessage: "Don't use `{{name}}` as a type.{{customMessage}}",
            bannedTypeReplacement: 'Replace `{{name}}` with `{{replacement}}`.',
        },
        schema: [
            {
                type: 'object',
                $defs: {
                    banConfig: {
                        oneOf: [
                            {
                                type: 'boolean',
                                description: 'Bans the type with the default message.',
                                enum: [true],
                            },
                            {
                                type: 'string',
                                description: 'Bans the type with a custom message.',
                            },
                            {
                                type: 'object',
                                additionalProperties: false,
                                description: 'Bans a type.',
                                properties: {
                                    fixWith: {
                                        type: 'string',
                                        description: 'Type to autofix replace with. Note that autofixers can be applied automatically - so you need to be careful with this option.',
                                    },
                                    message: {
                                        type: 'string',
                                        description: 'Custom error message.',
                                    },
                                    suggest: {
                                        type: 'array',
                                        description: 'Types to suggest replacing with.',
                                        items: { type: 'string' },
                                    },
                                },
                            },
                        ],
                    },
                },
                additionalProperties: false,
                properties: {
                    types: {
                        type: 'object',
                        additionalProperties: {
                            $ref: '#/items/0/$defs/banConfig',
                        },
                        description: 'An object whose keys are the types you want to ban, and the values are error messages.',
                    },
                },
            },
        ],
    },
    defaultOptions: [{}],
    create(context, [{ types = {} }]) {
        const bannedTypes = new Map(Object.entries(types).map(([type, data]) => [removeSpaces(type), data]));
        function checkBannedTypes(typeNode, name = stringifyNode(typeNode, context.sourceCode)) {
            const bannedType = bannedTypes.get(name);
            if (bannedType == null || bannedType === false) {
                return;
            }
            const customMessage = getCustomMessage(bannedType);
            const fixWith = bannedType && typeof bannedType === 'object' && bannedType.fixWith;
            const suggest = bannedType && typeof bannedType === 'object'
                ? bannedType.suggest
                : undefined;
            context.report({
                node: typeNode,
                messageId: 'bannedTypeMessage',
                data: {
                    name,
                    customMessage,
                },
                fix: fixWith
                    ? (fixer) => fixer.replaceText(typeNode, fixWith)
                    : null,
                suggest: suggest?.map(replacement => ({
                    messageId: 'bannedTypeReplacement',
                    data: {
                        name,
                        replacement,
                    },
                    fix: (fixer) => fixer.replaceText(typeNode, replacement),
                })),
            });
        }
        const keywordSelectors = (0, util_1.objectReduceKey)(TYPE_KEYWORDS, (acc, keyword) => {
            if (bannedTypes.has(keyword)) {
                acc[TYPE_KEYWORDS[keyword]] = (node) => checkBannedTypes(node, keyword);
            }
            return acc;
        }, {});
        return {
            ...keywordSelectors,
            TSClassImplements(node) {
                checkBannedTypes(node);
            },
            TSInterfaceHeritage(node) {
                checkBannedTypes(node);
            },
            TSTupleType(node) {
                if (!node.elementTypes.length) {
                    checkBannedTypes(node);
                }
            },
            TSTypeLiteral(node) {
                if (!node.members.length) {
                    checkBannedTypes(node);
                }
            },
            TSTypeReference(node) {
                checkBannedTypes(node.typeName);
                if (node.typeArguments) {
                    checkBannedTypes(node);
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-shadow.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageIds = 'noShadow' | 'noShadowGlobal';
export type Options = [
    {
        allow?: string[];
        builtinGlobals?: boolean;
        hoist?: 'all' | 'functions' | 'functions-and-types' | 'never' | 'types';
        ignoreFunctionTypeParameterNameValueShadow?: boolean;
        ignoreOnInitialization?: boolean;
        ignoreTypeValueShadow?: boolean;
    }
];
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-shadow.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const isTypeImport_1 = require("../util/isTypeImport");
const allowedFunctionVariableDefTypes = new Set([
    utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration,
    utils_1.AST_NODE_TYPES.TSFunctionType,
    utils_1.AST_NODE_TYPES.TSMethodSignature,
    utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
    utils_1.AST_NODE_TYPES.TSDeclareFunction,
    utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration,
    utils_1.AST_NODE_TYPES.TSConstructorType,
]);
const functionsHoistedNodes = new Set([utils_1.AST_NODE_TYPES.FunctionDeclaration]);
const typesHoistedNodes = new Set([
    utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,
    utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration,
]);
exports.default = (0, util_1.createRule)({
    name: 'no-shadow',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow variable declarations from shadowing variables declared in the outer scope',
            extendsBaseRule: true,
        },
        messages: {
            noShadow: "'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.",
            noShadowGlobal: "'{{name}}' is already a global variable.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allow: {
                        type: 'array',
                        description: 'Identifier names for which shadowing is allowed.',
                        items: {
                            type: 'string',
                        },
                    },
                    builtinGlobals: {
                        type: 'boolean',
                        description: 'Whether to report shadowing of built-in global variables.',
                    },
                    hoist: {
                        type: 'string',
                        description: 'Whether to report shadowing before outer functions or variables are defined.',
                        enum: ['all', 'functions', 'functions-and-types', 'never', 'types'],
                    },
                    ignoreFunctionTypeParameterNameValueShadow: {
                        type: 'boolean',
                        description: 'Whether to ignore function parameters named the same as a variable.',
                    },
                    ignoreOnInitialization: {
                        type: 'boolean',
                        description: 'Whether to ignore the variable initializers when the shadowed variable is presumably still unitialized.',
                    },
                    ignoreTypeValueShadow: {
                        type: 'boolean',
                        description: 'Whether to ignore types named the same as a variable.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allow: [],
            builtinGlobals: false,
            hoist: 'functions-and-types',
            ignoreFunctionTypeParameterNameValueShadow: true,
            ignoreOnInitialization: false,
            ignoreTypeValueShadow: true,
        },
    ],
    create(context, [options]) {
        /**
         * Check if a scope is a TypeScript module augmenting the global namespace.
         */
        function isGlobalAugmentation(scope) {
            return ((scope.type === scope_manager_1.ScopeType.tsModule && scope.block.kind === 'global') ||
                (!!scope.upper && isGlobalAugmentation(scope.upper)));
        }
        /**
         * Check if variable is a `this` parameter.
         */
        function isThisParam(variable) {
            return (variable.defs[0].type === scope_manager_1.DefinitionType.Parameter &&
                variable.name === 'this');
        }
        function isTypeValueShadow(variable, shadowed) {
            if (options.ignoreTypeValueShadow !== true) {
                return false;
            }
            if (!('isValueVariable' in variable)) {
                // this shouldn't happen...
                return false;
            }
            const firstDefinition = shadowed.defs.at(0);
            const isShadowedValue = !('isValueVariable' in shadowed) ||
                !firstDefinition ||
                (!(0, isTypeImport_1.isTypeImport)(firstDefinition) && shadowed.isValueVariable);
            return variable.isValueVariable !== isShadowedValue;
        }
        function isFunctionTypeParameterNameValueShadow(variable, shadowed) {
            if (options.ignoreFunctionTypeParameterNameValueShadow !== true) {
                return false;
            }
            if (!('isValueVariable' in variable)) {
                // this shouldn't happen...
                return false;
            }
            const isShadowedValue = 'isValueVariable' in shadowed ? shadowed.isValueVariable : true;
            if (!isShadowedValue) {
                return false;
            }
            return variable.defs.every(def => allowedFunctionVariableDefTypes.has(def.node.type));
        }
        function isGenericOfStaticMethod(variable) {
            if (!('isTypeVariable' in variable)) {
                // this shouldn't happen...
                return false;
            }
            if (!variable.isTypeVariable) {
                return false;
            }
            if (variable.identifiers.length === 0) {
                return false;
            }
            const typeParameter = variable.identifiers[0].parent;
            if (typeParameter.type !== utils_1.AST_NODE_TYPES.TSTypeParameter) {
                return false;
            }
            const typeParameterDecl = typeParameter.parent;
            if (typeParameterDecl.type !== utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration) {
                return false;
            }
            const functionExpr = typeParameterDecl.parent;
            if (functionExpr.type !== utils_1.AST_NODE_TYPES.FunctionExpression &&
                functionExpr.type !== utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {
                return false;
            }
            const methodDefinition = functionExpr.parent;
            if (methodDefinition.type !== utils_1.AST_NODE_TYPES.MethodDefinition) {
                return false;
            }
            return methodDefinition.static;
        }
        function isGenericOfClass(variable) {
            if (!('isTypeVariable' in variable)) {
                // this shouldn't happen...
                return false;
            }
            if (!variable.isTypeVariable) {
                return false;
            }
            if (variable.identifiers.length === 0) {
                return false;
            }
            const typeParameter = variable.identifiers[0].parent;
            if (typeParameter.type !== utils_1.AST_NODE_TYPES.TSTypeParameter) {
                return false;
            }
            const typeParameterDecl = typeParameter.parent;
            if (typeParameterDecl.type !== utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration) {
                return false;
            }
            const classDecl = typeParameterDecl.parent;
            return (classDecl.type === utils_1.AST_NODE_TYPES.ClassDeclaration ||
                classDecl.type === utils_1.AST_NODE_TYPES.ClassExpression);
        }
        function isGenericOfAStaticMethodShadow(variable, shadowed) {
            return isGenericOfStaticMethod(variable) && isGenericOfClass(shadowed);
        }
        function isImportDeclaration(definition) {
            return definition.type === utils_1.AST_NODE_TYPES.ImportDeclaration;
        }
        function isExternalModuleDeclarationWithName(scope, name) {
            return (scope.type === scope_manager_1.ScopeType.tsModule &&
                scope.block.id.type === utils_1.AST_NODE_TYPES.Literal &&
                scope.block.id.value === name);
        }
        function isExternalDeclarationMerging(scope, variable, shadowed) {
            const [firstDefinition] = shadowed.defs;
            const [secondDefinition] = variable.defs;
            return ((0, isTypeImport_1.isTypeImport)(firstDefinition) &&
                isImportDeclaration(firstDefinition.parent) &&
                isExternalModuleDeclarationWithName(scope, firstDefinition.parent.source.value) &&
                (secondDefinition.node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration ||
                    secondDefinition.node.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration));
        }
        /**
         * Check if variable name is allowed.
         * @param variable The variable to check.
         * @returns Whether or not the variable name is allowed.
         */
        function isAllowed(variable) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return options.allow.includes(variable.name);
        }
        /**
         * Checks if a variable of the class name in the class scope of ClassDeclaration.
         *
         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.
         * So we should ignore the variable in the class scope.
         * @param variable The variable to check.
         * @returns Whether or not the variable of the class name in the class scope of ClassDeclaration.
         */
        function isDuplicatedClassNameVariable(variable) {
            const block = variable.scope.block;
            return (block.type === utils_1.AST_NODE_TYPES.ClassDeclaration &&
                block.id === variable.identifiers[0]);
        }
        /**
         * Checks if a variable of the class name in the class scope of TSEnumDeclaration.
         *
         * TSEnumDeclaration creates two variables of its name into its outer scope and its class scope.
         * So we should ignore the variable in the class scope.
         * @param variable The variable to check.
         * @returns Whether or not the variable of the class name in the class scope of TSEnumDeclaration.
         */
        function isDuplicatedEnumNameVariable(variable) {
            const block = variable.scope.block;
            return (block.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration &&
                block.id === variable.identifiers[0]);
        }
        /**
         * Checks whether or not a given location is inside of the range of a given node.
         * @param node An node to check.
         * @param location A location to check.
         * @returns `true` if the location is inside of the range of the node.
         */
        function isInRange(node, location) {
            return node && node.range[0] <= location && location <= node.range[1];
        }
        /**
         * Searches from the current node through its ancestry to find a matching node.
         * @param node a node to get.
         * @param match a callback that checks whether or not the node verifies its condition or not.
         * @returns the matching node.
         */
        function findSelfOrAncestor(node, match) {
            let currentNode = node;
            while (currentNode && !match(currentNode)) {
                currentNode = currentNode.parent;
            }
            return currentNode;
        }
        /**
         * Finds function's outer scope.
         * @param scope Function's own scope.
         * @returns Function's outer scope.
         */
        function getOuterScope(scope) {
            const upper = scope.upper;
            if (upper?.type === scope_manager_1.ScopeType.functionExpressionName) {
                return upper.upper;
            }
            return upper;
        }
        /**
         * Checks if a variable and a shadowedVariable have the same init pattern ancestor.
         * @param variable a variable to check.
         * @param shadowedVariable a shadowedVariable to check.
         * @returns Whether or not the variable and the shadowedVariable have the same init pattern ancestor.
         */
        function isInitPatternNode(variable, shadowedVariable) {
            const outerDef = shadowedVariable.defs.at(0);
            if (!outerDef) {
                return false;
            }
            const { variableScope } = variable.scope;
            if (!((variableScope.block.type ===
                utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                variableScope.block.type === utils_1.AST_NODE_TYPES.FunctionExpression) &&
                getOuterScope(variableScope) === shadowedVariable.scope)) {
                return false;
            }
            const fun = variableScope.block;
            const { parent } = fun;
            const callExpression = findSelfOrAncestor(parent, node => node.type === utils_1.AST_NODE_TYPES.CallExpression);
            if (!callExpression) {
                return false;
            }
            let node = outerDef.name;
            const location = callExpression.range[1];
            while (node) {
                if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {
                    if (isInRange(node.init, location)) {
                        return true;
                    }
                    if ((node.parent.parent.type === utils_1.AST_NODE_TYPES.ForInStatement ||
                        node.parent.parent.type === utils_1.AST_NODE_TYPES.ForOfStatement) &&
                        isInRange(node.parent.parent.right, location)) {
                        return true;
                    }
                    break;
                }
                else if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {
                    if (isInRange(node.right, location)) {
                        return true;
                    }
                }
                else if ([
                    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
                    utils_1.AST_NODE_TYPES.CatchClause,
                    utils_1.AST_NODE_TYPES.ClassDeclaration,
                    utils_1.AST_NODE_TYPES.ClassExpression,
                    utils_1.AST_NODE_TYPES.ExportNamedDeclaration,
                    utils_1.AST_NODE_TYPES.FunctionDeclaration,
                    utils_1.AST_NODE_TYPES.FunctionExpression,
                    utils_1.AST_NODE_TYPES.ImportDeclaration,
                ].includes(node.type)) {
                    break;
                }
                node = node.parent;
            }
            return false;
        }
        /**
         * Checks if a variable is inside the initializer of scopeVar.
         *
         * To avoid reporting at declarations such as `var a = function a() {};`.
         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.
         * @param variable The variable to check.
         * @param scopeVar The scope variable to look for.
         * @returns Whether or not the variable is inside initializer of scopeVar.
         */
        function isOnInitializer(variable, scopeVar) {
            const outerScope = scopeVar.scope;
            const outerDef = scopeVar.defs.at(0);
            const outer = outerDef?.parent?.range;
            const innerScope = variable.scope;
            const innerDef = variable.defs.at(0);
            const inner = innerDef?.name.range;
            return !!(outer &&
                inner &&
                outer[0] < inner[0] &&
                inner[1] < outer[1] &&
                ((innerDef.type === scope_manager_1.DefinitionType.FunctionName &&
                    innerDef.node.type === utils_1.AST_NODE_TYPES.FunctionExpression) ||
                    innerDef.node.type === utils_1.AST_NODE_TYPES.ClassExpression) &&
                outerScope === innerScope.upper);
        }
        /**
         * Get a range of a variable's identifier node.
         * @param variable The variable to get.
         * @returns The range of the variable's identifier node.
         */
        function getNameRange(variable) {
            const def = variable.defs.at(0);
            return def?.name.range;
        }
        /**
         * Checks if a variable is in TDZ of scopeVar.
         * @param variable The variable to check.
         * @param scopeVar The variable of TDZ.
         * @returns Whether or not the variable is in TDZ of scopeVar.
         */
        function isInTdz(variable, scopeVar) {
            const outerDef = scopeVar.defs.at(0);
            const inner = getNameRange(variable);
            const outer = getNameRange(scopeVar);
            if (!inner || !outer || inner[1] >= outer[0]) {
                return false;
            }
            if (!outerDef) {
                return true;
            }
            if (options.hoist === 'functions') {
                return !functionsHoistedNodes.has(outerDef.node.type);
            }
            if (options.hoist === 'types') {
                return !typesHoistedNodes.has(outerDef.node.type);
            }
            if (options.hoist === 'functions-and-types') {
                return (!functionsHoistedNodes.has(outerDef.node.type) &&
                    !typesHoistedNodes.has(outerDef.node.type));
            }
            return true;
        }
        /**
         * Get declared line and column of a variable.
         * @param  variable The variable to get.
         * @returns The declared line and column of the variable.
         */
        function getDeclaredLocation(variable) {
            const identifier = variable.identifiers.at(0);
            if (identifier) {
                return {
                    column: identifier.loc.start.column + 1,
                    global: false,
                    line: identifier.loc.start.line,
                };
            }
            return {
                global: true,
            };
        }
        /**
         * Checks if the initialization of a variable has the declare modifier in a
         * definition file.
         */
        function isDeclareInDTSFile(variable) {
            const fileName = context.filename;
            if (!(0, util_1.isDefinitionFile)(fileName)) {
                return false;
            }
            return variable.defs.some(def => {
                return ((def.type === scope_manager_1.DefinitionType.Variable && def.parent.declare) ||
                    (def.type === scope_manager_1.DefinitionType.ClassName && def.node.declare) ||
                    (def.type === scope_manager_1.DefinitionType.TSEnumName && def.node.declare) ||
                    (def.type === scope_manager_1.DefinitionType.TSModuleName && def.node.declare));
            });
        }
        /**
         * Checks the current context for shadowed variables.
         * @param scope Fixme
         */
        function checkForShadows(scope) {
            // ignore global augmentation
            if (isGlobalAugmentation(scope)) {
                return;
            }
            const variables = scope.variables;
            for (const variable of variables) {
                // ignore "arguments"
                if (variable.identifiers.length === 0) {
                    continue;
                }
                // this params are pseudo-params that cannot be shadowed
                if (isThisParam(variable)) {
                    continue;
                }
                // ignore variables of a class name in the class scope of ClassDeclaration
                if (isDuplicatedClassNameVariable(variable)) {
                    continue;
                }
                // ignore variables of a class name in the class scope of ClassDeclaration
                if (isDuplicatedEnumNameVariable(variable)) {
                    continue;
                }
                // ignore configured allowed names
                if (isAllowed(variable)) {
                    continue;
                }
                // ignore variables with the declare keyword in .d.ts files
                if (isDeclareInDTSFile(variable)) {
                    continue;
                }
                // Gets shadowed variable.
                const shadowed = scope.upper
                    ? utils_1.ASTUtils.findVariable(scope.upper, variable.name)
                    : null;
                if (!shadowed) {
                    continue;
                }
                // ignore type value variable shadowing if configured
                if (isTypeValueShadow(variable, shadowed)) {
                    continue;
                }
                // ignore function type parameter name shadowing if configured
                if (isFunctionTypeParameterNameValueShadow(variable, shadowed)) {
                    continue;
                }
                // ignore static class method generic shadowing class generic
                // this is impossible for the scope analyser to understand
                // so we have to handle this manually in this rule
                if (isGenericOfAStaticMethodShadow(variable, shadowed)) {
                    continue;
                }
                if (isExternalDeclarationMerging(scope, variable, shadowed)) {
                    continue;
                }
                const isESLintGlobal = 'writeable' in shadowed;
                if ((shadowed.identifiers.length > 0 ||
                    (options.builtinGlobals && isESLintGlobal)) &&
                    !isOnInitializer(variable, shadowed) &&
                    !(options.ignoreOnInitialization &&
                        isInitPatternNode(variable, shadowed)) &&
                    !(options.hoist !== 'all' && isInTdz(variable, shadowed))) {
                    const location = getDeclaredLocation(shadowed);
                    context.report({
                        node: variable.identifiers[0],
                        ...(location.global
                            ? {
                                messageId: 'noShadowGlobal',
                                data: {
                                    name: variable.name,
                                },
                            }
                            : {
                                messageId: 'noShadow',
                                data: {
                                    name: variable.name,
                                    shadowedColumn: location.column,
                                    shadowedLine: location.line,
                                },
                            }),
                    });
                }
            }
        }
        return {
            'Program:exit'(node) {
                const globalScope = context.sourceCode.getScope(node);
                const stack = [...globalScope.childScopes];
                while (stack.length) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const scope = stack.pop();
                    stack.push(...scope.childScopes);
                    checkForShadows(scope);
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-this-alias.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowDestructuring?: boolean;
        allowedNames?: string[];
    }
];
export type MessageIds = 'thisAssignment' | 'thisDestructure';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-this-alias.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-this-alias',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow aliasing `this`',
            recommended: 'recommended',
        },
        messages: {
            thisAssignment: "Unexpected aliasing of 'this' to local variable.",
            thisDestructure: "Unexpected aliasing of members of 'this' to local variables.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowDestructuring: {
                        type: 'boolean',
                        description: 'Whether to ignore destructurings, such as `const { props, state } = this`.',
                    },
                    allowedNames: {
                        type: 'array',
                        description: 'Names to ignore, such as ["self"] for `const self = this;`.',
                        items: {
                            type: 'string',
                        },
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowDestructuring: true,
            allowedNames: [],
        },
    ],
    create(context, [{ allowDestructuring, allowedNames }]) {
        return {
            "VariableDeclarator[init.type='ThisExpression'], AssignmentExpression[right.type='ThisExpression']"(node) {
                const id = node.type === utils_1.AST_NODE_TYPES.VariableDeclarator ? node.id : node.left;
                if (allowDestructuring && id.type !== utils_1.AST_NODE_TYPES.Identifier) {
                    return;
                }
                const hasAllowedName = id.type === utils_1.AST_NODE_TYPES.Identifier
                    ? // https://github.com/typescript-eslint/typescript-eslint/issues/5439
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        allowedNames.includes(id.name)
                    : false;
                if (!hasAllowedName) {
                    context.report({
                        node: id,
                        messageId: id.type === utils_1.AST_NODE_TYPES.Identifier
                            ? 'thisAssignment'
                            : 'thisDestructure',
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-type-alias.d.ts
--------------------------------------------------------------------------------

type Values = 'always' | 'in-intersections' | 'in-unions' | 'in-unions-and-intersections' | 'never';
export type Options = [
    {
        allowAliases?: Values;
        allowCallbacks?: 'always' | 'never';
        allowConditionalTypes?: 'always' | 'never';
        allowConstructors?: 'always' | 'never';
        allowGenerics?: 'always' | 'never';
        allowLiterals?: Values;
        allowMappedTypes?: Values;
        allowTupleTypes?: Values;
    }
];
export type MessageIds = 'noCompositionAlias' | 'noTypeAlias';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-type-alias.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-type-alias',
    meta: {
        type: 'suggestion',
        deprecated: {
            deprecatedSince: '6.0.0',
            replacedBy: [
                {
                    rule: {
                        name: '@typescript-eslint/consistent-type-definitions',
                        url: 'https://typescript-eslint.io/rules/consistent-type-definitions',
                    },
                },
            ],
            url: 'https://github.com/typescript-eslint/typescript-eslint/pull/6229',
        },
        docs: {
            description: 'Disallow type aliases',
            // too opinionated to be recommended
        },
        messages: {
            noCompositionAlias: '{{typeName}} in {{compositionType}} types are not allowed.',
            noTypeAlias: 'Type {{alias}} are not allowed.',
        },
        schema: [
            {
                type: 'object',
                $defs: {
                    expandedOptions: {
                        type: 'string',
                        enum: [
                            'always',
                            'never',
                            'in-unions',
                            'in-intersections',
                            'in-unions-and-intersections',
                        ],
                    },
                    simpleOptions: {
                        type: 'string',
                        enum: ['always', 'never'],
                    },
                },
                additionalProperties: false,
                properties: {
                    allowAliases: {
                        $ref: '#/items/0/$defs/expandedOptions',
                        description: 'Whether to allow direct one-to-one type aliases.',
                    },
                    allowCallbacks: {
                        $ref: '#/items/0/$defs/simpleOptions',
                        description: 'Whether to allow type aliases for callbacks.',
                    },
                    allowConditionalTypes: {
                        $ref: '#/items/0/$defs/simpleOptions',
                        description: 'Whether to allow type aliases for conditional types.',
                    },
                    allowConstructors: {
                        $ref: '#/items/0/$defs/simpleOptions',
                        description: 'Whether to allow type aliases with constructors.',
                    },
                    allowGenerics: {
                        $ref: '#/items/0/$defs/simpleOptions',
                        description: 'Whether to allow type aliases with generic types.',
                    },
                    allowLiterals: {
                        $ref: '#/items/0/$defs/expandedOptions',
                        description: 'Whether to allow type aliases with object literal types.',
                    },
                    allowMappedTypes: {
                        $ref: '#/items/0/$defs/expandedOptions',
                        description: 'Whether to allow type aliases with mapped types.',
                    },
                    allowTupleTypes: {
                        $ref: '#/items/0/$defs/expandedOptions',
                        description: 'Whether to allow type aliases with tuple types.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowAliases: 'never',
            allowCallbacks: 'never',
            allowConditionalTypes: 'never',
            allowConstructors: 'never',
            allowGenerics: 'never',
            allowLiterals: 'never',
            allowMappedTypes: 'never',
            allowTupleTypes: 'never',
        },
    ],
    create(context, [{ allowAliases, allowCallbacks, allowConditionalTypes, allowConstructors, allowGenerics, allowLiterals, allowMappedTypes, allowTupleTypes, },]) {
        const unions = ['always', 'in-unions', 'in-unions-and-intersections'];
        const intersections = [
            'always',
            'in-intersections',
            'in-unions-and-intersections',
        ];
        const compositions = [
            'in-unions',
            'in-intersections',
            'in-unions-and-intersections',
        ];
        const aliasTypes = new Set([
            utils_1.AST_NODE_TYPES.TSArrayType,
            utils_1.AST_NODE_TYPES.TSImportType,
            utils_1.AST_NODE_TYPES.TSIndexedAccessType,
            utils_1.AST_NODE_TYPES.TSLiteralType,
            utils_1.AST_NODE_TYPES.TSTemplateLiteralType,
            utils_1.AST_NODE_TYPES.TSTypeQuery,
            utils_1.AST_NODE_TYPES.TSTypeReference,
        ]);
        /**
         * Determines if the composition type is supported by the allowed flags.
         * @param isTopLevel a flag indicating this is the top level node.
         * @param compositionType the composition type (either TSUnionType or TSIntersectionType)
         * @param allowed the currently allowed flags.
         */
        function isSupportedComposition(isTopLevel, compositionType, allowed) {
            return (!compositions.includes(allowed) ||
                (!isTopLevel &&
                    ((compositionType === utils_1.AST_NODE_TYPES.TSUnionType &&
                        unions.includes(allowed)) ||
                        (compositionType === utils_1.AST_NODE_TYPES.TSIntersectionType &&
                            intersections.includes(allowed)))));
        }
        /**
         * Gets the message to be displayed based on the node type and whether the node is a top level declaration.
         * @param node the location
         * @param compositionType the type of composition this alias is part of (undefined if not
         *                                  part of a composition)
         * @param isRoot a flag indicating we are dealing with the top level declaration.
         * @param type the kind of type alias being validated.
         */
        function reportError(node, compositionType, isRoot, type) {
            if (isRoot) {
                return context.report({
                    node,
                    messageId: 'noTypeAlias',
                    data: {
                        alias: type.toLowerCase(),
                    },
                });
            }
            return context.report({
                node,
                messageId: 'noCompositionAlias',
                data: {
                    compositionType: compositionType === utils_1.AST_NODE_TYPES.TSUnionType
                        ? 'union'
                        : 'intersection',
                    typeName: type,
                },
            });
        }
        const isValidTupleType = (type) => {
            if (type.node.type === utils_1.AST_NODE_TYPES.TSTupleType) {
                return true;
            }
            if (type.node.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&
                ['keyof', 'readonly'].includes(type.node.operator) &&
                type.node.typeAnnotation?.type === utils_1.AST_NODE_TYPES.TSTupleType) {
                return true;
            }
            return false;
        };
        const isValidGeneric = (type) => {
            return (type.node.type === utils_1.AST_NODE_TYPES.TSTypeReference &&
                type.node.typeArguments != null);
        };
        const checkAndReport = (optionValue, isTopLevel, type, label) => {
            if (optionValue === 'never' ||
                !isSupportedComposition(isTopLevel, type.compositionType, optionValue)) {
                reportError(type.node, type.compositionType, isTopLevel, label);
            }
        };
        /**
         * Validates the node looking for aliases, callbacks and literals.
         * @param type the type of composition this alias is part of (null if not
         *                                  part of a composition)
         * @param isTopLevel a flag indicating this is the top level node.
         */
        function validateTypeAliases(type, isTopLevel = false) {
            // https://github.com/typescript-eslint/typescript-eslint/issues/5439
            /* eslint-disable @typescript-eslint/no-non-null-assertion */
            if (type.node.type === utils_1.AST_NODE_TYPES.TSFunctionType) {
                // callback
                if (allowCallbacks === 'never') {
                    reportError(type.node, type.compositionType, isTopLevel, 'Callbacks');
                }
            }
            else if (type.node.type === utils_1.AST_NODE_TYPES.TSConditionalType) {
                // conditional type
                if (allowConditionalTypes === 'never') {
                    reportError(type.node, type.compositionType, isTopLevel, 'Conditional types');
                }
            }
            else if (type.node.type === utils_1.AST_NODE_TYPES.TSConstructorType) {
                if (allowConstructors === 'never') {
                    reportError(type.node, type.compositionType, isTopLevel, 'Constructors');
                }
            }
            else if (type.node.type === utils_1.AST_NODE_TYPES.TSTypeLiteral) {
                // literal object type
                checkAndReport(allowLiterals, isTopLevel, type, 'Literals');
            }
            else if (type.node.type === utils_1.AST_NODE_TYPES.TSMappedType) {
                // mapped type
                checkAndReport(allowMappedTypes, isTopLevel, type, 'Mapped types');
            }
            else if (isValidTupleType(type)) {
                // tuple types
                checkAndReport(allowTupleTypes, isTopLevel, type, 'Tuple Types');
            }
            else if (isValidGeneric(type)) {
                if (allowGenerics === 'never') {
                    reportError(type.node, type.compositionType, isTopLevel, 'Generics');
                }
            }
            else if (type.node.type.endsWith(utils_1.AST_TOKEN_TYPES.Keyword) ||
                aliasTypes.has(type.node.type) ||
                (type.node.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&
                    (type.node.operator === 'keyof' ||
                        (type.node.operator === 'readonly' &&
                            type.node.typeAnnotation &&
                            aliasTypes.has(type.node.typeAnnotation.type))))) {
                // alias / keyword
                checkAndReport(allowAliases, isTopLevel, type, 'Aliases');
            }
            else {
                // unhandled type - shouldn't happen
                reportError(type.node, type.compositionType, isTopLevel, 'Unhandled');
            }
            /* eslint-enable @typescript-eslint/no-non-null-assertion */
        }
        /**
         * Flatten the given type into an array of its dependencies
         */
        function getTypes(node, compositionType = null) {
            if (node.type === utils_1.AST_NODE_TYPES.TSUnionType ||
                node.type === utils_1.AST_NODE_TYPES.TSIntersectionType) {
                return node.types.flatMap(type => getTypes(type, node.type));
            }
            return [{ node, compositionType }];
        }
        return {
            TSTypeAliasDeclaration(node) {
                const types = getTypes(node.typeAnnotation);
                if (types.length === 1) {
                    // is a top level type annotation
                    validateTypeAliases(types[0], true);
                }
                else {
                    // is a composition type
                    types.forEach(type => {
                        validateTypeAliases(type);
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unnecessary-boolean-literal-compare.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'comparingNullableToFalse' | 'comparingNullableToTrueDirect' | 'comparingNullableToTrueNegated' | 'direct' | 'negated' | 'noStrictNullCheck';
export type Options = [
    {
        allowComparingNullableBooleansToFalse?: boolean;
        allowComparingNullableBooleansToTrue?: boolean;
        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing?: boolean;
    }
];
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-boolean-literal-compare.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-boolean-literal-compare',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow unnecessary equality comparisons against boolean literals',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            comparingNullableToFalse: 'This expression unnecessarily compares a nullable boolean value to false instead of using the ?? operator to provide a default.',
            comparingNullableToTrueDirect: 'This expression unnecessarily compares a nullable boolean value to true instead of using it directly.',
            comparingNullableToTrueNegated: 'This expression unnecessarily compares a nullable boolean value to true instead of negating it.',
            direct: 'This expression unnecessarily compares a boolean value to a boolean instead of using it directly.',
            negated: 'This expression unnecessarily compares a boolean value to a boolean instead of negating it.',
            noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowComparingNullableBooleansToFalse: {
                        type: 'boolean',
                        description: 'Whether to allow comparisons between nullable boolean variables and `false`.',
                    },
                    allowComparingNullableBooleansToTrue: {
                        type: 'boolean',
                        description: 'Whether to allow comparisons between nullable boolean variables and `true`.',
                    },
                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {
                        type: 'boolean',
                        description: 'Unless this is set to `true`, the rule will error on every file whose `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or `strict`) set to `true`.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowComparingNullableBooleansToFalse: true,
            allowComparingNullableBooleansToTrue: true,
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,
        },
    ],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const compilerOptions = services.program.getCompilerOptions();
        const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');
        if (!isStrictNullChecks &&
            options.allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {
            context.report({
                loc: {
                    start: { column: 0, line: 0 },
                    end: { column: 0, line: 0 },
                },
                messageId: 'noStrictNullCheck',
            });
        }
        function getBooleanComparison(node) {
            const comparison = deconstructComparison(node);
            if (!comparison) {
                return undefined;
            }
            const { constraintType, isTypeParameter } = (0, util_1.getConstraintInfo)(checker, services.getTypeAtLocation(comparison.expression));
            if (isTypeParameter && constraintType == null) {
                return undefined;
            }
            if (isBooleanType(constraintType)) {
                return {
                    ...comparison,
                    expressionIsNullableBoolean: false,
                };
            }
            if (isNullableBoolean(constraintType)) {
                return {
                    ...comparison,
                    expressionIsNullableBoolean: true,
                };
            }
            return undefined;
        }
        function isBooleanType(expressionType) {
            return tsutils.isTypeFlagSet(expressionType, ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLiteral);
        }
        /**
         * checks if the expressionType is a union that
         *   1) contains at least one nullish type (null or undefined)
         *   2) contains at least once boolean type (true or false or boolean)
         *   3) does not contain any types besides nullish and boolean types
         */
        function isNullableBoolean(expressionType) {
            if (!expressionType.isUnion()) {
                return false;
            }
            const { types } = expressionType;
            const nonNullishTypes = types.filter(type => !tsutils.isTypeFlagSet(type, ts.TypeFlags.Undefined | ts.TypeFlags.Null));
            const hasNonNullishType = nonNullishTypes.length > 0;
            if (!hasNonNullishType) {
                return false;
            }
            const hasNullableType = nonNullishTypes.length < types.length;
            if (!hasNullableType) {
                return false;
            }
            const allNonNullishTypesAreBoolean = nonNullishTypes.every(isBooleanType);
            if (!allNonNullishTypesAreBoolean) {
                return false;
            }
            return true;
        }
        function deconstructComparison(node) {
            const comparisonType = getEqualsKind(node.operator);
            if (!comparisonType) {
                return undefined;
            }
            for (const [against, expression] of [
                [node.right, node.left],
                [node.left, node.right],
            ]) {
                if (against.type !== utils_1.AST_NODE_TYPES.Literal ||
                    typeof against.value !== 'boolean') {
                    continue;
                }
                const { value: literalBooleanInComparison } = against;
                const negated = !comparisonType.isPositive;
                return {
                    expression,
                    literalBooleanInComparison,
                    negated,
                };
            }
            return undefined;
        }
        function nodeIsUnaryNegation(node) {
            return (node.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                node.prefix &&
                node.operator === '!');
        }
        return {
            BinaryExpression(node) {
                const comparison = getBooleanComparison(node);
                if (comparison == null) {
                    return;
                }
                if (comparison.expressionIsNullableBoolean) {
                    if (comparison.literalBooleanInComparison &&
                        options.allowComparingNullableBooleansToTrue) {
                        return;
                    }
                    if (!comparison.literalBooleanInComparison &&
                        options.allowComparingNullableBooleansToFalse) {
                        return;
                    }
                }
                context.report({
                    node,
                    messageId: comparison.expressionIsNullableBoolean
                        ? comparison.literalBooleanInComparison
                            ? comparison.negated
                                ? 'comparingNullableToTrueNegated'
                                : 'comparingNullableToTrueDirect'
                            : 'comparingNullableToFalse'
                        : comparison.negated
                            ? 'negated'
                            : 'direct',
                    *fix(fixer) {
                        // 1. isUnaryNegation - parent negation
                        // 2. literalBooleanInComparison - is compared to literal boolean
                        // 3. negated - is expression negated
                        const isUnaryNegation = nodeIsUnaryNegation(node.parent);
                        const shouldNegate = comparison.negated !== comparison.literalBooleanInComparison;
                        const mutatedNode = isUnaryNegation ? node.parent : node;
                        yield fixer.replaceText(mutatedNode, context.sourceCode.getText(comparison.expression));
                        // if `isUnaryNegation === literalBooleanInComparison === !negated` is true - negate the expression
                        if (shouldNegate === isUnaryNegation) {
                            yield fixer.insertTextBefore(mutatedNode, '!');
                            // if the expression `exp` is not a strong precedence node, wrap it in parentheses
                            if (!(0, util_1.isStrongPrecedenceNode)(comparison.expression)) {
                                yield fixer.insertTextBefore(mutatedNode, '(');
                                yield fixer.insertTextAfter(mutatedNode, ')');
                            }
                        }
                        // if the expression `exp` is nullable, and we're not comparing to `true`, insert `?? true`
                        if (comparison.expressionIsNullableBoolean &&
                            !comparison.literalBooleanInComparison) {
                            // provide the default `true`
                            yield fixer.insertTextBefore(mutatedNode, '(');
                            yield fixer.insertTextAfter(mutatedNode, ' ?? true)');
                        }
                    },
                });
            },
        };
    },
});
function getEqualsKind(operator) {
    switch (operator) {
        case '!=':
            return {
                isPositive: false,
                isStrict: false,
            };
        case '!==':
            return {
                isPositive: false,
                isStrict: true,
            };
        case '==':
            return {
                isPositive: true,
                isStrict: false,
            };
        case '===':
            return {
                isPositive: true,
                isStrict: true,
            };
        default:
            return undefined;
    }
}


--------------------------------------------------------------------------------
FILE: no-unnecessary-condition.d.ts
--------------------------------------------------------------------------------

type LegacyAllowConstantLoopConditions = boolean;
type AllowConstantLoopConditions = 'always' | 'never' | 'only-allowed-literals';
export type Options = [
    {
        allowConstantLoopConditions?: AllowConstantLoopConditions | LegacyAllowConstantLoopConditions;
        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing?: boolean;
        checkTypePredicates?: boolean;
    }
];
export type MessageId = 'alwaysFalsy' | 'alwaysFalsyFunc' | 'alwaysNullish' | 'alwaysTruthy' | 'alwaysTruthyFunc' | 'comparisonBetweenLiteralTypes' | 'never' | 'neverNullish' | 'neverOptionalChain' | 'noOverlapBooleanExpression' | 'noStrictNullCheck' | 'suggestRemoveOptionalChain' | 'typeGuardAlreadyIsType';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageId, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-condition.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const assertionFunctionUtils_1 = require("../util/assertionFunctionUtils");
// #region
const nullishFlag = ts.TypeFlags.Undefined | ts.TypeFlags.Null;
function isNullishType(type) {
    return tsutils.isTypeFlagSet(type, nullishFlag);
}
function isAlwaysNullish(type) {
    return tsutils.unionConstituents(type).every(isNullishType);
}
/**
 * Note that this differs from {@link isNullableType} in that it doesn't consider
 * `any` or `unknown` to be nullable.
 */
function isPossiblyNullish(type) {
    return tsutils.unionConstituents(type).some(isNullishType);
}
function toStaticValue(type) {
    // type.isLiteral() only covers numbers/bigints and strings, hence the rest of the branches.
    if (tsutils.isBooleanLiteralType(type)) {
        return { value: tsutils.isTrueLiteralType(type) };
    }
    if (type.flags === ts.TypeFlags.Undefined) {
        return { value: undefined };
    }
    if (type.flags === ts.TypeFlags.Null) {
        return { value: null };
    }
    if (type.isLiteral()) {
        return { value: (0, util_1.getValueOfLiteralType)(type) };
    }
    return undefined;
}
const BOOL_OPERATORS = new Set([
    '<',
    '>',
    '<=',
    '>=',
    '==',
    '===',
    '!=',
    '!==',
]);
function isBoolOperator(operator) {
    return BOOL_OPERATORS.has(operator);
}
function booleanComparison(left, operator, right) {
    switch (operator) {
        case '!=':
            // eslint-disable-next-line eqeqeq -- intentionally comparing with loose equality
            return left != right;
        case '!==':
            return left !== right;
        case '<':
            // @ts-expect-error: we don't care if the comparison seems unintentional.
            return left < right;
        case '<=':
            // @ts-expect-error: we don't care if the comparison seems unintentional.
            return left <= right;
        case '==':
            // eslint-disable-next-line eqeqeq -- intentionally comparing with loose equality
            return left == right;
        case '===':
            return left === right;
        case '>':
            // @ts-expect-error: we don't care if the comparison seems unintentional.
            return left > right;
        case '>=':
            // @ts-expect-error: we don't care if the comparison seems unintentional.
            return left >= right;
    }
}
const constantLoopConditionsAllowedLiterals = new Set([
    true,
    false,
    1,
    0,
]);
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-condition',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow conditionals where the type is always truthy or always falsy',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            alwaysFalsy: 'Unnecessary conditional, value is always falsy.',
            alwaysFalsyFunc: 'This callback should return a conditional, but return is always falsy.',
            alwaysNullish: 'Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.',
            alwaysTruthy: 'Unnecessary conditional, value is always truthy.',
            alwaysTruthyFunc: 'This callback should return a conditional, but return is always truthy.',
            comparisonBetweenLiteralTypes: 'Unnecessary conditional, comparison is always {{trueOrFalse}}, since `{{left}} {{operator}} {{right}}` is {{trueOrFalse}}.',
            never: 'Unnecessary conditional, value is `never`.',
            neverNullish: 'Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.',
            neverOptionalChain: 'Unnecessary optional chain on a non-nullish value.',
            noOverlapBooleanExpression: 'Unnecessary conditional, the types have no overlap.',
            noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',
            suggestRemoveOptionalChain: 'Remove unnecessary optional chain',
            typeGuardAlreadyIsType: 'Unnecessary conditional, expression already has the type being checked by the {{typeGuardOrAssertionFunction}}.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowConstantLoopConditions: {
                        description: 'Whether to ignore constant loop conditions, such as `while (true)`.',
                        oneOf: [
                            {
                                type: 'boolean',
                                description: 'Always ignore or not ignore the loop conditions',
                            },
                            {
                                type: 'string',
                                description: 'Which situations to ignore constant conditions in.',
                                enum: ['always', 'never', 'only-allowed-literals'],
                            },
                        ],
                    },
                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {
                        type: 'boolean',
                        description: 'Whether to not error when running with a tsconfig that has strictNullChecks turned.',
                    },
                    checkTypePredicates: {
                        type: 'boolean',
                        description: 'Whether to check the asserted argument of a type predicate function for unnecessary conditions',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowConstantLoopConditions: 'never',
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,
            checkTypePredicates: false,
        },
    ],
    create(context, [{ allowConstantLoopConditions, allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing, checkTypePredicates, },]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const compilerOptions = services.program.getCompilerOptions();
        const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');
        const isNoUncheckedIndexedAccess = tsutils.isCompilerOptionEnabled(compilerOptions, 'noUncheckedIndexedAccess');
        const allowConstantLoopConditionsOption = normalizeAllowConstantLoopConditions(
        // https://github.com/typescript-eslint/typescript-eslint/issues/5439
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        allowConstantLoopConditions);
        if (!isStrictNullChecks &&
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {
            context.report({
                loc: {
                    start: { column: 0, line: 0 },
                    end: { column: 0, line: 0 },
                },
                messageId: 'noStrictNullCheck',
            });
        }
        function nodeIsArrayType(node) {
            const nodeType = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            return tsutils
                .unionConstituents(nodeType)
                .some(part => checker.isArrayType(part));
        }
        function nodeIsTupleType(node) {
            const nodeType = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            return tsutils
                .unionConstituents(nodeType)
                .some(part => checker.isTupleType(part));
        }
        function isArrayIndexExpression(node) {
            return (
            // Is an index signature
            node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                node.computed &&
                // ...into an array type
                (nodeIsArrayType(node.object) ||
                    // ... or a tuple type
                    (nodeIsTupleType(node.object) &&
                        // Exception: literal index into a tuple - will have a sound type
                        node.property.type !== utils_1.AST_NODE_TYPES.Literal)));
        }
        // Conditional is always necessary if it involves:
        //    `any` or `unknown` or a naked type variable
        function isConditionalAlwaysNecessary(type) {
            return tsutils
                .unionConstituents(type)
                .some(part => (0, util_1.isTypeAnyType)(part) ||
                (0, util_1.isTypeUnknownType)(part) ||
                (0, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeVariable));
        }
        function isNullableMemberExpression(node) {
            const objectType = services.getTypeAtLocation(node.object);
            if (node.computed) {
                const propertyType = services.getTypeAtLocation(node.property);
                return isNullablePropertyType(objectType, propertyType);
            }
            const property = node.property;
            // Get the actual property name, to account for private properties (this.#prop).
            const propertyName = context.sourceCode.getText(property);
            const propertyType = objectType
                .getProperties()
                .find(prop => prop.name === propertyName);
            if (propertyType &&
                tsutils.isSymbolFlagSet(propertyType, ts.SymbolFlags.Optional)) {
                return true;
            }
            return false;
        }
        /**
         * Checks if a conditional node is necessary:
         * if the type of the node is always true or always false, it's not necessary.
         */
        function checkNode(expression, isUnaryNotArgument = false, node = expression) {
            // Check if the node is Unary Negation expression and handle it
            if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                expression.operator === '!') {
                return checkNode(expression.argument, !isUnaryNotArgument, node);
            }
            // Since typescript array index signature types don't represent the
            //  possibility of out-of-bounds access, if we're indexing into an array
            //  just skip the check, to avoid false positives
            if (!isNoUncheckedIndexedAccess && isArrayIndexExpression(expression)) {
                return;
            }
            // When checking logical expressions, only check the right side
            //  as the left side has been checked by checkLogicalExpressionForUnnecessaryConditionals
            //
            // Unless the node is nullish coalescing, as it's common to use patterns like `nullBool ?? true` to to strict
            //  boolean checks if we inspect the right here, it'll usually be a constant condition on purpose.
            // In this case it's better to inspect the type of the expression as a whole.
            if (expression.type === utils_1.AST_NODE_TYPES.LogicalExpression &&
                expression.operator !== '??') {
                return checkNode(expression.right);
            }
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, expression);
            if (isConditionalAlwaysNecessary(type)) {
                return;
            }
            let messageId = null;
            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {
                messageId = 'never';
            }
            else if (!(0, util_1.isPossiblyTruthy)(type)) {
                messageId = !isUnaryNotArgument ? 'alwaysFalsy' : 'alwaysTruthy';
            }
            else if (!(0, util_1.isPossiblyFalsy)(type)) {
                messageId = !isUnaryNotArgument ? 'alwaysTruthy' : 'alwaysFalsy';
            }
            if (messageId) {
                context.report({ node, messageId });
            }
        }
        function checkNodeForNullish(node) {
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            // Conditional is always necessary if it involves `any`, `unknown` or a naked type parameter
            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any |
                ts.TypeFlags.Unknown |
                ts.TypeFlags.TypeParameter |
                ts.TypeFlags.TypeVariable)) {
                return;
            }
            let messageId = null;
            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {
                messageId = 'never';
            }
            else if (!isPossiblyNullish(type) &&
                !(node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                    isNullableMemberExpression(node))) {
                // Since typescript array index signature types don't represent the
                //  possibility of out-of-bounds access, if we're indexing into an array
                //  just skip the check, to avoid false positives
                if (isNoUncheckedIndexedAccess ||
                    (!isArrayIndexExpression(node) &&
                        !(node.type === utils_1.AST_NODE_TYPES.ChainExpression &&
                            node.expression.type !== utils_1.AST_NODE_TYPES.TSNonNullExpression &&
                            optionChainContainsOptionArrayIndex(node.expression)))) {
                    messageId = 'neverNullish';
                }
            }
            else if (isAlwaysNullish(type)) {
                messageId = 'alwaysNullish';
            }
            if (messageId) {
                context.report({ node, messageId });
            }
        }
        /**
         * Checks that a binary expression is necessarily conditional, reports otherwise.
         * If both sides of the binary expression are literal values, it's not a necessary condition.
         *
         * NOTE: It's also unnecessary if the types that don't overlap at all
         *    but that case is handled by the Typescript compiler itself.
         *    Known exceptions:
         *      - https://github.com/microsoft/TypeScript/issues/32627
         *      - https://github.com/microsoft/TypeScript/issues/37160 (handled)
         */
        function checkIfBoolExpressionIsNecessaryConditional(node, left, right, operator) {
            const leftType = (0, util_1.getConstrainedTypeAtLocation)(services, left);
            const rightType = (0, util_1.getConstrainedTypeAtLocation)(services, right);
            const leftStaticValue = toStaticValue(leftType);
            const rightStaticValue = toStaticValue(rightType);
            if (leftStaticValue != null && rightStaticValue != null) {
                const conditionIsTrue = booleanComparison(leftStaticValue.value, operator, rightStaticValue.value);
                context.report({
                    node,
                    messageId: 'comparisonBetweenLiteralTypes',
                    data: {
                        left: checker.typeToString(leftType),
                        operator,
                        right: checker.typeToString(rightType),
                        trueOrFalse: conditionIsTrue ? 'true' : 'false',
                    },
                });
                return;
            }
            // Workaround for https://github.com/microsoft/TypeScript/issues/37160
            if (isStrictNullChecks) {
                const UNDEFINED = ts.TypeFlags.Undefined;
                const NULL = ts.TypeFlags.Null;
                const VOID = ts.TypeFlags.Void;
                const isComparable = (type, flag) => {
                    // Allow comparison to `any`, `unknown` or a naked type parameter.
                    flag |=
                        ts.TypeFlags.Any |
                            ts.TypeFlags.Unknown |
                            ts.TypeFlags.TypeParameter |
                            ts.TypeFlags.TypeVariable;
                    // Allow loose comparison to nullish values.
                    if (operator === '==' || operator === '!=') {
                        flag |= NULL | UNDEFINED | VOID;
                    }
                    return (0, util_1.isTypeFlagSet)(type, flag);
                };
                if ((leftType.flags === UNDEFINED &&
                    !isComparable(rightType, UNDEFINED | VOID)) ||
                    (rightType.flags === UNDEFINED &&
                        !isComparable(leftType, UNDEFINED | VOID)) ||
                    (leftType.flags === NULL && !isComparable(rightType, NULL)) ||
                    (rightType.flags === NULL && !isComparable(leftType, NULL))) {
                    context.report({ node, messageId: 'noOverlapBooleanExpression' });
                    return;
                }
            }
        }
        /**
         * Checks that a logical expression contains a boolean, reports otherwise.
         */
        function checkLogicalExpressionForUnnecessaryConditionals(node) {
            if (node.operator === '??') {
                checkNodeForNullish(node.left);
                return;
            }
            // Only checks the left side, since the right side might not be "conditional" at all.
            // The right side will be checked if the LogicalExpression is used in a conditional context
            checkNode(node.left);
        }
        function checkIfWhileLoopIsNecessaryConditional(node) {
            if (allowConstantLoopConditionsOption === 'only-allowed-literals' &&
                node.test.type === utils_1.AST_NODE_TYPES.Literal &&
                constantLoopConditionsAllowedLiterals.has(node.test.value)) {
                return;
            }
            checkIfLoopIsNecessaryConditional(node);
        }
        /**
         * Checks that a testable expression of a loop is necessarily conditional, reports otherwise.
         */
        function checkIfLoopIsNecessaryConditional(node) {
            if (node.test == null) {
                // e.g. `for(;;)`
                return;
            }
            if (allowConstantLoopConditionsOption === 'always' &&
                tsutils.isTrueLiteralType((0, util_1.getConstrainedTypeAtLocation)(services, node.test))) {
                return;
            }
            checkNode(node.test);
        }
        function checkCallExpression(node) {
            if (checkTypePredicates) {
                const truthinessAssertedArgument = (0, assertionFunctionUtils_1.findTruthinessAssertedArgument)(services, node);
                if (truthinessAssertedArgument != null) {
                    checkNode(truthinessAssertedArgument);
                }
                const typeGuardAssertedArgument = (0, assertionFunctionUtils_1.findTypeGuardAssertedArgument)(services, node);
                if (typeGuardAssertedArgument != null) {
                    const typeOfArgument = (0, util_1.getConstrainedTypeAtLocation)(services, typeGuardAssertedArgument.argument);
                    if (typeOfArgument === typeGuardAssertedArgument.type) {
                        context.report({
                            node: typeGuardAssertedArgument.argument,
                            messageId: 'typeGuardAlreadyIsType',
                            data: {
                                typeGuardOrAssertionFunction: typeGuardAssertedArgument.asserts
                                    ? 'assertion function'
                                    : 'type guard',
                            },
                        });
                    }
                }
            }
            // If this is something like arr.filter(x => /*condition*/), check `condition`
            if ((0, util_1.isArrayMethodCallWithPredicate)(context, services, node) &&
                node.arguments.length) {
                const callback = node.arguments[0];
                // Inline defined functions
                if (callback.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                    callback.type === utils_1.AST_NODE_TYPES.FunctionExpression) {
                    // Two special cases, where we can directly check the node that's returned:
                    // () => something
                    if (callback.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
                        return checkNode(callback.body);
                    }
                    // () => { return something; }
                    const callbackBody = callback.body.body;
                    if (callbackBody.length === 1 &&
                        callbackBody[0].type === utils_1.AST_NODE_TYPES.ReturnStatement &&
                        callbackBody[0].argument) {
                        return checkNode(callbackBody[0].argument);
                    }
                    // Potential enhancement: could use code-path analysis to check
                    //   any function with a single return statement
                    // (Value to complexity ratio is dubious however)
                }
                // Otherwise just do type analysis on the function as a whole.
                const returnTypes = tsutils
                    .getCallSignaturesOfType((0, util_1.getConstrainedTypeAtLocation)(services, callback))
                    .map(sig => sig.getReturnType());
                if (returnTypes.length === 0) {
                    // Not a callable function, e.g. `any`
                    return;
                }
                let hasFalsyReturnTypes = false;
                let hasTruthyReturnTypes = false;
                for (const type of returnTypes) {
                    const { constraintType } = (0, util_1.getConstraintInfo)(checker, type);
                    // Predicate is always necessary if it involves `any` or `unknown`
                    if (!constraintType ||
                        (0, util_1.isTypeAnyType)(constraintType) ||
                        (0, util_1.isTypeUnknownType)(constraintType)) {
                        return;
                    }
                    if ((0, util_1.isPossiblyFalsy)(constraintType)) {
                        hasFalsyReturnTypes = true;
                    }
                    if ((0, util_1.isPossiblyTruthy)(constraintType)) {
                        hasTruthyReturnTypes = true;
                    }
                    // bail early if both a possibly-truthy and a possibly-falsy have been detected
                    if (hasFalsyReturnTypes && hasTruthyReturnTypes) {
                        return;
                    }
                }
                if (!hasFalsyReturnTypes) {
                    return context.report({
                        node: callback,
                        messageId: 'alwaysTruthyFunc',
                    });
                }
                if (!hasTruthyReturnTypes) {
                    return context.report({
                        node: callback,
                        messageId: 'alwaysFalsyFunc',
                    });
                }
            }
        }
        // Recursively searches an optional chain for an array index expression
        //  Has to search the entire chain, because an array index will "infect" the rest of the types
        //  Example:
        //  ```
        //  [{x: {y: "z"} }][n] // type is {x: {y: "z"}}
        //    ?.x // type is {y: "z"}
        //    ?.y // This access is considered "unnecessary" according to the types
        //  ```
        function optionChainContainsOptionArrayIndex(node) {
            const lhsNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;
            if (node.optional && isArrayIndexExpression(lhsNode)) {
                return true;
            }
            if (lhsNode.type === utils_1.AST_NODE_TYPES.MemberExpression ||
                lhsNode.type === utils_1.AST_NODE_TYPES.CallExpression) {
                return optionChainContainsOptionArrayIndex(lhsNode);
            }
            return false;
        }
        function isNullablePropertyType(objType, propertyType) {
            if (propertyType.isUnion()) {
                return propertyType.types.some(type => isNullablePropertyType(objType, type));
            }
            if (propertyType.isNumberLiteral() || propertyType.isStringLiteral()) {
                const propType = (0, util_1.getTypeOfPropertyOfName)(checker, objType, propertyType.value.toString());
                if (propType) {
                    return (0, util_1.isNullableType)(propType);
                }
            }
            const typeName = (0, util_1.getTypeName)(checker, propertyType);
            return checker
                .getIndexInfosOfType(objType)
                .some(info => (0, util_1.getTypeName)(checker, info.keyType) === typeName);
        }
        // Checks whether a member expression is nullable or not regardless of it's previous node.
        //  Example:
        //  ```
        //  // 'bar' is nullable if 'foo' is null.
        //  // but this function checks regardless of 'foo' type, so returns 'true'.
        //  declare const foo: { bar : { baz: string } } | null
        //  foo?.bar;
        //  ```
        function isMemberExpressionNullableOriginFromObject(node) {
            const prevType = (0, util_1.getConstrainedTypeAtLocation)(services, node.object);
            const property = node.property;
            if (prevType.isUnion() && (0, util_1.isIdentifier)(property)) {
                const isOwnNullable = prevType.types.some(type => {
                    if (node.computed) {
                        const propertyType = (0, util_1.getConstrainedTypeAtLocation)(services, node.property);
                        return isNullablePropertyType(type, propertyType);
                    }
                    const propType = (0, util_1.getTypeOfPropertyOfName)(checker, type, property.name);
                    if (propType) {
                        return (0, util_1.isNullableType)(propType);
                    }
                    const indexInfo = checker.getIndexInfosOfType(type);
                    return indexInfo.some(info => {
                        const isStringTypeName = (0, util_1.getTypeName)(checker, info.keyType) === 'string';
                        return (isStringTypeName &&
                            (isNoUncheckedIndexedAccess || (0, util_1.isNullableType)(info.type)));
                    });
                });
                return !isOwnNullable && (0, util_1.isNullableType)(prevType);
            }
            return false;
        }
        function isCallExpressionNullableOriginFromCallee(node) {
            const prevType = (0, util_1.getConstrainedTypeAtLocation)(services, node.callee);
            if (prevType.isUnion()) {
                const isOwnNullable = prevType.types.some(type => {
                    const signatures = type.getCallSignatures();
                    return signatures.some(sig => (0, util_1.isNullableType)(sig.getReturnType()));
                });
                return !isOwnNullable && (0, util_1.isNullableType)(prevType);
            }
            return false;
        }
        function isOptionableExpression(node) {
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            const isOwnNullable = node.type === utils_1.AST_NODE_TYPES.MemberExpression
                ? !isMemberExpressionNullableOriginFromObject(node)
                : node.type === utils_1.AST_NODE_TYPES.CallExpression
                    ? !isCallExpressionNullableOriginFromCallee(node)
                    : true;
            return (isConditionalAlwaysNecessary(type) ||
                (isOwnNullable && (0, util_1.isNullableType)(type)));
        }
        function checkOptionalChain(node, beforeOperator, fix) {
            // We only care if this step in the chain is optional. If just descend
            // from an optional chain, then that's fine.
            if (!node.optional) {
                return;
            }
            // Since typescript array index signature types don't represent the
            //  possibility of out-of-bounds access, if we're indexing into an array
            //  just skip the check, to avoid false positives
            if (!isNoUncheckedIndexedAccess &&
                optionChainContainsOptionArrayIndex(node)) {
                return;
            }
            const nodeToCheck = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;
            if (isOptionableExpression(nodeToCheck)) {
                return;
            }
            const questionDotOperator = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(beforeOperator, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '?.'), util_1.NullThrowsReasons.MissingToken('operator', node.type));
            context.report({
                loc: questionDotOperator.loc,
                node,
                messageId: 'neverOptionalChain',
                suggest: [
                    {
                        messageId: 'suggestRemoveOptionalChain',
                        fix(fixer) {
                            return fixer.replaceText(questionDotOperator, fix);
                        },
                    },
                ],
            });
        }
        function checkOptionalMemberExpression(node) {
            checkOptionalChain(node, node.object, node.computed ? '' : '.');
        }
        function checkOptionalCallExpression(node) {
            checkOptionalChain(node, node.callee, '');
        }
        function checkAssignmentExpression(node) {
            // Similar to checkLogicalExpressionForUnnecessaryConditionals, since
            // a ||= b is equivalent to a || (a = b)
            if (['&&=', '||='].includes(node.operator)) {
                checkNode(node.left);
            }
            else if (node.operator === '??=') {
                checkNodeForNullish(node.left);
            }
        }
        return {
            AssignmentExpression: checkAssignmentExpression,
            BinaryExpression(node) {
                const { operator } = node;
                if (isBoolOperator(operator)) {
                    checkIfBoolExpressionIsNecessaryConditional(node, node.left, node.right, operator);
                }
            },
            CallExpression: checkCallExpression,
            'CallExpression[optional = true]': checkOptionalCallExpression,
            ConditionalExpression: (node) => checkNode(node.test),
            DoWhileStatement: checkIfLoopIsNecessaryConditional,
            ForStatement: checkIfLoopIsNecessaryConditional,
            IfStatement: (node) => checkNode(node.test),
            LogicalExpression: checkLogicalExpressionForUnnecessaryConditionals,
            'MemberExpression[optional = true]': checkOptionalMemberExpression,
            SwitchCase({ parent, test }) {
                // only check `case ...:`, not `default:`
                if (test) {
                    checkIfBoolExpressionIsNecessaryConditional(test, parent.discriminant, test, '===');
                }
            },
            WhileStatement: checkIfWhileLoopIsNecessaryConditional,
        };
    },
});
function normalizeAllowConstantLoopConditions(allowConstantLoopConditions) {
    if (allowConstantLoopConditions === true) {
        return 'always';
    }
    if (allowConstantLoopConditions === false) {
        return 'never';
    }
    return allowConstantLoopConditions;
}


--------------------------------------------------------------------------------
FILE: no-unnecessary-parameter-property-assignment.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unnecessaryAssign", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-parameter-property-assignment.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const UNNECESSARY_OPERATORS = new Set(['??=', '&&=', '=', '||=']);
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-parameter-property-assignment',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow unnecessary assignment of constructor property parameter',
        },
        messages: {
            unnecessaryAssign: 'This assignment is unnecessary since it is already assigned by a parameter property.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const reportInfoStack = [];
        function isThisMemberExpression(node) {
            return (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                node.object.type === utils_1.AST_NODE_TYPES.ThisExpression);
        }
        function getPropertyName(node) {
            if (!isThisMemberExpression(node)) {
                return null;
            }
            if (node.property.type === utils_1.AST_NODE_TYPES.Identifier) {
                return node.property.name;
            }
            if (node.computed) {
                return (0, util_1.getStaticStringValue)(node.property);
            }
            return null;
        }
        function findParentFunction(node) {
            if (!node ||
                node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration ||
                node.type === utils_1.AST_NODE_TYPES.FunctionExpression ||
                node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {
                return node;
            }
            return findParentFunction(node.parent);
        }
        function findParentPropertyDefinition(node) {
            if (!node || node.type === utils_1.AST_NODE_TYPES.PropertyDefinition) {
                return node;
            }
            return findParentPropertyDefinition(node.parent);
        }
        function isConstructorFunctionExpression(node) {
            return (node?.type === utils_1.AST_NODE_TYPES.FunctionExpression &&
                utils_1.ASTUtils.isConstructor(node.parent));
        }
        function isReferenceFromParameter(node) {
            const scope = context.sourceCode.getScope(node);
            const rightRef = scope.references.find(ref => ref.identifier.name === node.name);
            return rightRef?.resolved?.defs.at(0)?.type === scope_manager_1.DefinitionType.Parameter;
        }
        function isParameterPropertyWithName(node, name) {
            return (node.type === utils_1.AST_NODE_TYPES.TSParameterProperty &&
                ((node.parameter.type === utils_1.AST_NODE_TYPES.Identifier && // constructor (public foo) {}
                    node.parameter.name === name) ||
                    (node.parameter.type === utils_1.AST_NODE_TYPES.AssignmentPattern && // constructor (public foo = 1) {}
                        node.parameter.left.name === name)));
        }
        function getIdentifier(node) {
            if (node.type === utils_1.AST_NODE_TYPES.Identifier) {
                return node;
            }
            if (node.type === utils_1.AST_NODE_TYPES.TSAsExpression ||
                node.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {
                return getIdentifier(node.expression);
            }
            return null;
        }
        function isArrowIIFE(node) {
            return (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&
                node.parent.type === utils_1.AST_NODE_TYPES.CallExpression);
        }
        return {
            ClassBody() {
                reportInfoStack.push({
                    assignedBeforeConstructor: new Set(),
                    assignedBeforeUnnecessary: new Set(),
                    unnecessaryAssignments: [],
                });
            },
            'ClassBody:exit'() {
                const { assignedBeforeConstructor, unnecessaryAssignments } = (0, util_1.nullThrows)(reportInfoStack.pop(), 'The top stack should exist');
                unnecessaryAssignments.forEach(({ name, node }) => {
                    if (assignedBeforeConstructor.has(name)) {
                        return;
                    }
                    context.report({
                        node,
                        messageId: 'unnecessaryAssign',
                    });
                });
            },
            "MethodDefinition[kind='constructor'] > FunctionExpression AssignmentExpression"(node) {
                const leftName = getPropertyName(node.left);
                if (!leftName) {
                    return;
                }
                let functionNode = findParentFunction(node);
                if (functionNode && isArrowIIFE(functionNode)) {
                    functionNode = findParentFunction(functionNode.parent);
                }
                if (!isConstructorFunctionExpression(functionNode)) {
                    return;
                }
                const { assignedBeforeUnnecessary, unnecessaryAssignments } = (0, util_1.nullThrows)(reportInfoStack.at(reportInfoStack.length - 1), 'The top of stack should exist');
                if (!UNNECESSARY_OPERATORS.has(node.operator)) {
                    assignedBeforeUnnecessary.add(leftName);
                    return;
                }
                const rightId = getIdentifier(node.right);
                if (leftName !== rightId?.name || !isReferenceFromParameter(rightId)) {
                    return;
                }
                const hasParameterProperty = functionNode.params.some(param => isParameterPropertyWithName(param, rightId.name));
                if (hasParameterProperty && !assignedBeforeUnnecessary.has(leftName)) {
                    unnecessaryAssignments.push({
                        name: leftName,
                        node,
                    });
                }
            },
            'PropertyDefinition AssignmentExpression'(node) {
                const name = getPropertyName(node.left);
                if (!name) {
                    return;
                }
                const functionNode = findParentFunction(node);
                if (functionNode &&
                    !(isArrowIIFE(functionNode) &&
                        findParentPropertyDefinition(node)?.value === functionNode.parent)) {
                    return;
                }
                const { assignedBeforeConstructor } = (0, util_1.nullThrows)(reportInfoStack.at(-1), 'The top stack should exist');
                assignedBeforeConstructor.add(name);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unnecessary-qualifier.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unnecessaryQualifier", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-qualifier.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-qualifier',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow unnecessary namespace qualifiers',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            unnecessaryQualifier: "Qualifier is unnecessary since '{{ name }}' is in scope.",
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const namespacesInScope = [];
        let currentFailedNamespaceExpression = null;
        const services = (0, util_1.getParserServices)(context);
        const esTreeNodeToTSNodeMap = services.esTreeNodeToTSNodeMap;
        const checker = services.program.getTypeChecker();
        function tryGetAliasedSymbol(symbol, checker) {
            return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)
                ? checker.getAliasedSymbol(symbol)
                : null;
        }
        function symbolIsNamespaceInScope(symbol) {
            const symbolDeclarations = symbol.getDeclarations() ?? [];
            if (symbolDeclarations.some(decl => namespacesInScope.some(ns => ns === decl))) {
                return true;
            }
            const alias = tryGetAliasedSymbol(symbol, checker);
            return alias != null && symbolIsNamespaceInScope(alias);
        }
        function getSymbolInScope(node, flags, name) {
            const scope = checker.getSymbolsInScope(node, flags);
            return scope.find(scopeSymbol => scopeSymbol.name === name);
        }
        function symbolsAreEqual(accessed, inScope) {
            return accessed === checker.getExportSymbolOfSymbol(inScope);
        }
        function qualifierIsUnnecessary(qualifier, name) {
            const namespaceSymbol = services.getSymbolAtLocation(qualifier);
            if (namespaceSymbol == null ||
                !symbolIsNamespaceInScope(namespaceSymbol)) {
                return false;
            }
            const accessedSymbol = services.getSymbolAtLocation(name);
            if (accessedSymbol == null) {
                return false;
            }
            // If the symbol in scope is different, the qualifier is necessary.
            const tsQualifier = esTreeNodeToTSNodeMap.get(qualifier);
            const fromScope = getSymbolInScope(tsQualifier, accessedSymbol.flags, context.sourceCode.getText(name));
            return !!fromScope && symbolsAreEqual(accessedSymbol, fromScope);
        }
        function visitNamespaceAccess(node, qualifier, name) {
            // Only look for nested qualifier errors if we didn't already fail on the outer qualifier.
            if (!currentFailedNamespaceExpression &&
                qualifierIsUnnecessary(qualifier, name)) {
                currentFailedNamespaceExpression = node;
                context.report({
                    node: qualifier,
                    messageId: 'unnecessaryQualifier',
                    data: {
                        name: context.sourceCode.getText(name),
                    },
                    fix(fixer) {
                        return fixer.removeRange([qualifier.range[0], name.range[0]]);
                    },
                });
            }
        }
        function enterDeclaration(node) {
            namespacesInScope.push(esTreeNodeToTSNodeMap.get(node));
        }
        function exitDeclaration() {
            namespacesInScope.pop();
        }
        function resetCurrentNamespaceExpression(node) {
            if (node === currentFailedNamespaceExpression) {
                currentFailedNamespaceExpression = null;
            }
        }
        function isPropertyAccessExpression(node) {
            return node.type === utils_1.AST_NODE_TYPES.MemberExpression && !node.computed;
        }
        function isEntityNameExpression(node) {
            return (node.type === utils_1.AST_NODE_TYPES.Identifier ||
                (isPropertyAccessExpression(node) &&
                    isEntityNameExpression(node.object)));
        }
        return {
            'ExportNamedDeclaration[declaration.type="TSEnumDeclaration"]': enterDeclaration,
            'ExportNamedDeclaration[declaration.type="TSEnumDeclaration"]:exit': exitDeclaration,
            'ExportNamedDeclaration[declaration.type="TSModuleDeclaration"]': enterDeclaration,
            'ExportNamedDeclaration[declaration.type="TSModuleDeclaration"]:exit': exitDeclaration,
            'MemberExpression:exit': resetCurrentNamespaceExpression,
            'MemberExpression[computed=false]'(node) {
                const property = node.property;
                if (isEntityNameExpression(node.object)) {
                    visitNamespaceAccess(node, node.object, property);
                }
            },
            TSEnumDeclaration: enterDeclaration,
            'TSEnumDeclaration:exit': exitDeclaration,
            'TSModuleDeclaration:exit': exitDeclaration,
            'TSModuleDeclaration > TSModuleBlock'(node) {
                enterDeclaration(node.parent);
            },
            TSQualifiedName(node) {
                visitNamespaceAccess(node, node.left, node.right);
            },
            'TSQualifiedName:exit': resetCurrentNamespaceExpression,
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unnecessary-template-expression.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageId = 'noUnnecessaryTemplateExpression';
declare const _default: TSESLint.RuleModule<"noUnnecessaryTemplateExpression", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-template-expression.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const rangeToLoc_1 = require("../util/rangeToLoc");
const evenNumOfBackslashesRegExp = /(?<!(?:[^\\]|^)(?:\\\\)*\\)/;
// '\\$' <- false
// '\\\\$' <- true
// '\\\\\\$' <- false
function endsWithUnescapedDollarSign(str) {
    return new RegExp(`${evenNumOfBackslashesRegExp.source}\\$$`).test(str);
}
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-template-expression',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow unnecessary template expressions',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            noUnnecessaryTemplateExpression: 'Template literal expression is unnecessary and can be simplified.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function isStringLike(type) {
            return (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.StringLike);
        }
        function isUnderlyingTypeString(type) {
            if (type.isUnion()) {
                return type.types.every(isStringLike);
            }
            if (type.isIntersection()) {
                return type.types.some(isStringLike);
            }
            return isStringLike(type);
        }
        function isEnumMemberType(type) {
            return tsutils.typeConstituents(type).some(t => {
                const symbol = t.getSymbol();
                return !!(symbol?.valueDeclaration && ts.isEnumMember(symbol.valueDeclaration));
            });
        }
        const isLiteral = (0, util_1.isNodeOfType)(utils_1.TSESTree.AST_NODE_TYPES.Literal);
        function isTemplateLiteral(node) {
            return node.type === utils_1.AST_NODE_TYPES.TemplateLiteral;
        }
        function isInfinityIdentifier(node) {
            return (node.type === utils_1.AST_NODE_TYPES.Identifier && node.name === 'Infinity');
        }
        function isNaNIdentifier(node) {
            return node.type === utils_1.AST_NODE_TYPES.Identifier && node.name === 'NaN';
        }
        function isFixableIdentifier(node) {
            return ((0, util_1.isUndefinedIdentifier)(node) ||
                isInfinityIdentifier(node) ||
                isNaNIdentifier(node));
        }
        function hasCommentsBetweenQuasi(startQuasi, endQuasi) {
            const startToken = (0, util_1.nullThrows)(context.sourceCode.getTokenByRangeStart(startQuasi.range[0]), util_1.NullThrowsReasons.MissingToken('`${', 'opening template literal'));
            const endToken = (0, util_1.nullThrows)(context.sourceCode.getTokenByRangeStart(endQuasi.range[0]), util_1.NullThrowsReasons.MissingToken('}', 'closing template literal'));
            return context.sourceCode.commentsExistBetween(startToken, endToken);
        }
        function isTrivialInterpolation(node) {
            return (node.quasis.length === 2 &&
                node.quasis[0].value.raw === '' &&
                node.quasis[1].value.raw === '');
        }
        function getInterpolations(node) {
            if (node.type === utils_1.AST_NODE_TYPES.TemplateLiteral) {
                return node.expressions;
            }
            return node.types;
        }
        function getInterpolationInfos(node) {
            return getInterpolations(node).map((interpolation, index) => ({
                interpolation,
                nextQuasi: node.quasis[index + 1],
                prevQuasi: node.quasis[index],
            }));
        }
        function getLiteral(node) {
            const maybeLiteral = node.type === utils_1.AST_NODE_TYPES.TSLiteralType ? node.literal : node;
            return isLiteral(maybeLiteral) ? maybeLiteral : null;
        }
        function getTemplateLiteral(node) {
            const maybeTemplateLiteral = node.type === utils_1.AST_NODE_TYPES.TSLiteralType ? node.literal : node;
            return isTemplateLiteral(maybeTemplateLiteral)
                ? maybeTemplateLiteral
                : null;
        }
        function reportSingleInterpolation(node) {
            const interpolations = getInterpolations(node);
            context.report({
                loc: (0, rangeToLoc_1.rangeToLoc)(context.sourceCode, [
                    interpolations[0].range[0] - 2,
                    interpolations[0].range[1] + 1,
                ]),
                messageId: 'noUnnecessaryTemplateExpression',
                fix(fixer) {
                    const wrappingCode = (0, util_1.getMovedNodeCode)({
                        destinationNode: node,
                        nodeToMove: interpolations[0],
                        sourceCode: context.sourceCode,
                    });
                    return fixer.replaceText(node, wrappingCode);
                },
            });
        }
        function isUnnecessaryValueInterpolation({ interpolation, nextQuasi, prevQuasi, }) {
            if (hasCommentsBetweenQuasi(prevQuasi, nextQuasi)) {
                return false;
            }
            if (isFixableIdentifier(interpolation)) {
                return true;
            }
            if (isLiteral(interpolation)) {
                // allow trailing whitespace literal
                if (startsWithNewLine(nextQuasi.value.raw)) {
                    return !(typeof interpolation.value === 'string' &&
                        isWhitespace(interpolation.value));
                }
                return true;
            }
            if (isTemplateLiteral(interpolation)) {
                // allow trailing whitespace literal
                if (startsWithNewLine(nextQuasi.value.raw)) {
                    return !(interpolation.quasis.length === 1 &&
                        isWhitespace(interpolation.quasis[0].value.raw));
                }
                return true;
            }
            return false;
        }
        function isUnncessaryTypeInterpolation({ interpolation, nextQuasi, prevQuasi, }) {
            if (hasCommentsBetweenQuasi(prevQuasi, nextQuasi)) {
                return false;
            }
            const literal = getLiteral(interpolation);
            if (literal) {
                // allow trailing whitespace literal
                if (startsWithNewLine(nextQuasi.value.raw)) {
                    return !(typeof literal.value === 'string' && isWhitespace(literal.value));
                }
                return true;
            }
            if (interpolation.type === utils_1.AST_NODE_TYPES.TSNullKeyword ||
                interpolation.type === utils_1.AST_NODE_TYPES.TSUndefinedKeyword) {
                return true;
            }
            const templateLiteral = getTemplateLiteral(interpolation);
            if (templateLiteral) {
                // allow trailing whitespace literal
                if (startsWithNewLine(nextQuasi.value.raw)) {
                    return !(templateLiteral.quasis.length === 1 &&
                        isWhitespace(templateLiteral.quasis[0].value.raw));
                }
                return true;
            }
            return false;
        }
        function getReportDescriptors(infos) {
            let nextCharacterIsOpeningCurlyBrace = false;
            const reportDescriptors = [];
            const reversedInfos = [...infos].reverse();
            for (const { interpolation, nextQuasi, prevQuasi } of reversedInfos) {
                const fixers = [];
                if (nextQuasi.value.raw !== '') {
                    nextCharacterIsOpeningCurlyBrace =
                        nextQuasi.value.raw.startsWith('{');
                }
                const literal = getLiteral(interpolation);
                const templateLiteral = getTemplateLiteral(interpolation);
                if (literal) {
                    let escapedValue = (typeof literal.value === 'string'
                        ? // The value is already a string, so we're removing quotes:
                            // "'va`lue'" -> "va`lue"
                            literal.raw.slice(1, -1)
                        : // The value may be one of number | bigint | boolean | RegExp | null.
                            // In regular expressions, we escape every backslash
                            String(literal.value).replaceAll('\\', '\\\\'))
                        // The string or RegExp may contain ` or ${.
                        // We want both of these to be escaped in the final template expression.
                        //
                        // A pair of backslashes means "escaped backslash", so backslashes
                        // from this pair won't escape ` or ${. Therefore, to escape these
                        // sequences in the resulting template expression, we need to escape
                        // all sequences that are preceded by an even number of backslashes.
                        //
                        // This RegExp does the following transformations:
                        // \` -> \`
                        // \\` -> \\\`
                        // \${ -> \${
                        // \\${ -> \\\${
                        .replaceAll(new RegExp(`${evenNumOfBackslashesRegExp.source}(\`|\\\${)`, 'g'), '\\$1');
                    // `...${'...$'}{...`
                    //           ^^^^
                    if (nextCharacterIsOpeningCurlyBrace &&
                        endsWithUnescapedDollarSign(escapedValue)) {
                        escapedValue = escapedValue.replaceAll(/\$$/g, '\\$');
                    }
                    if (escapedValue.length !== 0) {
                        nextCharacterIsOpeningCurlyBrace = escapedValue.startsWith('{');
                    }
                    fixers.push(fixer => [fixer.replaceText(literal, escapedValue)]);
                }
                else if (templateLiteral) {
                    // Since we iterate from the last expression to the first,
                    // a subsequent expression can tell the current expression
                    // that it starts with {.
                    //
                    // `... ${`... $`}${'{...'} ...`
                    //             ^     ^ subsequent expression starts with {
                    //             current expression ends with a dollar sign,
                    //             so '$' + '{' === '${' (bad news for us).
                    //             Let's escape the dollar sign at the end.
                    if (nextCharacterIsOpeningCurlyBrace &&
                        endsWithUnescapedDollarSign(templateLiteral.quasis[templateLiteral.quasis.length - 1].value
                            .raw)) {
                        fixers.push(fixer => [
                            fixer.replaceTextRange([templateLiteral.range[1] - 2, templateLiteral.range[1] - 2], '\\'),
                        ]);
                    }
                    if (templateLiteral.quasis.length === 1 &&
                        templateLiteral.quasis[0].value.raw.length !== 0) {
                        nextCharacterIsOpeningCurlyBrace =
                            templateLiteral.quasis[0].value.raw.startsWith('{');
                    }
                    // Remove the beginning and trailing backtick characters.
                    fixers.push(fixer => [
                        fixer.removeRange([
                            templateLiteral.range[0],
                            templateLiteral.range[0] + 1,
                        ]),
                        fixer.removeRange([
                            templateLiteral.range[1] - 1,
                            templateLiteral.range[1],
                        ]),
                    ]);
                }
                else {
                    nextCharacterIsOpeningCurlyBrace = false;
                }
                // `... $${'{...'} ...`
                //      ^^^^^
                if (nextCharacterIsOpeningCurlyBrace &&
                    endsWithUnescapedDollarSign(prevQuasi.value.raw)) {
                    fixers.push(fixer => [
                        fixer.replaceTextRange([prevQuasi.range[1] - 3, prevQuasi.range[1] - 2], '\\$'),
                    ]);
                }
                const warnLocStart = prevQuasi.range[1] - 2;
                const warnLocEnd = nextQuasi.range[0] + 1;
                reportDescriptors.push({
                    loc: (0, rangeToLoc_1.rangeToLoc)(context.sourceCode, [warnLocStart, warnLocEnd]),
                    messageId: 'noUnnecessaryTemplateExpression',
                    fix(fixer) {
                        return [
                            // Remove the quasis' parts that are related to the current expression.
                            fixer.removeRange([warnLocStart, interpolation.range[0]]),
                            fixer.removeRange([interpolation.range[1], warnLocEnd]),
                            ...fixers.flatMap(cb => cb(fixer)),
                        ];
                    },
                });
            }
            return reportDescriptors;
        }
        return {
            TemplateLiteral(node) {
                if (node.parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {
                    return;
                }
                if (isTrivialInterpolation(node) &&
                    !hasCommentsBetweenQuasi(node.quasis[0], node.quasis[1])) {
                    const { constraintType } = (0, util_1.getConstraintInfo)(checker, services.getTypeAtLocation(node.expressions[0]));
                    if (constraintType && isUnderlyingTypeString(constraintType)) {
                        reportSingleInterpolation(node);
                        return;
                    }
                }
                const infos = getInterpolationInfos(node).filter(isUnnecessaryValueInterpolation);
                for (const reportDescriptor of getReportDescriptors(infos)) {
                    context.report(reportDescriptor);
                }
            },
            TSTemplateLiteralType(node) {
                if (isTrivialInterpolation(node) &&
                    !hasCommentsBetweenQuasi(node.quasis[0], node.quasis[1])) {
                    const { constraintType, isTypeParameter } = (0, util_1.getConstraintInfo)(checker, services.getTypeAtLocation(node.types[0]));
                    if (constraintType &&
                        !isTypeParameter &&
                        isUnderlyingTypeString(constraintType) &&
                        !isEnumMemberType(constraintType)) {
                        reportSingleInterpolation(node);
                        return;
                    }
                }
                const infos = getInterpolationInfos(node).filter(isUnncessaryTypeInterpolation);
                for (const reportDescriptor of getReportDescriptors(infos)) {
                    context.report(reportDescriptor);
                }
            },
        };
    },
});
function isWhitespace(x) {
    // allow empty string too since we went to allow
    // `      ${''}
    // `;
    //
    // in addition to
    // `${'        '}
    // `;
    //
    return /^\s*$/.test(x);
}
function startsWithNewLine(x) {
    return x.startsWith('\n') || x.startsWith('\r\n');
}


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-arguments.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'unnecessaryTypeParameter';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unnecessaryTypeParameter", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-arguments.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-type-arguments',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow type arguments that are equal to the default',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            unnecessaryTypeParameter: 'This is the default value for this type parameter, so it can be omitted.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function getTypeForComparison(type) {
            if ((0, util_1.isTypeReferenceType)(type)) {
                return {
                    type: type.target,
                    typeArguments: checker.getTypeArguments(type),
                };
            }
            return {
                type,
                typeArguments: [],
            };
        }
        function checkTSArgsAndParameters(esParameters, typeParameters) {
            // Just check the last one. Must specify previous type parameters if the last one is specified.
            const i = esParameters.params.length - 1;
            const arg = esParameters.params[i];
            const param = typeParameters.at(i);
            if (!param?.default) {
                return;
            }
            // TODO: would like checker.areTypesEquivalent. https://github.com/Microsoft/TypeScript/issues/13502
            const defaultType = checker.getTypeAtLocation(param.default);
            const argType = services.getTypeAtLocation(arg);
            // this check should handle some of the most simple cases of like strings, numbers, etc
            if (defaultType !== argType) {
                // For more complex types (like aliases to generic object types) - TS won't always create a
                // global shared type object for the type - so we need to resort to manually comparing the
                // reference type and the passed type arguments.
                // Also - in case there are aliases - we need to resolve them before we do checks
                const defaultTypeResolved = getTypeForComparison(defaultType);
                const argTypeResolved = getTypeForComparison(argType);
                if (
                // ensure the resolved type AND all the parameters are the same
                defaultTypeResolved.type !== argTypeResolved.type ||
                    defaultTypeResolved.typeArguments.length !==
                        argTypeResolved.typeArguments.length ||
                    defaultTypeResolved.typeArguments.some((t, i) => t !== argTypeResolved.typeArguments[i])) {
                    return;
                }
            }
            context.report({
                node: arg,
                messageId: 'unnecessaryTypeParameter',
                fix: fixer => fixer.removeRange(i === 0
                    ? esParameters.range
                    : [esParameters.params[i - 1].range[1], arg.range[1]]),
            });
        }
        return {
            TSTypeParameterInstantiation(node) {
                const expression = services.esTreeNodeToTSNodeMap.get(node);
                const typeParameters = getTypeParametersFromNode(node, expression, checker);
                if (typeParameters) {
                    checkTSArgsAndParameters(node, typeParameters);
                }
            },
        };
    },
});
function getTypeParametersFromNode(node, tsNode, checker) {
    if (ts.isExpressionWithTypeArguments(tsNode)) {
        return getTypeParametersFromType(node, tsNode.expression, checker);
    }
    if (ts.isTypeReferenceNode(tsNode)) {
        return getTypeParametersFromType(node, tsNode.typeName, checker);
    }
    if (ts.isCallExpression(tsNode) ||
        ts.isNewExpression(tsNode) ||
        ts.isTaggedTemplateExpression(tsNode) ||
        ts.isJsxOpeningElement(tsNode) ||
        ts.isJsxSelfClosingElement(tsNode)) {
        return getTypeParametersFromCall(node, tsNode, checker);
    }
    return undefined;
}
function getTypeParametersFromType(node, type, checker) {
    const symAtLocation = checker.getSymbolAtLocation(type);
    if (!symAtLocation) {
        return undefined;
    }
    const sym = getAliasedSymbol(symAtLocation, checker);
    const declarations = sym.getDeclarations();
    if (!declarations) {
        return undefined;
    }
    const sortedDeclarations = sortDeclarationsByTypeValueContext(node, declarations);
    return (0, util_1.findFirstResult)(sortedDeclarations, decl => {
        if (ts.isTypeAliasDeclaration(decl) ||
            ts.isInterfaceDeclaration(decl) ||
            ts.isClassLike(decl)) {
            return decl.typeParameters;
        }
        if (ts.isVariableDeclaration(decl)) {
            return getConstructSignatureDeclaration(symAtLocation, checker)
                ?.typeParameters;
        }
        return undefined;
    });
}
function getTypeParametersFromCall(node, tsNode, checker) {
    const sig = checker.getResolvedSignature(tsNode);
    const sigDecl = sig?.getDeclaration();
    if (!sigDecl) {
        return ts.isNewExpression(tsNode)
            ? getTypeParametersFromType(node, tsNode.expression, checker)
            : undefined;
    }
    return sigDecl.typeParameters;
}
function getAliasedSymbol(symbol, checker) {
    return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)
        ? checker.getAliasedSymbol(symbol)
        : symbol;
}
function isInTypeContext(node) {
    return (node.parent.type === utils_1.AST_NODE_TYPES.TSInterfaceHeritage ||
        node.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference ||
        node.parent.type === utils_1.AST_NODE_TYPES.TSClassImplements);
}
function isTypeContextDeclaration(decl) {
    return ts.isTypeAliasDeclaration(decl) || ts.isInterfaceDeclaration(decl);
}
function typeFirstCompare(declA, declB) {
    const aIsType = isTypeContextDeclaration(declA);
    const bIsType = isTypeContextDeclaration(declB);
    return Number(bIsType) - Number(aIsType);
}
function sortDeclarationsByTypeValueContext(node, declarations) {
    const sorted = [...declarations].sort(typeFirstCompare);
    if (isInTypeContext(node)) {
        return sorted;
    }
    return sorted.reverse();
}
function getConstructSignatureDeclaration(symbol, checker) {
    const type = checker.getTypeOfSymbol(symbol);
    const sig = type.getConstructSignatures();
    return sig.at(0)?.getDeclaration();
}


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-assertion.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        checkLiteralConstAssertions?: boolean;
        typesToIgnore?: string[];
    }
];
export type MessageIds = 'contextuallyUnnecessary' | 'unnecessaryAssertion';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-assertion.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-type-assertion',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow type assertions that do not change the type of an expression',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            contextuallyUnnecessary: 'This assertion is unnecessary since the receiver accepts the original type of the expression.',
            unnecessaryAssertion: 'This assertion is unnecessary since it does not change the type of the expression.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    checkLiteralConstAssertions: {
                        type: 'boolean',
                        description: 'Whether to check literal const assertions.',
                    },
                    typesToIgnore: {
                        type: 'array',
                        description: 'A list of type names to ignore.',
                        items: {
                            type: 'string',
                        },
                    },
                },
            },
        ],
    },
    defaultOptions: [{}],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const compilerOptions = services.program.getCompilerOptions();
        /**
         * Returns true if there's a chance the variable has been used before a value has been assigned to it
         */
        function isPossiblyUsedBeforeAssigned(node) {
            const declaration = (0, util_1.getDeclaration)(services, node);
            if (!declaration) {
                // don't know what the declaration is for some reason, so just assume the worst
                return true;
            }
            if (
            // non-strict mode doesn't care about used before assigned errors
            tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks') &&
                // ignore class properties as they are compile time guarded
                // also ignore function arguments as they can't be used before defined
                ts.isVariableDeclaration(declaration)) {
                // For var declarations, we need to check whether the node
                // is actually in a descendant of its declaration or not. If not,
                // it may be used before defined.
                // eg
                // if (Math.random() < 0.5) {
                //     var x: number  = 2;
                // } else {
                //     x!.toFixed();
                // }
                if (ts.isVariableDeclarationList(declaration.parent) &&
                    // var
                    declaration.parent.flags === ts.NodeFlags.None &&
                    // If they are not in the same file it will not exist.
                    // This situation must not occur using before defined.
                    services.tsNodeToESTreeNodeMap.has(declaration)) {
                    const declaratorNode = services.tsNodeToESTreeNodeMap.get(declaration);
                    const scope = context.sourceCode.getScope(node);
                    const declaratorScope = context.sourceCode.getScope(declaratorNode);
                    let parentScope = declaratorScope;
                    while ((parentScope = parentScope.upper)) {
                        if (parentScope === scope) {
                            return true;
                        }
                    }
                }
                if (
                // is it `const x!: number`
                declaration.initializer == null &&
                    declaration.exclamationToken == null &&
                    declaration.type != null) {
                    // check if the defined variable type has changed since assignment
                    const declarationType = checker.getTypeFromTypeNode(declaration.type);
                    const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);
                    if (declarationType === type &&
                        // `declare`s are never narrowed, so never skip them
                        !(ts.isVariableDeclarationList(declaration.parent) &&
                            ts.isVariableStatement(declaration.parent.parent) &&
                            tsutils.includesModifier((0, util_1.getModifiers)(declaration.parent.parent), ts.SyntaxKind.DeclareKeyword))) {
                        // possibly used before assigned, so just skip it
                        // better to false negative and skip it, than false positive and fix to compile erroring code
                        //
                        // no better way to figure this out right now
                        // https://github.com/Microsoft/TypeScript/issues/31124
                        return true;
                    }
                }
            }
            return false;
        }
        function isConstAssertion(node) {
            return (node.type === utils_1.AST_NODE_TYPES.TSTypeReference &&
                node.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.typeName.name === 'const');
        }
        function isTemplateLiteralWithExpressions(expression) {
            return (expression.type === utils_1.AST_NODE_TYPES.TemplateLiteral &&
                expression.expressions.length !== 0);
        }
        function isImplicitlyNarrowedLiteralDeclaration({ expression, parent, }) {
            /**
             * Even on `const` variable declarations, template literals with expressions can sometimes be widened without a type assertion.
             * @see https://github.com/typescript-eslint/typescript-eslint/issues/8737
             */
            if (isTemplateLiteralWithExpressions(expression)) {
                return false;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const maybeDeclarationNode = parent.parent;
            return ((maybeDeclarationNode.type === utils_1.AST_NODE_TYPES.VariableDeclaration &&
                maybeDeclarationNode.kind === 'const') ||
                (parent.type === utils_1.AST_NODE_TYPES.PropertyDefinition && parent.readonly));
        }
        function isTypeUnchanged(uncast, cast) {
            if (uncast === cast) {
                return true;
            }
            if ((0, util_1.isTypeFlagSet)(uncast, ts.TypeFlags.Undefined) &&
                (0, util_1.isTypeFlagSet)(cast, ts.TypeFlags.Undefined) &&
                tsutils.isCompilerOptionEnabled(compilerOptions, 'exactOptionalPropertyTypes')) {
                const uncastParts = tsutils
                    .unionConstituents(uncast)
                    .filter(part => !(0, util_1.isTypeFlagSet)(part, ts.TypeFlags.Undefined));
                const castParts = tsutils
                    .unionConstituents(cast)
                    .filter(part => !(0, util_1.isTypeFlagSet)(part, ts.TypeFlags.Undefined));
                if (uncastParts.length !== castParts.length) {
                    return false;
                }
                const uncastPartsSet = new Set(uncastParts);
                return castParts.every(part => uncastPartsSet.has(part));
            }
            return false;
        }
        function isTypeLiteral(type) {
            return type.isLiteral() || tsutils.isBooleanLiteralType(type);
        }
        function isIIFE(expression) {
            return (expression.type === utils_1.AST_NODE_TYPES.CallExpression &&
                (expression.callee.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                    expression.callee.type === utils_1.AST_NODE_TYPES.FunctionExpression));
        }
        function getUncastType(node) {
            // Special handling for IIFE: extract the function's return type
            if (isIIFE(node.expression)) {
                const callee = node.expression.callee;
                const functionType = services.getTypeAtLocation(callee);
                const signatures = functionType.getCallSignatures();
                if (signatures.length > 0) {
                    const returnType = checker.getReturnTypeOfSignature(signatures[0]);
                    // If the function has no explicit return type annotation and returns undefined,
                    // treat it as void (TypeScript infers () => {} as () => undefined, but it should be void)
                    if (callee.returnType == null &&
                        (0, util_1.isTypeFlagSet)(returnType, ts.TypeFlags.Undefined)) {
                        return checker.getVoidType();
                    }
                    return returnType;
                }
            }
            return services.getTypeAtLocation(node.expression);
        }
        return {
            'TSAsExpression, TSTypeAssertion'(node) {
                if (options.typesToIgnore?.includes(context.sourceCode.getText(node.typeAnnotation))) {
                    return;
                }
                const castType = services.getTypeAtLocation(node);
                const castTypeIsLiteral = isTypeLiteral(castType);
                const typeAnnotationIsConstAssertion = isConstAssertion(node.typeAnnotation);
                if (!options.checkLiteralConstAssertions &&
                    castTypeIsLiteral &&
                    typeAnnotationIsConstAssertion) {
                    return;
                }
                const uncastType = getUncastType(node);
                const typeIsUnchanged = isTypeUnchanged(uncastType, castType);
                const wouldSameTypeBeInferred = castTypeIsLiteral
                    ? isImplicitlyNarrowedLiteralDeclaration(node)
                    : !typeAnnotationIsConstAssertion;
                if (typeIsUnchanged && wouldSameTypeBeInferred) {
                    context.report({
                        node,
                        messageId: 'unnecessaryAssertion',
                        fix(fixer) {
                            if (node.type === utils_1.AST_NODE_TYPES.TSTypeAssertion) {
                                const openingAngleBracket = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(node.typeAnnotation, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator &&
                                    token.value === '<'), util_1.NullThrowsReasons.MissingToken('<', 'type annotation'));
                                const closingAngleBracket = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.typeAnnotation, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator &&
                                    token.value === '>'), util_1.NullThrowsReasons.MissingToken('>', 'type annotation'));
                                // < ( number ) > ( 3 + 5 )
                                // ^---remove---^
                                return fixer.removeRange([
                                    openingAngleBracket.range[0],
                                    closingAngleBracket.range[1],
                                ]);
                            }
                            // `as` is always present in TSAsExpression
                            const asToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.expression, token => token.type === utils_1.AST_TOKEN_TYPES.Identifier &&
                                token.value === 'as'), util_1.NullThrowsReasons.MissingToken('>', 'type annotation'));
                            const tokenBeforeAs = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(asToken, {
                                includeComments: true,
                            }), util_1.NullThrowsReasons.MissingToken('comment', 'as'));
                            // ( 3 + 5 )  as  number
                            //          ^--remove--^
                            return fixer.removeRange([tokenBeforeAs.range[1], node.range[1]]);
                        },
                    });
                }
                // TODO - add contextually unnecessary check for this
            },
            TSNonNullExpression(node) {
                const removeExclamationFix = fixer => {
                    const exclamationToken = (0, util_1.nullThrows)(context.sourceCode.getLastToken(node, token => token.value === '!'), util_1.NullThrowsReasons.MissingToken('exclamation mark', 'non-null assertion'));
                    return fixer.removeRange(exclamationToken.range);
                };
                if (node.parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression &&
                    node.parent.operator === '=') {
                    if (node.parent.left === node) {
                        context.report({
                            node,
                            messageId: 'contextuallyUnnecessary',
                            fix: removeExclamationFix,
                        });
                    }
                    // for all other = assignments we ignore non-null checks
                    // this is because non-null assertions can change the type-flow of the code
                    // so whilst they might be unnecessary for the assignment - they are necessary
                    // for following code
                    return;
                }
                const originalNode = services.esTreeNodeToTSNodeMap.get(node);
                const type = (0, util_1.getConstrainedTypeAtLocation)(services, node.expression);
                if (!(0, util_1.isNullableType)(type)) {
                    if (node.expression.type === utils_1.AST_NODE_TYPES.Identifier &&
                        isPossiblyUsedBeforeAssigned(node.expression)) {
                        return;
                    }
                    context.report({
                        node,
                        messageId: 'unnecessaryAssertion',
                        fix: removeExclamationFix,
                    });
                }
                else {
                    // we know it's a nullable type
                    // so figure out if the variable is used in a place that accepts nullable types
                    const contextualType = (0, util_1.getContextualType)(checker, originalNode);
                    if (contextualType) {
                        if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Unknown) &&
                            !(0, util_1.isTypeFlagSet)(contextualType, ts.TypeFlags.Unknown)) {
                            return;
                        }
                        // in strict mode you can't assign null to undefined, so we have to make sure that
                        // the two types share a nullable type
                        const typeIncludesUndefined = (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Undefined);
                        const typeIncludesNull = (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Null);
                        const typeIncludesVoid = (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Void);
                        const contextualTypeIncludesUndefined = (0, util_1.isTypeFlagSet)(contextualType, ts.TypeFlags.Undefined);
                        const contextualTypeIncludesNull = (0, util_1.isTypeFlagSet)(contextualType, ts.TypeFlags.Null);
                        const contextualTypeIncludesVoid = (0, util_1.isTypeFlagSet)(contextualType, ts.TypeFlags.Void);
                        // make sure that the parent accepts the same types
                        // i.e. assigning `string | null | undefined` to `string | undefined` is invalid
                        const isValidUndefined = typeIncludesUndefined
                            ? contextualTypeIncludesUndefined
                            : true;
                        const isValidNull = typeIncludesNull
                            ? contextualTypeIncludesNull
                            : true;
                        const isValidVoid = typeIncludesVoid
                            ? contextualTypeIncludesVoid
                            : true;
                        if (isValidUndefined && isValidNull && isValidVoid) {
                            context.report({
                                node,
                                messageId: 'contextuallyUnnecessary',
                                fix: removeExclamationFix,
                            });
                        }
                    }
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-constraint.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"removeUnnecessaryConstraint" | "unnecessaryConstraint", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-constraint.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const node_path_1 = require("node:path");
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-type-constraint',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow unnecessary constraints on generic types',
            recommended: 'recommended',
        },
        hasSuggestions: true,
        messages: {
            removeUnnecessaryConstraint: 'Remove the unnecessary `{{constraint}}` constraint.',
            unnecessaryConstraint: 'Constraining the generic type `{{name}}` to `{{constraint}}` does nothing and is unnecessary.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        // In theory, we could use the type checker for more advanced constraint types...
        // ...but in practice, these types are rare, and likely not worth requiring type info.
        // https://github.com/typescript-eslint/typescript-eslint/pull/2516#discussion_r495731858
        const unnecessaryConstraints = new Map([
            [utils_1.AST_NODE_TYPES.TSAnyKeyword, 'any'],
            [utils_1.AST_NODE_TYPES.TSUnknownKeyword, 'unknown'],
        ]);
        function checkRequiresGenericDeclarationDisambiguation(filename) {
            const pathExt = (0, node_path_1.extname)(filename).toLocaleLowerCase();
            switch (pathExt) {
                case ts.Extension.Cts:
                case ts.Extension.Mts:
                case ts.Extension.Tsx:
                    return true;
                default:
                    return false;
            }
        }
        const requiresGenericDeclarationDisambiguation = checkRequiresGenericDeclarationDisambiguation(context.filename);
        const checkNode = (node, inArrowFunction) => {
            const constraint = unnecessaryConstraints.get(node.constraint.type);
            function shouldAddTrailingComma() {
                if (!inArrowFunction || !requiresGenericDeclarationDisambiguation) {
                    return false;
                }
                // Only <T>() => {} would need trailing comma
                return (node.parent.params.length ===
                    1 &&
                    context.sourceCode.getTokensAfter(node)[0].value !== ',' &&
                    !node.default);
            }
            if (constraint) {
                context.report({
                    node,
                    messageId: 'unnecessaryConstraint',
                    data: {
                        name: node.name.name,
                        constraint,
                    },
                    suggest: [
                        {
                            messageId: 'removeUnnecessaryConstraint',
                            data: {
                                constraint,
                            },
                            fix(fixer) {
                                return fixer.replaceTextRange([node.name.range[1], node.constraint.range[1]], shouldAddTrailingComma() ? ',' : '');
                            },
                        },
                    ],
                });
            }
        };
        return {
            ':not(ArrowFunctionExpression) > TSTypeParameterDeclaration > TSTypeParameter[constraint]'(node) {
                checkNode(node, false);
            },
            'ArrowFunctionExpression > TSTypeParameterDeclaration > TSTypeParameter[constraint]'(node) {
                checkNode(node, true);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-conversion.d.ts
--------------------------------------------------------------------------------

type MessageIds = 'suggestRemove' | 'suggestSatisfies' | 'unnecessaryTypeConversion';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-conversion.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
function isEnumType(type) {
    return (type.getFlags() & ts.TypeFlags.EnumLike) !== 0;
}
function isEnumMemberType(type) {
    const symbol = type.getSymbol();
    if (!symbol) {
        return false;
    }
    return (symbol.flags & ts.SymbolFlags.EnumMember) !== 0;
}
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-type-conversion',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow conversion idioms when they do not change the type or value of the expression',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            suggestRemove: 'Remove the type conversion.',
            suggestSatisfies: 'Instead, assert that the value satisfies the {{type}} type.',
            unnecessaryTypeConversion: '{{violation}} does not change the type or value of the {{type}}.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function doesUnderlyingTypeMatchFlag(type, typeFlag) {
            return tsutils
                .unionConstituents(type)
                .every(t => (0, util_1.isTypeFlagSet)(t, typeFlag));
        }
        const services = (0, util_1.getParserServices)(context);
        function handleUnaryOperator(node, typeFlag, typeString, violation, isDoubleOperator) {
            const outerNode = isDoubleOperator ? node.parent : node;
            const type = services.getTypeAtLocation(node.argument);
            if (doesUnderlyingTypeMatchFlag(type, typeFlag)) {
                const wrappingFixerParams = {
                    node: outerNode,
                    innerNode: [node.argument],
                    sourceCode: context.sourceCode,
                };
                context.report({
                    loc: {
                        start: outerNode.loc.start,
                        end: {
                            column: node.loc.start.column + 1,
                            line: node.loc.start.line,
                        },
                    },
                    messageId: 'unnecessaryTypeConversion',
                    data: { type: typeString, violation },
                    suggest: [
                        {
                            messageId: 'suggestRemove',
                            fix: (0, util_1.getWrappingFixer)(wrappingFixerParams),
                        },
                        {
                            messageId: 'suggestSatisfies',
                            data: { type: typeString },
                            fix: (0, util_1.getWrappingFixer)({
                                ...wrappingFixerParams,
                                wrap: expr => `${expr} satisfies ${typeString}`,
                            }),
                        },
                    ],
                });
            }
        }
        return {
            'AssignmentExpression[operator = "+="]'(node) {
                if (node.right.type === utils_1.AST_NODE_TYPES.Literal &&
                    node.right.value === '' &&
                    doesUnderlyingTypeMatchFlag(services.getTypeAtLocation(node.left), ts.TypeFlags.StringLike)) {
                    const wrappingFixerParams = {
                        node,
                        innerNode: [node.left],
                        sourceCode: context.sourceCode,
                    };
                    context.report({
                        node,
                        messageId: 'unnecessaryTypeConversion',
                        data: {
                            type: 'string',
                            violation: "Concatenating a string with ''",
                        },
                        suggest: [
                            {
                                messageId: 'suggestRemove',
                                fix: node.parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement
                                    ? (fixer) => [
                                        fixer.removeRange([
                                            node.parent.range[0],
                                            node.parent.range[1],
                                        ]),
                                    ]
                                    : (0, util_1.getWrappingFixer)(wrappingFixerParams),
                            },
                            {
                                messageId: 'suggestSatisfies',
                                data: { type: 'string' },
                                fix: (0, util_1.getWrappingFixer)({
                                    ...wrappingFixerParams,
                                    wrap: expr => `${expr} satisfies string`,
                                }),
                            },
                        ],
                    });
                }
            },
            'BinaryExpression[operator = "+"]'(node) {
                if (node.right.type === utils_1.AST_NODE_TYPES.Literal &&
                    node.right.value === '' &&
                    doesUnderlyingTypeMatchFlag(services.getTypeAtLocation(node.left), ts.TypeFlags.StringLike)) {
                    const wrappingFixerParams = {
                        node,
                        innerNode: [node.left],
                        sourceCode: context.sourceCode,
                    };
                    context.report({
                        loc: {
                            start: node.left.loc.end,
                            end: node.loc.end,
                        },
                        messageId: 'unnecessaryTypeConversion',
                        data: {
                            type: 'string',
                            violation: "Concatenating a string with ''",
                        },
                        suggest: [
                            {
                                messageId: 'suggestRemove',
                                fix: (0, util_1.getWrappingFixer)(wrappingFixerParams),
                            },
                            {
                                messageId: 'suggestSatisfies',
                                data: { type: 'string' },
                                fix: (0, util_1.getWrappingFixer)({
                                    ...wrappingFixerParams,
                                    wrap: expr => `${expr} satisfies string`,
                                }),
                            },
                        ],
                    });
                }
                else if (node.left.type === utils_1.AST_NODE_TYPES.Literal &&
                    node.left.value === '' &&
                    doesUnderlyingTypeMatchFlag(services.getTypeAtLocation(node.right), ts.TypeFlags.StringLike)) {
                    const wrappingFixerParams = {
                        node,
                        innerNode: [node.right],
                        sourceCode: context.sourceCode,
                    };
                    context.report({
                        loc: {
                            start: node.loc.start,
                            end: node.right.loc.start,
                        },
                        messageId: 'unnecessaryTypeConversion',
                        data: {
                            type: 'string',
                            violation: "Concatenating '' with a string",
                        },
                        suggest: [
                            {
                                messageId: 'suggestRemove',
                                fix: (0, util_1.getWrappingFixer)(wrappingFixerParams),
                            },
                            {
                                messageId: 'suggestSatisfies',
                                data: { type: 'string' },
                                fix: (0, util_1.getWrappingFixer)({
                                    ...wrappingFixerParams,
                                    wrap: expr => `${expr} satisfies string`,
                                }),
                            },
                        ],
                    });
                }
            },
            CallExpression(node) {
                const nodeCallee = node.callee;
                const builtInTypeFlags = {
                    BigInt: ts.TypeFlags.BigIntLike,
                    Boolean: ts.TypeFlags.BooleanLike,
                    Number: ts.TypeFlags.NumberLike,
                    String: ts.TypeFlags.StringLike,
                };
                if (nodeCallee.type !== utils_1.AST_NODE_TYPES.Identifier ||
                    !(nodeCallee.name in builtInTypeFlags)) {
                    return;
                }
                const typeFlag = builtInTypeFlags[nodeCallee.name];
                const scope = context.sourceCode.getScope(node);
                const variable = scope.set.get(nodeCallee.name);
                if (!!variable?.defs.length ||
                    !doesUnderlyingTypeMatchFlag((0, util_1.getConstrainedTypeAtLocation)(services, node.arguments[0]), typeFlag)) {
                    return;
                }
                const wrappingFixerParams = {
                    node,
                    innerNode: [node.arguments[0]],
                    sourceCode: context.sourceCode,
                };
                const typeString = nodeCallee.name.toLowerCase();
                context.report({
                    node: nodeCallee,
                    messageId: 'unnecessaryTypeConversion',
                    data: {
                        type: nodeCallee.name.toLowerCase(),
                        violation: `Passing a ${typeString} to ${nodeCallee.name}()`,
                    },
                    suggest: [
                        {
                            messageId: 'suggestRemove',
                            fix: (0, util_1.getWrappingFixer)(wrappingFixerParams),
                        },
                        {
                            messageId: 'suggestSatisfies',
                            data: { type: typeString },
                            fix: (0, util_1.getWrappingFixer)({
                                ...wrappingFixerParams,
                                wrap: expr => `${expr} satisfies ${typeString}`,
                            }),
                        },
                    ],
                });
            },
            'CallExpression > MemberExpression.callee > Identifier[name = "toString"].property'(node) {
                const memberExpr = node.parent;
                const type = (0, util_1.getConstrainedTypeAtLocation)(services, memberExpr.object);
                if (isEnumType(type) || isEnumMemberType(type)) {
                    return;
                }
                if (doesUnderlyingTypeMatchFlag(type, ts.TypeFlags.StringLike)) {
                    const wrappingFixerParams = {
                        node: memberExpr.parent,
                        innerNode: [memberExpr.object],
                        sourceCode: context.sourceCode,
                    };
                    context.report({
                        loc: {
                            start: memberExpr.property.loc.start,
                            end: memberExpr.parent.loc.end,
                        },
                        messageId: 'unnecessaryTypeConversion',
                        data: {
                            type: 'string',
                            violation: "Calling a string's .toString() method",
                        },
                        suggest: [
                            {
                                messageId: 'suggestRemove',
                                fix: (0, util_1.getWrappingFixer)(wrappingFixerParams),
                            },
                            {
                                messageId: 'suggestSatisfies',
                                data: { type: 'string' },
                                fix: (0, util_1.getWrappingFixer)({
                                    ...wrappingFixerParams,
                                    wrap: expr => `${expr} satisfies string`,
                                }),
                            },
                        ],
                    });
                }
            },
            'UnaryExpression[operator = "!"] > UnaryExpression[operator = "!"]'(node) {
                handleUnaryOperator(node, ts.TypeFlags.BooleanLike, 'boolean', 'Using !! on a boolean', true);
            },
            'UnaryExpression[operator = "+"]'(node) {
                handleUnaryOperator(node, ts.TypeFlags.NumberLike, 'number', 'Using the unary + operator on a number', false);
            },
            'UnaryExpression[operator = "~"] > UnaryExpression[operator = "~"]'(node) {
                const outerNode = node.parent;
                const type = services.getTypeAtLocation(node.argument);
                if (tsutils.unionConstituents(type).every(t => {
                    return ((0, util_1.isTypeFlagSet)(t, ts.TypeFlags.NumberLiteral) &&
                        Number.isInteger(t.value));
                })) {
                    const wrappingFixerParams = {
                        node: outerNode,
                        innerNode: [node.argument],
                        sourceCode: context.sourceCode,
                    };
                    context.report({
                        loc: {
                            start: outerNode.loc.start,
                            end: {
                                column: node.loc.start.column + 1,
                                line: node.loc.start.line,
                            },
                        },
                        messageId: 'unnecessaryTypeConversion',
                        data: { type: 'number', violation: 'Using ~~ on an integer' },
                        suggest: [
                            {
                                messageId: 'suggestRemove',
                                fix: (0, util_1.getWrappingFixer)(wrappingFixerParams),
                            },
                            {
                                messageId: 'suggestSatisfies',
                                data: { type: 'number' },
                                fix: (0, util_1.getWrappingFixer)({
                                    ...wrappingFixerParams,
                                    wrap: expr => `${expr} satisfies number`,
                                }),
                            },
                        ],
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-parameters.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"replaceUsagesWithConstraint" | "sole", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unnecessary-type-parameters.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-type-parameters',
    meta: {
        type: 'problem',
        docs: {
            description: "Disallow type parameters that aren't used multiple times",
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            replaceUsagesWithConstraint: 'Replace all usages of type parameter with its constraint.',
            sole: 'Type parameter {{name}} is {{uses}} in the {{descriptor}} signature.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const parserServices = (0, util_1.getParserServices)(context);
        function checkNode(node, descriptor) {
            const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
            const checker = parserServices.program.getTypeChecker();
            let counts;
            // Get the scope in which the type parameters are declared.
            const scope = context.sourceCode.getScope(node);
            for (const typeParameter of tsNode.typeParameters) {
                const esTypeParameter = parserServices.tsNodeToESTreeNodeMap.get(typeParameter);
                const smTypeParameterVariable = (0, util_1.nullThrows)((() => {
                    const variable = scope.set.get(esTypeParameter.name.name);
                    return variable?.isTypeVariable ? variable : undefined;
                })(), "Type parameter should be present in scope's variables.");
                // Quick path: if the type parameter is used multiple times in the AST,
                // we don't need to dip into types to know it's repeated.
                if (isTypeParameterRepeatedInAST(esTypeParameter, smTypeParameterVariable.references, node.body?.range[0] ?? node.returnType?.range[1])) {
                    continue;
                }
                // For any inferred types, we have to dip into type checking.
                counts ??= countTypeParameterUsage(checker, tsNode);
                const identifierCounts = counts.get(typeParameter.name);
                if (!identifierCounts || identifierCounts > 2) {
                    continue;
                }
                context.report({
                    node: esTypeParameter,
                    messageId: 'sole',
                    data: {
                        name: typeParameter.name.text,
                        descriptor,
                        uses: identifierCounts === 1 ? 'never used' : 'used only once',
                    },
                    suggest: [
                        {
                            messageId: 'replaceUsagesWithConstraint',
                            *fix(fixer) {
                                // Replace all the usages of the type parameter with the constraint...
                                const constraint = esTypeParameter.constraint;
                                // special case - a constraint of 'any' actually acts like 'unknown'
                                const constraintText = constraint != null &&
                                    constraint.type !== utils_1.AST_NODE_TYPES.TSAnyKeyword
                                    ? context.sourceCode.getText(constraint)
                                    : 'unknown';
                                for (const reference of smTypeParameterVariable.references) {
                                    if (reference.isTypeReference) {
                                        const referenceNode = reference.identifier;
                                        const isComplexType = constraint?.type === utils_1.AST_NODE_TYPES.TSUnionType ||
                                            constraint?.type === utils_1.AST_NODE_TYPES.TSIntersectionType ||
                                            constraint?.type === utils_1.AST_NODE_TYPES.TSConditionalType;
                                        const hasMatchingAncestorType = [
                                            utils_1.AST_NODE_TYPES.TSArrayType,
                                            utils_1.AST_NODE_TYPES.TSIndexedAccessType,
                                            utils_1.AST_NODE_TYPES.TSIntersectionType,
                                            utils_1.AST_NODE_TYPES.TSUnionType,
                                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                        ].some(type => referenceNode.parent.parent.type === type);
                                        if (isComplexType && hasMatchingAncestorType) {
                                            const fixResult = (0, util_1.getWrappingFixer)({
                                                node: referenceNode,
                                                innerNode: constraint,
                                                sourceCode: context.sourceCode,
                                                wrap: constraintNode => constraintNode,
                                            })(fixer);
                                            yield fixResult;
                                        }
                                        else {
                                            yield fixer.replaceText(referenceNode, constraintText);
                                        }
                                    }
                                }
                                // ...and remove the type parameter itself from the declaration.
                                const typeParamsNode = (0, util_1.nullThrows)(node.typeParameters, 'node should have type parameters');
                                // We are assuming at this point that the reported type parameter
                                // is present in the inspected node's type parameters.
                                if (typeParamsNode.params.length === 1) {
                                    // Remove the whole <T> generic syntax if we're removing the only type parameter in the list.
                                    yield fixer.remove(typeParamsNode);
                                }
                                else {
                                    const index = typeParamsNode.params.indexOf(esTypeParameter);
                                    if (index === 0) {
                                        const commaAfter = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(esTypeParameter, token => token.value === ','), util_1.NullThrowsReasons.MissingToken('comma', 'type parameter list'));
                                        const tokenAfterComma = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(commaAfter, {
                                            includeComments: true,
                                        }), util_1.NullThrowsReasons.MissingToken('token', 'type parameter list'));
                                        yield fixer.removeRange([
                                            esTypeParameter.range[0],
                                            tokenAfterComma.range[0],
                                        ]);
                                    }
                                    else {
                                        const commaBefore = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(esTypeParameter, token => token.value === ','), util_1.NullThrowsReasons.MissingToken('comma', 'type parameter list'));
                                        yield fixer.removeRange([
                                            commaBefore.range[0],
                                            esTypeParameter.range[1],
                                        ]);
                                    }
                                }
                            },
                        },
                    ],
                });
            }
        }
        return {
            [[
                'ArrowFunctionExpression[typeParameters]',
                'FunctionDeclaration[typeParameters]',
                'FunctionExpression[typeParameters]',
                'TSCallSignatureDeclaration[typeParameters]',
                'TSConstructorType[typeParameters]',
                'TSDeclareFunction[typeParameters]',
                'TSEmptyBodyFunctionExpression[typeParameters]',
                'TSFunctionType[typeParameters]',
                'TSMethodSignature[typeParameters]',
            ].join(', ')](node) {
                checkNode(node, 'function');
            },
            [[
                'ClassDeclaration[typeParameters]',
                'ClassExpression[typeParameters]',
            ].join(', ')](node) {
                checkNode(node, 'class');
            },
        };
    },
});
function isTypeParameterRepeatedInAST(node, references, startOfBody = Infinity) {
    let total = 0;
    for (const reference of references) {
        // References inside the type parameter's definition don't count...
        if (reference.identifier.range[0] < node.range[1] &&
            reference.identifier.range[1] > node.range[0]) {
            continue;
        }
        // ...nor references that are outside the declaring signature.
        if (reference.identifier.range[0] > startOfBody) {
            continue;
        }
        // Neither do references that aren't to the same type parameter,
        // namely value-land (non-type) identifiers of the type parameter's type,
        // and references to different type parameters or values.
        if (!reference.isTypeReference ||
            reference.identifier.name !== node.name.name) {
            continue;
        }
        // If the type parameter is being used as a type argument, then we
        // know the type parameter is being reused and can't be reported.
        if (reference.identifier.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference) {
            const grandparent = skipConstituentsUpward(reference.identifier.parent.parent);
            if (grandparent.type === utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation &&
                grandparent.params.includes(reference.identifier.parent) &&
                // Array and ReadonlyArray must be handled carefully
                // let's defer the check to the type-aware phase
                !(grandparent.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference &&
                    grandparent.parent.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
                    ['Array', 'ReadonlyArray'].includes(grandparent.parent.typeName.name))) {
                return true;
            }
        }
        total += 1;
        if (total >= 2) {
            return true;
        }
    }
    return false;
}
function skipConstituentsUpward(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSIntersectionType:
        case utils_1.AST_NODE_TYPES.TSUnionType:
            return skipConstituentsUpward(node.parent);
        default:
            return node;
    }
}
/**
 * Count uses of type parameters in inferred return types.
 * We need to resolve and analyze the inferred return type of a function
 * to see whether it contains additional references to the type parameters.
 * For classes, we need to do this for all their methods.
 */
function countTypeParameterUsage(checker, node) {
    const counts = new Map();
    if (ts.isClassLike(node)) {
        for (const typeParameter of node.typeParameters) {
            collectTypeParameterUsageCounts(checker, typeParameter, counts, true);
        }
        for (const member of node.members) {
            collectTypeParameterUsageCounts(checker, member, counts, true);
        }
    }
    else {
        collectTypeParameterUsageCounts(checker, node, counts, false);
    }
    return counts;
}
/**
 * Populates {@link foundIdentifierUsages} by the number of times each type parameter
 * appears in the given type by checking its uses through its type references.
 * This is essentially a limited subset of the scope manager, but for types.
 */
function collectTypeParameterUsageCounts(checker, node, foundIdentifierUsages, fromClass) {
    const visitedSymbolLists = new Set();
    const type = checker.getTypeAtLocation(node);
    const typeUsages = new Map();
    const visitedConstraints = new Set();
    let functionLikeType = false;
    let visitedDefault = false;
    if (ts.isCallSignatureDeclaration(node) ||
        ts.isConstructorDeclaration(node)) {
        functionLikeType = true;
        visitSignature(checker.getSignatureFromDeclaration(node));
    }
    if (!functionLikeType) {
        visitType(type, false);
    }
    function visitType(type, assumeMultipleUses, isReturnType = false) {
        // Seeing the same type > (threshold=3 ** 2) times indicates a likely
        // recursive type, like `type T = { [P in keyof T]: T }`.
        // If it's not recursive, then heck, we've seen it enough times that any
        // referenced types have been counted enough to qualify as used.
        if (!type || incrementTypeUsages(type) > 9) {
            return;
        }
        if (tsutils.isTypeParameter(type)) {
            const declaration = type.getSymbol()?.getDeclarations()?.[0];
            if (declaration) {
                incrementIdentifierCount(declaration.name, assumeMultipleUses);
                // Visiting the type of a constrained type parameter will recurse into
                // the constraint. We avoid infinite loops by visiting each only once.
                if (declaration.constraint &&
                    !visitedConstraints.has(declaration.constraint)) {
                    visitedConstraints.add(declaration.constraint);
                    visitType(checker.getTypeAtLocation(declaration.constraint), false);
                }
                if (declaration.default && !visitedDefault) {
                    visitedDefault = true;
                    visitType(checker.getTypeAtLocation(declaration.default), false);
                }
            }
        }
        // Catch-all: generic type references like `Exclude<T, null>`
        else if (type.aliasTypeArguments) {
            // We don't descend into the definition of the type alias, so we don't
            // know whether it's used multiple times. It's safest to assume it is.
            visitTypesList(type.aliasTypeArguments, true);
        }
        // Intersections and unions like `0 | 1`
        else if (tsutils.isUnionOrIntersectionType(type)) {
            visitTypesList(type.types, assumeMultipleUses);
        }
        // Index access types like `T[K]`
        else if (tsutils.isIndexedAccessType(type)) {
            visitType(type.objectType, assumeMultipleUses);
            visitType(type.indexType, assumeMultipleUses);
        }
        // Tuple types like `[K, V]`
        // Generic type references like `Map<K, V>`
        else if (tsutils.isTypeReference(type)) {
            for (const typeArgument of type.typeArguments ?? []) {
                // currently, if we are in a "class context", everything is accepted
                let thisAssumeMultipleUses = fromClass || assumeMultipleUses;
                // special cases - readonly arrays/tuples are considered only to use the
                // type parameter once. Mutable arrays/tuples are considered to use the
                // type parameter multiple times if and only if they are returned.
                // other kind of type references always count as multiple uses
                thisAssumeMultipleUses ||= tsutils.isTupleType(type.target)
                    ? isReturnType && !type.target.readonly
                    : checker.isArrayType(type.target)
                        ? isReturnType &&
                            type.symbol?.getName() === 'Array'
                        : true;
                visitType(typeArgument, thisAssumeMultipleUses, isReturnType);
            }
        }
        // Template literals like `a${T}b`
        else if (tsutils.isTemplateLiteralType(type)) {
            for (const subType of type.types) {
                visitType(subType, assumeMultipleUses);
            }
        }
        // Conditional types like `T extends string ? T : never`
        else if (tsutils.isConditionalType(type)) {
            visitType(type.checkType, assumeMultipleUses);
            visitType(type.extendsType, assumeMultipleUses);
        }
        // Catch-all: inferred object types like `{ K: V }`.
        // These catch-alls should be _after_ more specific checks like
        // `isTypeReference` to avoid descending into all the properties of a
        // generic interface/class, e.g. `Map<K, V>`.
        else if (tsutils.isObjectType(type)) {
            const properties = type.getProperties();
            visitSymbolsListOnce(properties, false);
            if (isMappedType(type)) {
                visitType(type.typeParameter, false);
                if (properties.length === 0) {
                    // TS treats mapped types like `{[k in "a"]: T}` like `{a: T}`.
                    // They have properties, so we need to avoid double-counting.
                    visitType(type.templateType ?? type.constraintType, false);
                }
            }
            visitType(type.getNumberIndexType(), true);
            visitType(type.getStringIndexType(), true);
            type.getCallSignatures().forEach(signature => {
                functionLikeType = true;
                visitSignature(signature);
            });
            type.getConstructSignatures().forEach(signature => {
                functionLikeType = true;
                visitSignature(signature);
            });
        }
        // Catch-all: operator types like `keyof T`
        else if (isOperatorType(type)) {
            visitType(type.type, assumeMultipleUses);
        }
    }
    function incrementIdentifierCount(id, assumeMultipleUses) {
        const identifierCount = foundIdentifierUsages.get(id) ?? 0;
        const value = assumeMultipleUses ? 2 : 1;
        foundIdentifierUsages.set(id, identifierCount + value);
    }
    function incrementTypeUsages(type) {
        const count = (typeUsages.get(type) ?? 0) + 1;
        typeUsages.set(type, count);
        return count;
    }
    function visitSignature(signature) {
        if (!signature) {
            return;
        }
        if (signature.thisParameter) {
            visitType(checker.getTypeOfSymbol(signature.thisParameter), false);
        }
        for (const parameter of signature.parameters) {
            visitType(checker.getTypeOfSymbol(parameter), false);
        }
        for (const typeParameter of signature.getTypeParameters() ?? []) {
            visitType(typeParameter, false);
        }
        visitType(checker.getTypePredicateOfSignature(signature)?.type ??
            signature.getReturnType(), false, true);
    }
    function visitSymbolsListOnce(symbols, assumeMultipleUses) {
        if (visitedSymbolLists.has(symbols)) {
            return;
        }
        visitedSymbolLists.add(symbols);
        for (const symbol of symbols) {
            visitType(checker.getTypeOfSymbol(symbol), assumeMultipleUses);
        }
    }
    function visitTypesList(types, assumeMultipleUses) {
        for (const type of types) {
            visitType(type, assumeMultipleUses);
        }
    }
}
function isMappedType(type) {
    return 'typeParameter' in type;
}
function isOperatorType(type) {
    return 'type' in type && !!type.type;
}


--------------------------------------------------------------------------------
FILE: no-unsafe-argument.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'unsafeArgument' | 'unsafeArraySpread' | 'unsafeSpread' | 'unsafeTupleSpread';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-argument.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
var RestTypeKind;
(function (RestTypeKind) {
    RestTypeKind[RestTypeKind["Array"] = 0] = "Array";
    RestTypeKind[RestTypeKind["Tuple"] = 1] = "Tuple";
    RestTypeKind[RestTypeKind["Other"] = 2] = "Other";
})(RestTypeKind || (RestTypeKind = {}));
class FunctionSignature {
    paramTypes;
    restType;
    hasConsumedArguments = false;
    parameterTypeIndex = 0;
    constructor(paramTypes, restType) {
        this.paramTypes = paramTypes;
        this.restType = restType;
    }
    static create(checker, tsNode) {
        const signature = checker.getResolvedSignature(tsNode);
        if (!signature) {
            return null;
        }
        const paramTypes = [];
        let restType = null;
        const parameters = signature.getParameters();
        for (let i = 0; i < parameters.length; i += 1) {
            const param = parameters[i];
            const type = checker.getTypeOfSymbolAtLocation(param, tsNode);
            const decl = param.getDeclarations()?.[0];
            if (decl && (0, util_1.isRestParameterDeclaration)(decl)) {
                // is a rest param
                if (checker.isArrayType(type)) {
                    restType = {
                        type: checker.getTypeArguments(type)[0],
                        index: i,
                        kind: RestTypeKind.Array,
                    };
                }
                else if (checker.isTupleType(type)) {
                    restType = {
                        index: i,
                        kind: RestTypeKind.Tuple,
                        typeArguments: checker.getTypeArguments(type),
                    };
                }
                else {
                    restType = {
                        type,
                        index: i,
                        kind: RestTypeKind.Other,
                    };
                }
                break;
            }
            paramTypes.push(type);
        }
        return new this(paramTypes, restType);
    }
    consumeRemainingArguments() {
        this.hasConsumedArguments = true;
    }
    getNextParameterType() {
        const index = this.parameterTypeIndex;
        this.parameterTypeIndex += 1;
        if (index >= this.paramTypes.length || this.hasConsumedArguments) {
            if (this.restType == null) {
                return null;
            }
            switch (this.restType.kind) {
                case RestTypeKind.Tuple: {
                    const typeArguments = this.restType.typeArguments;
                    if (this.hasConsumedArguments) {
                        // all types consumed by a rest - just assume it's the last type
                        // there is one edge case where this is wrong, but we ignore it because
                        // it's rare and really complicated to handle
                        // eg: function foo(...a: [number, ...string[], number])
                        return typeArguments[typeArguments.length - 1];
                    }
                    const typeIndex = index - this.restType.index;
                    if (typeIndex >= typeArguments.length) {
                        return typeArguments[typeArguments.length - 1];
                    }
                    return typeArguments[typeIndex];
                }
                case RestTypeKind.Array:
                case RestTypeKind.Other:
                    return this.restType.type;
            }
        }
        return this.paramTypes[index];
    }
}
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-argument',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow calling a function with a value with type `any`',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            unsafeArgument: 'Unsafe argument of type {{sender}} assigned to a parameter of type {{receiver}}.',
            unsafeArraySpread: 'Unsafe spread of an {{sender}} array type.',
            unsafeSpread: 'Unsafe spread of an {{sender}} type.',
            unsafeTupleSpread: 'Unsafe spread of a tuple type. The argument is {{sender}} and is assigned to a parameter of type {{receiver}}.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function describeType(type) {
            if (tsutils.isIntrinsicErrorType(type)) {
                return 'error typed';
            }
            return `\`${checker.typeToString(type)}\``;
        }
        function describeTypeForSpread(type) {
            if (checker.isArrayType(type) &&
                tsutils.isIntrinsicErrorType(checker.getTypeArguments(type)[0])) {
                return 'error';
            }
            return describeType(type);
        }
        function describeTypeForTuple(type) {
            if (tsutils.isIntrinsicErrorType(type)) {
                return 'error typed';
            }
            return `of type \`${checker.typeToString(type)}\``;
        }
        function checkUnsafeArguments(args, callee, node) {
            if (args.length === 0) {
                return;
            }
            // ignore any-typed calls as these are caught by no-unsafe-call
            if ((0, util_1.isTypeAnyType)(services.getTypeAtLocation(callee))) {
                return;
            }
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            const signature = (0, util_1.nullThrows)(FunctionSignature.create(checker, tsNode), 'Expected to a signature resolved');
            if (node.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {
                // Consumes the first parameter (TemplateStringsArray) of the function called with TaggedTemplateExpression.
                signature.getNextParameterType();
            }
            for (const argument of args) {
                switch (argument.type) {
                    // spreads consume
                    case utils_1.AST_NODE_TYPES.SpreadElement: {
                        const spreadArgType = services.getTypeAtLocation(argument.argument);
                        if ((0, util_1.isTypeAnyType)(spreadArgType)) {
                            // foo(...any)
                            context.report({
                                node: argument,
                                messageId: 'unsafeSpread',
                                data: { sender: describeType(spreadArgType) },
                            });
                        }
                        else if ((0, util_1.isTypeAnyArrayType)(spreadArgType, checker)) {
                            // foo(...any[])
                            // TODO - we could break down the spread and compare the array type against each argument
                            context.report({
                                node: argument,
                                messageId: 'unsafeArraySpread',
                                data: { sender: describeTypeForSpread(spreadArgType) },
                            });
                        }
                        else if (checker.isTupleType(spreadArgType)) {
                            // foo(...[tuple1, tuple2])
                            const spreadTypeArguments = checker.getTypeArguments(spreadArgType);
                            for (const tupleType of spreadTypeArguments) {
                                const parameterType = signature.getNextParameterType();
                                if (parameterType == null) {
                                    continue;
                                }
                                const result = (0, util_1.isUnsafeAssignment)(tupleType, parameterType, checker, 
                                // we can't pass the individual tuple members in here as this will most likely be a spread variable
                                // not a spread array
                                null);
                                if (result) {
                                    context.report({
                                        node: argument,
                                        messageId: 'unsafeTupleSpread',
                                        data: {
                                            receiver: describeType(parameterType),
                                            sender: describeTypeForTuple(tupleType),
                                        },
                                    });
                                }
                            }
                            if (spreadArgType.target.combinedFlags & ts.ElementFlags.Variable) {
                                // the last element was a rest - so all remaining defined arguments can be considered "consumed"
                                // all remaining arguments should be compared against the rest type (if one exists)
                                signature.consumeRemainingArguments();
                            }
                        }
                        else {
                            // something that's iterable
                            // handling this will be pretty complex - so we ignore it for now
                            // TODO - handle generic iterable case
                        }
                        break;
                    }
                    default: {
                        const parameterType = signature.getNextParameterType();
                        if (parameterType == null) {
                            continue;
                        }
                        const argumentType = services.getTypeAtLocation(argument);
                        const result = (0, util_1.isUnsafeAssignment)(argumentType, parameterType, checker, argument);
                        if (result) {
                            context.report({
                                node: argument,
                                messageId: 'unsafeArgument',
                                data: {
                                    receiver: describeType(parameterType),
                                    sender: describeType(argumentType),
                                },
                            });
                        }
                    }
                }
            }
        }
        return {
            'CallExpression, NewExpression'(node) {
                checkUnsafeArguments(node.arguments, node.callee, node);
            },
            TaggedTemplateExpression(node) {
                checkUnsafeArguments(node.quasi.expressions, node.tag, node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-assignment.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeArraySpread" | "anyAssignment" | "anyAssignmentThis" | "unsafeArrayPattern" | "unsafeArrayPatternFromTuple" | "unsafeAssignment" | "unsafeObjectPattern", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-assignment.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
var ComparisonType;
(function (ComparisonType) {
    /** Do no assignment comparison */
    ComparisonType[ComparisonType["None"] = 0] = "None";
    /** Use the receiver's type for comparison */
    ComparisonType[ComparisonType["Basic"] = 1] = "Basic";
    /** Use the sender's contextual type for comparison */
    ComparisonType[ComparisonType["Contextual"] = 2] = "Contextual";
})(ComparisonType || (ComparisonType = {}));
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-assignment',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow assigning a value with type `any` to variables and properties',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            anyAssignment: 'Unsafe assignment of an {{sender}} value.',
            anyAssignmentThis: [
                'Unsafe assignment of an {{sender}} value. `this` is typed as `any`.',
                'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.',
            ].join('\n'),
            unsafeArrayPattern: 'Unsafe array destructuring of an {{sender}} array value.',
            unsafeArrayPatternFromTuple: 'Unsafe array destructuring of a tuple element with an {{sender}} value.',
            unsafeArraySpread: 'Unsafe spread of an {{sender}} value in an array.',
            unsafeAssignment: 'Unsafe assignment of type {{sender}} to a variable of type {{receiver}}.',
            unsafeObjectPattern: 'Unsafe object destructuring of a property with an {{sender}} value.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const compilerOptions = services.program.getCompilerOptions();
        const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');
        // returns true if the assignment reported
        function checkArrayDestructureHelper(receiverNode, senderNode) {
            if (receiverNode.type !== utils_1.AST_NODE_TYPES.ArrayPattern) {
                return false;
            }
            const senderTsNode = services.esTreeNodeToTSNodeMap.get(senderNode);
            const senderType = services.getTypeAtLocation(senderNode);
            return checkArrayDestructure(receiverNode, senderType, senderTsNode);
        }
        // returns true if the assignment reported
        function checkArrayDestructure(receiverNode, senderType, senderNode) {
            // any array
            // const [x] = ([] as any[]);
            if ((0, util_1.isTypeAnyArrayType)(senderType, checker)) {
                context.report({
                    node: receiverNode,
                    messageId: 'unsafeArrayPattern',
                    data: createData(senderType),
                });
                return false;
            }
            if (!checker.isTupleType(senderType)) {
                return true;
            }
            const tupleElements = checker.getTypeArguments(senderType);
            // tuple with any
            // const [x] = [1 as any];
            let didReport = false;
            for (let receiverIndex = 0; receiverIndex < receiverNode.elements.length; receiverIndex += 1) {
                const receiverElement = receiverNode.elements[receiverIndex];
                if (!receiverElement) {
                    continue;
                }
                if (receiverElement.type === utils_1.AST_NODE_TYPES.RestElement) {
                    // don't handle rests as they're not a 1:1 assignment
                    continue;
                }
                const senderType = tupleElements[receiverIndex];
                if (!senderType) {
                    continue;
                }
                // check for the any type first so we can handle [[[x]]] = [any]
                if ((0, util_1.isTypeAnyType)(senderType)) {
                    context.report({
                        node: receiverElement,
                        messageId: 'unsafeArrayPatternFromTuple',
                        data: createData(senderType),
                    });
                    // we want to report on every invalid element in the tuple
                    didReport = true;
                }
                else if (receiverElement.type === utils_1.AST_NODE_TYPES.ArrayPattern) {
                    didReport = checkArrayDestructure(receiverElement, senderType, senderNode);
                }
                else if (receiverElement.type === utils_1.AST_NODE_TYPES.ObjectPattern) {
                    didReport = checkObjectDestructure(receiverElement, senderType, senderNode);
                }
            }
            return didReport;
        }
        // returns true if the assignment reported
        function checkObjectDestructureHelper(receiverNode, senderNode) {
            if (receiverNode.type !== utils_1.AST_NODE_TYPES.ObjectPattern) {
                return false;
            }
            const senderTsNode = services.esTreeNodeToTSNodeMap.get(senderNode);
            const senderType = services.getTypeAtLocation(senderNode);
            return checkObjectDestructure(receiverNode, senderType, senderTsNode);
        }
        // returns true if the assignment reported
        function checkObjectDestructure(receiverNode, senderType, senderNode) {
            const properties = new Map(senderType
                .getProperties()
                .map(property => [
                property.getName(),
                checker.getTypeOfSymbolAtLocation(property, senderNode),
            ]));
            let didReport = false;
            for (const receiverProperty of receiverNode.properties) {
                if (receiverProperty.type === utils_1.AST_NODE_TYPES.RestElement) {
                    // don't bother checking rest
                    continue;
                }
                let key;
                if (!receiverProperty.computed) {
                    key =
                        receiverProperty.key.type === utils_1.AST_NODE_TYPES.Identifier
                            ? receiverProperty.key.name
                            : String(receiverProperty.key.value);
                }
                else if (receiverProperty.key.type === utils_1.AST_NODE_TYPES.Literal) {
                    key = String(receiverProperty.key.value);
                }
                else if (receiverProperty.key.type === utils_1.AST_NODE_TYPES.TemplateLiteral &&
                    receiverProperty.key.quasis.length === 1) {
                    key = receiverProperty.key.quasis[0].value.cooked;
                }
                else {
                    // can't figure out the name, so skip it
                    continue;
                }
                const senderType = properties.get(key);
                if (!senderType) {
                    continue;
                }
                // check for the any type first so we can handle {x: {y: z}} = {x: any}
                if ((0, util_1.isTypeAnyType)(senderType)) {
                    context.report({
                        node: receiverProperty.value,
                        messageId: 'unsafeObjectPattern',
                        data: createData(senderType),
                    });
                    didReport = true;
                }
                else if (receiverProperty.value.type === utils_1.AST_NODE_TYPES.ArrayPattern) {
                    didReport = checkArrayDestructure(receiverProperty.value, senderType, senderNode);
                }
                else if (receiverProperty.value.type === utils_1.AST_NODE_TYPES.ObjectPattern) {
                    didReport = checkObjectDestructure(receiverProperty.value, senderType, senderNode);
                }
            }
            return didReport;
        }
        // returns true if the assignment reported
        function checkAssignment(receiverNode, senderNode, reportingNode, comparisonType) {
            const receiverTsNode = services.esTreeNodeToTSNodeMap.get(receiverNode);
            const receiverType = comparisonType === ComparisonType.Contextual
                ? ((0, util_1.getContextualType)(checker, receiverTsNode) ??
                    services.getTypeAtLocation(receiverNode))
                : services.getTypeAtLocation(receiverNode);
            const senderType = services.getTypeAtLocation(senderNode);
            if ((0, util_1.isTypeAnyType)(senderType)) {
                // handle cases when we assign any ==> unknown.
                if ((0, util_1.isTypeUnknownType)(receiverType)) {
                    return false;
                }
                let messageId = 'anyAssignment';
                if (!isNoImplicitThis) {
                    // `var foo = this`
                    const thisExpression = (0, util_1.getThisExpression)(senderNode);
                    if (thisExpression &&
                        (0, util_1.isTypeAnyType)((0, util_1.getConstrainedTypeAtLocation)(services, thisExpression))) {
                        messageId = 'anyAssignmentThis';
                    }
                }
                context.report({
                    node: reportingNode,
                    messageId,
                    data: createData(senderType),
                });
                return true;
            }
            if (comparisonType === ComparisonType.None) {
                return false;
            }
            const result = (0, util_1.isUnsafeAssignment)(senderType, receiverType, checker, senderNode);
            if (!result) {
                return false;
            }
            const { receiver, sender } = result;
            context.report({
                node: reportingNode,
                messageId: 'unsafeAssignment',
                data: createData(sender, receiver),
            });
            return true;
        }
        function getComparisonType(typeAnnotation) {
            return typeAnnotation
                ? // if there's a type annotation, we can do a comparison
                    ComparisonType.Basic
                : // no type annotation means the variable's type will just be inferred, thus equal
                    ComparisonType.None;
        }
        function createData(senderType, receiverType) {
            if (receiverType) {
                return {
                    receiver: `\`${checker.typeToString(receiverType)}\``,
                    sender: `\`${checker.typeToString(senderType)}\``,
                };
            }
            return {
                sender: tsutils.isIntrinsicErrorType(senderType)
                    ? 'error typed'
                    : '`any`',
            };
        }
        return {
            'AccessorProperty[value != null]'(node) {
                checkAssignment(node.key, node.value, node, getComparisonType(node.typeAnnotation));
            },
            'AssignmentExpression[operator = "="], AssignmentPattern'(node) {
                let didReport = checkAssignment(node.left, node.right, node, 
                // the variable already has some form of a type to compare against
                ComparisonType.Basic);
                if (!didReport) {
                    didReport = checkArrayDestructureHelper(node.left, node.right);
                }
                if (!didReport) {
                    checkObjectDestructureHelper(node.left, node.right);
                }
            },
            'PropertyDefinition[value != null]'(node) {
                checkAssignment(node.key, node.value, node, getComparisonType(node.typeAnnotation));
            },
            'VariableDeclarator[init != null]'(node) {
                const init = (0, util_1.nullThrows)(node.init, util_1.NullThrowsReasons.MissingToken(node.type, 'init'));
                let didReport = checkAssignment(node.id, init, node, getComparisonType(node.id.typeAnnotation));
                if (!didReport) {
                    didReport = checkArrayDestructureHelper(node.id, init);
                }
                if (!didReport) {
                    checkObjectDestructureHelper(node.id, init);
                }
            },
            // object pattern props are checked via assignments
            ':not(ObjectPattern) > Property'(node) {
                if (node.value.type === utils_1.AST_NODE_TYPES.AssignmentPattern ||
                    node.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {
                    // handled by other selector
                    return;
                }
                checkAssignment(node.key, node.value, node, ComparisonType.Contextual);
            },
            'ArrayExpression > SpreadElement'(node) {
                const restType = services.getTypeAtLocation(node.argument);
                if ((0, util_1.isTypeAnyType)(restType) || (0, util_1.isTypeAnyArrayType)(restType, checker)) {
                    context.report({
                        node,
                        messageId: 'unsafeArraySpread',
                        data: createData(restType),
                    });
                }
            },
            'JSXAttribute[value != null]'(node) {
                const value = (0, util_1.nullThrows)(node.value, util_1.NullThrowsReasons.MissingToken(node.type, 'value'));
                if (value.type !== utils_1.AST_NODE_TYPES.JSXExpressionContainer ||
                    value.expression.type === utils_1.AST_NODE_TYPES.JSXEmptyExpression) {
                    return;
                }
                checkAssignment(node.name, value.expression, value.expression, ComparisonType.Contextual);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-call.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'errorCall' | 'errorCallThis' | 'errorNew' | 'errorTemplateTag' | 'unsafeCall' | 'unsafeCallThis' | 'unsafeNew' | 'unsafeTemplateTag';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-call.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-call',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow calling a value with type `any`',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            errorCall: 'Unsafe call of a type that could not be resolved.',
            errorCallThis: 'Unsafe call of a `this` type that could not be resolved.',
            errorNew: 'Unsafe construction of a type that could not be resolved.',
            errorTemplateTag: 'Unsafe use of a template tag whose type could not be resolved.',
            unsafeCall: 'Unsafe call of {{type}} typed value.',
            unsafeCallThis: [
                'Unsafe call of {{type}} typed value. `this` is typed as {{type}}.',
                'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.',
            ].join('\n'),
            unsafeNew: 'Unsafe construction of {{type}} typed value.',
            unsafeTemplateTag: 'Unsafe use of {{type}} typed template tag.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const compilerOptions = services.program.getCompilerOptions();
        const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');
        function checkCall(node, reportingNode, unsafeMessageId, errorMessageId) {
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            if ((0, util_1.isTypeAnyType)(type)) {
                if (!isNoImplicitThis) {
                    // `this()` or `this.foo()` or `this.foo[bar]()`
                    const thisExpression = (0, util_1.getThisExpression)(node);
                    if (thisExpression &&
                        (0, util_1.isTypeAnyType)((0, util_1.getConstrainedTypeAtLocation)(services, thisExpression))) {
                        unsafeMessageId = 'unsafeCallThis';
                        errorMessageId = 'errorCallThis';
                    }
                }
                const isErrorType = tsutils.isIntrinsicErrorType(type);
                context.report({
                    node: reportingNode,
                    messageId: isErrorType ? errorMessageId : unsafeMessageId,
                    data: {
                        type: 'an `any`',
                    },
                });
                return;
            }
            if ((0, util_1.isBuiltinSymbolLike)(services.program, type, 'Function')) {
                // this also matches subtypes of `Function`, like `interface Foo extends Function {}`.
                //
                // For weird TS reasons that I don't understand, these are
                //
                // safe to construct if:
                // - they have at least one call signature _that is not void-returning_,
                // - OR they have at least one construct signature.
                //
                // safe to call (including as template) if:
                // - they have at least one call signature
                // - OR they have at least one construct signature.
                const constructSignatures = type.getConstructSignatures();
                if (constructSignatures.length > 0) {
                    return;
                }
                const callSignatures = type.getCallSignatures();
                if (unsafeMessageId === 'unsafeNew') {
                    if (callSignatures.some(signature => !tsutils.isIntrinsicVoidType(signature.getReturnType()))) {
                        return;
                    }
                }
                else if (callSignatures.length > 0) {
                    return;
                }
                context.report({
                    node: reportingNode,
                    messageId: unsafeMessageId,
                    data: {
                        type: 'a `Function`',
                    },
                });
                return;
            }
        }
        return {
            'CallExpression > *.callee'(node) {
                checkCall(node, node, 'unsafeCall', 'errorCall');
            },
            NewExpression(node) {
                checkCall(node.callee, node, 'unsafeNew', 'errorNew');
            },
            'TaggedTemplateExpression > *.tag'(node) {
                checkCall(node, node, 'unsafeTemplateTag', 'errorTemplateTag');
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-declaration-merging.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeMerging", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-declaration-merging.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-declaration-merging',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow unsafe declaration merging',
            recommended: 'recommended',
            requiresTypeChecking: false,
        },
        messages: {
            unsafeMerging: 'Unsafe declaration merging between classes and interfaces.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function checkUnsafeDeclaration(scope, node, unsafeKind) {
            const variable = scope.set.get(node.name);
            if (!variable) {
                return;
            }
            const defs = variable.defs;
            if (defs.length <= 1) {
                return;
            }
            if (defs.some(def => def.node.type === unsafeKind)) {
                context.report({
                    node,
                    messageId: 'unsafeMerging',
                });
            }
        }
        return {
            ClassDeclaration(node) {
                if (node.id) {
                    // by default eslint returns the inner class scope for the ClassDeclaration node
                    // but we want the outer scope within which merged variables will sit
                    const currentScope = context.sourceCode.getScope(node).upper;
                    if (currentScope == null) {
                        return;
                    }
                    checkUnsafeDeclaration(currentScope, node.id, utils_1.AST_NODE_TYPES.TSInterfaceDeclaration);
                }
            },
            TSInterfaceDeclaration(node) {
                checkUnsafeDeclaration(context.sourceCode.getScope(node), node.id, utils_1.AST_NODE_TYPES.ClassDeclaration);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-enum-comparison.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"mismatchedCase" | "mismatchedCondition" | "replaceValueWithEnum", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-enum-comparison.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const shared_1 = require("./enum-utils/shared");
/**
 * @returns Whether the right type is an unsafe comparison against any left type.
 */
function typeViolates(leftTypeParts, rightType) {
    const leftEnumValueTypes = new Set(leftTypeParts.map(getEnumValueType));
    return ((leftEnumValueTypes.has(ts.TypeFlags.Number) && isNumberLike(rightType)) ||
        (leftEnumValueTypes.has(ts.TypeFlags.String) && isStringLike(rightType)));
}
function isNumberLike(type) {
    return tsutils
        .unionConstituents(type)
        .every(unionPart => tsutils
        .intersectionConstituents(unionPart)
        .some(intersectionPart => tsutils.isTypeFlagSet(intersectionPart, ts.TypeFlags.Number | ts.TypeFlags.NumberLike)));
}
function isStringLike(type) {
    return tsutils
        .unionConstituents(type)
        .every(unionPart => tsutils
        .intersectionConstituents(unionPart)
        .some(intersectionPart => tsutils.isTypeFlagSet(intersectionPart, ts.TypeFlags.String | ts.TypeFlags.StringLike)));
}
/**
 * @returns What type a type's enum value is (number or string), if either.
 */
function getEnumValueType(type) {
    return tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLike)
        ? tsutils.isTypeFlagSet(type, ts.TypeFlags.NumberLiteral)
            ? ts.TypeFlags.Number
            : ts.TypeFlags.String
        : undefined;
}
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-enum-comparison',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow comparing an enum value with a non-enum value',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            mismatchedCase: 'The case statement does not have a shared enum type with the switch predicate.',
            mismatchedCondition: 'The two values in this comparison do not have a shared enum type.',
            replaceValueWithEnum: 'Replace with an enum value comparison.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const parserServices = (0, util_1.getParserServices)(context);
        const typeChecker = parserServices.program.getTypeChecker();
        function isMismatchedComparison(leftType, rightType) {
            // Allow comparisons that don't have anything to do with enums:
            //
            // ```ts
            // 1 === 2;
            // ```
            const leftEnumTypes = (0, shared_1.getEnumTypes)(typeChecker, leftType);
            const rightEnumTypes = new Set((0, shared_1.getEnumTypes)(typeChecker, rightType));
            if (leftEnumTypes.length === 0 && rightEnumTypes.size === 0) {
                return false;
            }
            // Allow comparisons that share an enum type:
            //
            // ```ts
            // Fruit.Apple === Fruit.Banana;
            // ```
            for (const leftEnumType of leftEnumTypes) {
                if (rightEnumTypes.has(leftEnumType)) {
                    return false;
                }
            }
            // We need to split the type into the union type parts in order to find
            // valid enum comparisons like:
            //
            // ```ts
            // declare const something: Fruit | Vegetable;
            // something === Fruit.Apple;
            // ```
            const leftTypeParts = tsutils.unionConstituents(leftType);
            const rightTypeParts = tsutils.unionConstituents(rightType);
            // If a type exists in both sides, we consider this comparison safe:
            //
            // ```ts
            // declare const fruit: Fruit.Apple | 0;
            // fruit === 0;
            // ```
            for (const leftTypePart of leftTypeParts) {
                if (rightTypeParts.includes(leftTypePart)) {
                    return false;
                }
            }
            return (typeViolates(leftTypeParts, rightType) ||
                typeViolates(rightTypeParts, leftType));
        }
        return {
            'BinaryExpression[operator=/^[<>!=]?={0,2}$/]'(node) {
                const leftType = parserServices.getTypeAtLocation(node.left);
                const rightType = parserServices.getTypeAtLocation(node.right);
                if (isMismatchedComparison(leftType, rightType)) {
                    context.report({
                        node,
                        messageId: 'mismatchedCondition',
                        suggest: [
                            {
                                messageId: 'replaceValueWithEnum',
                                fix(fixer) {
                                    // Replace the right side with an enum key if possible:
                                    //
                                    // ```ts
                                    // Fruit.Apple === 'apple'; // Fruit.Apple === Fruit.Apple
                                    // ```
                                    const leftEnumKey = (0, shared_1.getEnumKeyForLiteral)((0, shared_1.getEnumLiterals)(leftType), (0, util_1.getStaticValue)(node.right)?.value);
                                    if (leftEnumKey) {
                                        return fixer.replaceText(node.right, leftEnumKey);
                                    }
                                    // Replace the left side with an enum key if possible:
                                    //
                                    // ```ts
                                    // declare const fruit: Fruit;
                                    // 'apple' === Fruit.Apple; // Fruit.Apple === Fruit.Apple
                                    // ```
                                    const rightEnumKey = (0, shared_1.getEnumKeyForLiteral)((0, shared_1.getEnumLiterals)(rightType), (0, util_1.getStaticValue)(node.left)?.value);
                                    if (rightEnumKey) {
                                        return fixer.replaceText(node.left, rightEnumKey);
                                    }
                                    return null;
                                },
                            },
                        ],
                    });
                }
            },
            SwitchCase(node) {
                // Ignore `default` cases.
                if (node.test == null) {
                    return;
                }
                const { parent } = node;
                const leftType = parserServices.getTypeAtLocation(parent.discriminant);
                const rightType = parserServices.getTypeAtLocation(node.test);
                if (isMismatchedComparison(leftType, rightType)) {
                    context.report({
                        node,
                        messageId: 'mismatchedCase',
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-function-type.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"bannedFunctionType", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-function-type.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-function-type',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow using the unsafe built-in Function type',
            recommended: 'recommended',
        },
        messages: {
            bannedFunctionType: [
                'The `Function` type accepts any function-like value.',
                'Prefer explicitly defining any function parameters and return type.',
            ].join('\n'),
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function checkBannedTypes(node) {
            if (node.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.name === 'Function' &&
                (0, util_1.isReferenceToGlobalFunction)('Function', node, context.sourceCode)) {
                context.report({
                    node,
                    messageId: 'bannedFunctionType',
                });
            }
        }
        return {
            TSClassImplements(node) {
                checkBannedTypes(node.expression);
            },
            TSInterfaceHeritage(node) {
                checkBannedTypes(node.expression);
            },
            TSTypeReference(node) {
                checkBannedTypes(node.typeName);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-member-access.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowOptionalChaining?: boolean;
    }
];
export type MessageIds = 'errorComputedMemberAccess' | 'errorMemberExpression' | 'errorThisMemberExpression' | 'unsafeComputedMemberAccess' | 'unsafeMemberExpression' | 'unsafeThisMemberExpression';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-member-access.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
var State;
(function (State) {
    State[State["Unsafe"] = 1] = "Unsafe";
    State[State["Safe"] = 2] = "Safe";
    State[State["Chained"] = 3] = "Chained";
})(State || (State = {}));
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-member-access',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow member access on a value with type `any`',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            errorComputedMemberAccess: 'The type of computed name {{property}} cannot be resolved.',
            errorMemberExpression: 'Unsafe member access {{property}} on a type that cannot be resolved.',
            errorThisMemberExpression: [
                'Unsafe member access {{property}}. The type of `this` cannot be resolved.',
                'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.',
            ].join('\n'),
            unsafeComputedMemberAccess: 'Computed name {{property}} resolves to an `any` value.',
            unsafeMemberExpression: 'Unsafe member access {{property}} on an `any` value.',
            unsafeThisMemberExpression: [
                'Unsafe member access {{property}} on an `any` value. `this` is typed as `any`.',
                'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.',
            ].join('\n'),
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowOptionalChaining: {
                        type: 'boolean',
                        description: 'Whether to allow `?.` optional chains on `any` values.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowOptionalChaining: false,
        },
    ],
    create(context, [{ allowOptionalChaining }]) {
        const services = (0, util_1.getParserServices)(context);
        const compilerOptions = services.program.getCompilerOptions();
        const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');
        const stateCache = new Map();
        // Case notes:
        // value?.outer.middle.inner
        // The ChainExpression is a child of the root expression, and a parent of all the MemberExpressions.
        // But the left-most expression is what we want to report on: the inner-most expressions.
        // In fact, this is true even if the chain is on the inside!
        // value.outer.middle?.inner;
        // It was already true that every `object` (MemberExpression) has optional: boolean
        function checkMemberExpression(node) {
            if (allowOptionalChaining && node.optional) {
                stateCache.set(node, State.Chained);
                return State.Chained;
            }
            const cachedState = stateCache.get(node);
            if (cachedState) {
                return cachedState;
            }
            if (node.object.type === utils_1.AST_NODE_TYPES.MemberExpression) {
                const objectState = checkMemberExpression(node.object);
                if (objectState === State.Unsafe) {
                    // if the object is unsafe, we know this will be unsafe as well
                    // we don't need to report, as we have already reported on the inner member expr
                    stateCache.set(node, objectState);
                    return objectState;
                }
            }
            const type = services.getTypeAtLocation(node.object);
            const state = (0, util_1.isTypeAnyType)(type) ? State.Unsafe : State.Safe;
            stateCache.set(node, state);
            if (state === State.Unsafe) {
                const propertyName = context.sourceCode.getText(node.property);
                let messageId;
                if (!isNoImplicitThis) {
                    // `this.foo` or `this.foo[bar]`
                    const thisExpression = (0, util_1.getThisExpression)(node);
                    if (thisExpression) {
                        const thisType = (0, util_1.getConstrainedTypeAtLocation)(services, thisExpression);
                        if ((0, util_1.isTypeAnyType)(thisType)) {
                            messageId = tsutils.isIntrinsicErrorType(thisType)
                                ? 'errorThisMemberExpression'
                                : 'unsafeThisMemberExpression';
                        }
                    }
                }
                if (!messageId) {
                    messageId = tsutils.isIntrinsicErrorType(type)
                        ? 'errorMemberExpression'
                        : 'unsafeMemberExpression';
                }
                context.report({
                    node: node.property,
                    messageId,
                    data: {
                        property: node.computed ? `[${propertyName}]` : `.${propertyName}`,
                    },
                });
            }
            return state;
        }
        return {
            // ignore MemberExpressions with ancestors of type `TSClassImplements` or `TSInterfaceHeritage`
            'MemberExpression:not(TSClassImplements MemberExpression, TSInterfaceHeritage MemberExpression)': checkMemberExpression,
            'MemberExpression[computed = true] > *.property'(node) {
                if (allowOptionalChaining &&
                    node.parent.optional) {
                    return;
                }
                if (
                // x[1]
                node.type === utils_1.AST_NODE_TYPES.Literal ||
                    // x[1++] x[++x] etc
                    // FUN FACT - **all** update expressions return type number, regardless of the argument's type,
                    // because JS engines return NaN if there the argument is not a number.
                    node.type === utils_1.AST_NODE_TYPES.UpdateExpression) {
                    // perf optimizations - literals can obviously never be `any`
                    return;
                }
                const type = services.getTypeAtLocation(node);
                if ((0, util_1.isTypeAnyType)(type)) {
                    const propertyName = context.sourceCode.getText(node);
                    context.report({
                        node,
                        messageId: tsutils.isIntrinsicErrorType(type)
                            ? 'errorComputedMemberAccess'
                            : 'unsafeComputedMemberAccess',
                        data: {
                            property: `[${propertyName}]`,
                        },
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-return.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeReturn" | "unsafeReturnAssignment" | "unsafeReturnThis", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-return.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const getParentFunctionNode_1 = require("../util/getParentFunctionNode");
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-return',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow returning a value with type `any` from a function',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            unsafeReturn: 'Unsafe return of a value of type {{type}}.',
            unsafeReturnAssignment: 'Unsafe return of type `{{sender}}` from function with return type `{{receiver}}`.',
            unsafeReturnThis: [
                'Unsafe return of a value of type `{{type}}`. `this` is typed as `any`.',
                'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.',
            ].join('\n'),
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const compilerOptions = services.program.getCompilerOptions();
        const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');
        function checkReturn(returnNode, reportingNode = returnNode) {
            const tsNode = services.esTreeNodeToTSNodeMap.get(returnNode);
            const type = checker.getTypeAtLocation(tsNode);
            const anyType = (0, util_1.discriminateAnyType)(type, checker, services.program, tsNode);
            const functionNode = (0, getParentFunctionNode_1.getParentFunctionNode)(returnNode);
            /* istanbul ignore if */ if (!functionNode) {
                return;
            }
            // function has an explicit return type, so ensure it's a safe return
            const returnNodeType = (0, util_1.getConstrainedTypeAtLocation)(services, returnNode);
            const functionTSNode = services.esTreeNodeToTSNodeMap.get(functionNode);
            // function expressions will not have their return type modified based on receiver typing
            // so we have to use the contextual typing in these cases, i.e.
            // const foo1: () => Set<string> = () => new Set<any>();
            // the return type of the arrow function is Set<any> even though the variable is typed as Set<string>
            let functionType = ts.isFunctionExpression(functionTSNode) ||
                ts.isArrowFunction(functionTSNode)
                ? (0, util_1.getContextualType)(checker, functionTSNode)
                : services.getTypeAtLocation(functionNode);
            functionType ??= services.getTypeAtLocation(functionNode);
            const callSignatures = tsutils.getCallSignaturesOfType(functionType);
            // If there is an explicit type annotation *and* that type matches the actual
            // function return type, we shouldn't complain (it's intentional, even if unsafe)
            if (functionTSNode.type) {
                for (const signature of callSignatures) {
                    const signatureReturnType = signature.getReturnType();
                    if (returnNodeType === signatureReturnType ||
                        (0, util_1.isTypeFlagSet)(signatureReturnType, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
                        return;
                    }
                    if (functionNode.async) {
                        const awaitedSignatureReturnType = checker.getAwaitedType(signatureReturnType);
                        const awaitedReturnNodeType = checker.getAwaitedType(returnNodeType);
                        if (awaitedReturnNodeType === awaitedSignatureReturnType ||
                            (awaitedSignatureReturnType &&
                                (0, util_1.isTypeFlagSet)(awaitedSignatureReturnType, ts.TypeFlags.Any | ts.TypeFlags.Unknown))) {
                            return;
                        }
                    }
                }
            }
            if (anyType !== util_1.AnyType.Safe) {
                // Allow cases when the declared return type of the function is either unknown or unknown[]
                // and the function is returning any or any[].
                for (const signature of callSignatures) {
                    const functionReturnType = signature.getReturnType();
                    if (anyType === util_1.AnyType.Any &&
                        (0, util_1.isTypeUnknownType)(functionReturnType)) {
                        return;
                    }
                    if (anyType === util_1.AnyType.AnyArray &&
                        (0, util_1.isTypeUnknownArrayType)(functionReturnType, checker)) {
                        return;
                    }
                    const awaitedType = checker.getAwaitedType(functionReturnType);
                    if (awaitedType &&
                        anyType === util_1.AnyType.PromiseAny &&
                        (0, util_1.isTypeUnknownType)(awaitedType)) {
                        return;
                    }
                }
                if (anyType === util_1.AnyType.PromiseAny && !functionNode.async) {
                    return;
                }
                let messageId = 'unsafeReturn';
                const isErrorType = tsutils.isIntrinsicErrorType(returnNodeType);
                if (!isNoImplicitThis) {
                    // `return this`
                    const thisExpression = (0, util_1.getThisExpression)(returnNode);
                    if (thisExpression &&
                        (0, util_1.isTypeAnyType)((0, util_1.getConstrainedTypeAtLocation)(services, thisExpression))) {
                        messageId = 'unsafeReturnThis';
                    }
                }
                // If the function return type was not unknown/unknown[], mark usage as unsafeReturn.
                return context.report({
                    node: reportingNode,
                    messageId,
                    data: {
                        type: isErrorType
                            ? 'error'
                            : anyType === util_1.AnyType.Any
                                ? '`any`'
                                : anyType === util_1.AnyType.PromiseAny
                                    ? '`Promise<any>`'
                                    : '`any[]`',
                    },
                });
            }
            const signature = functionType.getCallSignatures().at(0);
            if (signature) {
                const functionReturnType = signature.getReturnType();
                const result = (0, util_1.isUnsafeAssignment)(returnNodeType, functionReturnType, checker, returnNode);
                if (!result) {
                    return;
                }
                const { receiver, sender } = result;
                return context.report({
                    node: reportingNode,
                    messageId: 'unsafeReturnAssignment',
                    data: {
                        receiver: checker.typeToString(receiver),
                        sender: checker.typeToString(sender),
                    },
                });
            }
        }
        return {
            'ArrowFunctionExpression > :not(BlockStatement).body': checkReturn,
            ReturnStatement(node) {
                const argument = node.argument;
                if (!argument) {
                    return;
                }
                checkReturn(argument, node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-type-assertion.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unsafeOfAnyTypeAssertion" | "unsafeToAnyTypeAssertion" | "unsafeToUnconstrainedTypeAssertion" | "unsafeTypeAssertion" | "unsafeTypeAssertionAssignableToConstraint", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-type-assertion.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-unsafe-type-assertion',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow type assertions that narrow a type',
            requiresTypeChecking: true,
        },
        messages: {
            unsafeOfAnyTypeAssertion: 'Unsafe assertion from {{type}} detected: consider using type guards or a safer assertion.',
            unsafeToAnyTypeAssertion: 'Unsafe assertion to {{type}} detected: consider using a more specific type to ensure safety.',
            unsafeToUnconstrainedTypeAssertion: "Unsafe type assertion: '{{type}}' could be instantiated with an arbitrary type which could be unrelated to the original type.",
            unsafeTypeAssertion: "Unsafe type assertion: type '{{type}}' is more narrow than the original type.",
            unsafeTypeAssertionAssignableToConstraint: "Unsafe type assertion: the original type is assignable to the constraint of type '{{type}}', but '{{type}}' could be instantiated with a different subtype of its constraint.",
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function getAnyTypeName(type) {
            return tsutils.isIntrinsicErrorType(type) ? 'error typed' : '`any`';
        }
        function isObjectLiteralType(type) {
            return (tsutils.isObjectType(type) &&
                tsutils.isObjectFlagSet(type, ts.ObjectFlags.ObjectLiteral));
        }
        function checkExpression(node) {
            const expressionType = services.getTypeAtLocation(node.expression);
            const assertedType = services.getTypeAtLocation(node.typeAnnotation);
            if (expressionType === assertedType) {
                return;
            }
            // handle cases when asserting unknown ==> any.
            if ((0, util_1.isTypeAnyType)(assertedType) && (0, util_1.isTypeUnknownType)(expressionType)) {
                context.report({
                    node,
                    messageId: 'unsafeToAnyTypeAssertion',
                    data: {
                        type: '`any`',
                    },
                });
                return;
            }
            const unsafeExpressionAny = (0, util_1.isUnsafeAssignment)(expressionType, assertedType, checker, node.expression);
            if (unsafeExpressionAny) {
                context.report({
                    node,
                    messageId: 'unsafeOfAnyTypeAssertion',
                    data: {
                        type: getAnyTypeName(unsafeExpressionAny.sender),
                    },
                });
                return;
            }
            const unsafeAssertedAny = (0, util_1.isUnsafeAssignment)(assertedType, expressionType, checker, node.typeAnnotation);
            if (unsafeAssertedAny) {
                context.report({
                    node,
                    messageId: 'unsafeToAnyTypeAssertion',
                    data: {
                        type: getAnyTypeName(unsafeAssertedAny.sender),
                    },
                });
                return;
            }
            // Use the widened type in case of an object literal so `isTypeAssignableTo()`
            // won't fail on excess property check.
            const expressionWidenedType = isObjectLiteralType(expressionType)
                ? checker.getWidenedType(expressionType)
                : expressionType;
            const isAssertionSafe = checker.isTypeAssignableTo(expressionWidenedType, assertedType);
            if (isAssertionSafe) {
                return;
            }
            // Produce a more specific error message when targeting a type parameter
            if (tsutils.isTypeParameter(assertedType)) {
                const assertedTypeConstraint = checker.getBaseConstraintOfType(assertedType);
                if (!assertedTypeConstraint) {
                    // asserting to an unconstrained type parameter is unsafe
                    context.report({
                        node,
                        messageId: 'unsafeToUnconstrainedTypeAssertion',
                        data: {
                            type: checker.typeToString(assertedType),
                        },
                    });
                    return;
                }
                // special case message if the original type is assignable to the
                // constraint of the target type parameter
                const isAssignableToConstraint = checker.isTypeAssignableTo(expressionWidenedType, assertedTypeConstraint);
                if (isAssignableToConstraint) {
                    context.report({
                        node,
                        messageId: 'unsafeTypeAssertionAssignableToConstraint',
                        data: {
                            type: checker.typeToString(assertedType),
                        },
                    });
                    return;
                }
            }
            // General error message
            context.report({
                node,
                messageId: 'unsafeTypeAssertion',
                data: {
                    type: checker.typeToString(assertedType),
                },
            });
        }
        return {
            'TSAsExpression, TSTypeAssertion'(node) {
                checkExpression(node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unsafe-unary-minus.d.ts
--------------------------------------------------------------------------------

export type Options = [];
export type MessageIds = 'unaryMinus';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unaryMinus", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unsafe-unary-minus.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util = __importStar(require("../util"));
exports.default = util.createRule({
    name: 'no-unsafe-unary-minus',
    meta: {
        type: 'problem',
        docs: {
            description: 'Require unary negation to take a number',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            unaryMinus: 'Argument of unary negation should be assignable to number | bigint but is {{type}} instead.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            UnaryExpression(node) {
                if (node.operator !== '-') {
                    return;
                }
                const services = util.getParserServices(context);
                const argType = util.getConstrainedTypeAtLocation(services, node.argument);
                const checker = services.program.getTypeChecker();
                if (tsutils
                    .unionConstituents(argType)
                    .some(type => !tsutils.isTypeFlagSet(type, ts.TypeFlags.Any |
                    ts.TypeFlags.Never |
                    ts.TypeFlags.BigIntLike |
                    ts.TypeFlags.NumberLike))) {
                    context.report({
                        node,
                        messageId: 'unaryMinus',
                        data: { type: checker.typeToString(argType) },
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unused-expressions.d.ts
--------------------------------------------------------------------------------

import { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unusedExpression", [{
    allowShortCircuit?: boolean;
    allowTaggedTemplates?: boolean;
    allowTernary?: boolean;
}], unknown, {
    ExpressionStatement(node: TSESTree.ExpressionStatement): void;
}>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"unusedExpression", [{
    allowShortCircuit?: boolean;
    allowTaggedTemplates?: boolean;
    allowTernary?: boolean;
}], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unused-expressions.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-unused-expressions');
const defaultOptions = [
    {
        allowShortCircuit: false,
        allowTaggedTemplates: false,
        allowTernary: false,
    },
];
exports.default = (0, util_1.createRule)({
    name: 'no-unused-expressions',
    meta: {
        type: 'suggestion',
        defaultOptions,
        docs: {
            description: 'Disallow unused expressions',
            extendsBaseRule: true,
            recommended: 'recommended',
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: baseRule.meta.schema,
    },
    defaultOptions,
    create(context, [{ allowShortCircuit = false, allowTernary = false }]) {
        const rules = baseRule.create(context);
        function isValidExpression(node) {
            if (allowShortCircuit && node.type === utils_1.AST_NODE_TYPES.LogicalExpression) {
                return isValidExpression(node.right);
            }
            if (allowTernary && node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {
                return (isValidExpression(node.alternate) &&
                    isValidExpression(node.consequent));
            }
            return ((node.type === utils_1.AST_NODE_TYPES.ChainExpression &&
                node.expression.type === utils_1.AST_NODE_TYPES.CallExpression) ||
                node.type === utils_1.AST_NODE_TYPES.ImportExpression);
        }
        return {
            ExpressionStatement(node) {
                if (node.directive || isValidExpression(node.expression)) {
                    return;
                }
                const expressionType = node.expression.type;
                if (expressionType ===
                    utils_1.TSESTree.AST_NODE_TYPES.TSInstantiationExpression ||
                    expressionType === utils_1.TSESTree.AST_NODE_TYPES.TSAsExpression ||
                    expressionType === utils_1.TSESTree.AST_NODE_TYPES.TSNonNullExpression ||
                    expressionType === utils_1.TSESTree.AST_NODE_TYPES.TSTypeAssertion) {
                    rules.ExpressionStatement({
                        ...node,
                        expression: node.expression.expression,
                    });
                    return;
                }
                rules.ExpressionStatement(node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unused-private-class-members.d.ts
--------------------------------------------------------------------------------

import { ESLintUtils } from '@typescript-eslint/utils';
export type MessageIds = 'unusedPrivateClassMember';
declare const _default: ESLintUtils.RuleModule<"unusedPrivateClassMember", [], import("../../rules").ESLintPluginDocs, ESLintUtils.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unused-private-class-members.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const classScopeAnalyzer_1 = require("../util/class-scope-analyzer/classScopeAnalyzer");
exports.default = (0, util_1.createRule)({
    name: 'no-unused-private-class-members',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow unused private class members',
            extendsBaseRule: true,
            requiresTypeChecking: false,
        },
        messages: {
            unusedPrivateClassMember: "Private class member '{{classMemberName}}' is defined but never used.",
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            'Program:exit'(node) {
                const result = (0, classScopeAnalyzer_1.analyzeClassMemberUsage)(node, utils_1.ESLintUtils.nullThrows(context.sourceCode.scopeManager, 'Missing required scope manager'));
                for (const classScope of result.values()) {
                    for (const member of [
                        ...classScope.members.instance.values(),
                        ...classScope.members.static.values(),
                    ]) {
                        if ((!member.isPrivate() && !member.isHashPrivate()) ||
                            member.isUsed()) {
                            continue;
                        }
                        context.report({
                            node: member.nameNode,
                            messageId: 'unusedPrivateClassMember',
                            data: { classMemberName: member.name },
                        });
                    }
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-unused-vars.d.ts
--------------------------------------------------------------------------------

import { TSESLint } from '@typescript-eslint/utils';
export type MessageIds = 'removeUnusedImportDeclaration' | 'removeUnusedVar' | 'unusedVar' | 'usedIgnoredVar' | 'usedOnlyAsType';
export type Options = [
    'all' | 'local' | {
        args?: 'after-used' | 'all' | 'none';
        argsIgnorePattern?: string;
        caughtErrors?: 'all' | 'none';
        caughtErrorsIgnorePattern?: string;
        destructuredArrayIgnorePattern?: string;
        enableAutofixRemoval?: {
            imports?: boolean;
        };
        ignoreClassWithStaticInitBlock?: boolean;
        ignoreRestSiblings?: boolean;
        ignoreUsingDeclarations?: boolean;
        reportUsedIgnorePattern?: boolean;
        vars?: 'all' | 'local';
        varsIgnorePattern?: string;
    }
];
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-unused-vars.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const referenceContainsTypeQuery_1 = require("../util/referenceContainsTypeQuery");
// this is a superset of DefinitionType which defines sub-types for better granularity
var VariableType;
(function (VariableType) {
    // New sub-types
    VariableType[VariableType["ArrayDestructure"] = 0] = "ArrayDestructure";
    // DefinitionType
    VariableType[VariableType["CatchClause"] = 1] = "CatchClause";
    VariableType[VariableType["ClassName"] = 2] = "ClassName";
    VariableType[VariableType["FunctionName"] = 3] = "FunctionName";
    VariableType[VariableType["ImportBinding"] = 4] = "ImportBinding";
    VariableType[VariableType["ImplicitGlobalVariable"] = 5] = "ImplicitGlobalVariable";
    VariableType[VariableType["Parameter"] = 6] = "Parameter";
    VariableType[VariableType["TSEnumMember"] = 7] = "TSEnumMember";
    VariableType[VariableType["TSEnumName"] = 8] = "TSEnumName";
    VariableType[VariableType["TSModuleName"] = 9] = "TSModuleName";
    VariableType[VariableType["Type"] = 10] = "Type";
    VariableType[VariableType["Variable"] = 11] = "Variable";
})(VariableType || (VariableType = {}));
const isCommaToken = {
    predicate: (token) => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === ',',
    tokenChar: ',',
};
const isLeftCurlyToken = {
    predicate: (token) => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '{',
    tokenChar: '{',
};
const isRightCurlyToken = {
    predicate: (token) => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '}',
    tokenChar: '}',
};
function assertToken({ predicate, tokenChar }, token) {
    if (token == null) {
        throw new Error(`Expected a valid "${tokenChar}" token, but found no token`);
    }
    if (!predicate(token)) {
        throw new Error(`Expected a valid "${tokenChar}" token, but got "${token.value}" instead`);
    }
    return token;
}
exports.default = (0, util_1.createRule)({
    name: 'no-unused-vars',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow unused variables',
            extendsBaseRule: true,
            recommended: 'recommended',
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            removeUnusedImportDeclaration: 'Remove unused import declaration.',
            removeUnusedVar: 'Remove unused variable "{{varName}}".',
            unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}.",
            usedIgnoredVar: "'{{varName}}' is marked as ignored but is used{{additional}}.",
            usedOnlyAsType: "'{{varName}}' is {{action}} but only used as a type{{additional}}.",
        },
        schema: [
            {
                oneOf: [
                    {
                        type: 'string',
                        description: 'Broad setting for unused variables to target.',
                        enum: ['all', 'local'],
                    },
                    {
                        type: 'object',
                        additionalProperties: false,
                        properties: {
                            args: {
                                type: 'string',
                                description: 'Whether to check all, some, or no arguments.',
                                enum: ['all', 'after-used', 'none'],
                            },
                            argsIgnorePattern: {
                                type: 'string',
                                description: 'Regular expressions of argument names to not check for usage.',
                            },
                            caughtErrors: {
                                type: 'string',
                                description: 'Whether to check catch block arguments.',
                                enum: ['all', 'none'],
                            },
                            caughtErrorsIgnorePattern: {
                                type: 'string',
                                description: 'Regular expressions of catch block argument names to not check for usage.',
                            },
                            destructuredArrayIgnorePattern: {
                                type: 'string',
                                description: 'Regular expressions of destructured array variable names to not check for usage.',
                            },
                            enableAutofixRemoval: {
                                type: 'object',
                                additionalProperties: false,
                                description: 'Configurable automatic fixes for different types of unused variables.',
                                properties: {
                                    imports: {
                                        type: 'boolean',
                                        description: 'Whether to enable automatic removal of unused imports.',
                                    },
                                },
                            },
                            ignoreClassWithStaticInitBlock: {
                                type: 'boolean',
                                description: 'Whether to ignore classes with at least one static initialization block.',
                            },
                            ignoreRestSiblings: {
                                type: 'boolean',
                                description: 'Whether to ignore sibling properties in `...` destructurings.',
                            },
                            ignoreUsingDeclarations: {
                                type: 'boolean',
                                description: 'Whether to ignore using or await using declarations.',
                            },
                            reportUsedIgnorePattern: {
                                type: 'boolean',
                                description: 'Whether to report variables that match any of the valid ignore pattern options if they have been used.',
                            },
                            vars: {
                                type: 'string',
                                description: 'Whether to check all variables or only locally-declared variables.',
                                enum: ['all', 'local'],
                            },
                            varsIgnorePattern: {
                                type: 'string',
                                description: 'Regular expressions of variable names to not check for usage.',
                            },
                        },
                    },
                ],
            },
        ],
    },
    defaultOptions: [{}],
    create(context, [firstOption]) {
        const MODULE_DECL_CACHE = new Map();
        const reportedUnusedVariables = new Set();
        function areAllSpecifiersUnused(decl) {
            return context.sourceCode.getDeclaredVariables(decl).every(variable => {
                return reportedUnusedVariables.has(variable);
            });
        }
        const report = (unusedVar, opts) => {
            reportedUnusedVariables.add(unusedVar);
            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() &&
                ref.from.variableScope === unusedVar.scope.variableScope);
            const id = writeReferences.length
                ? writeReferences[writeReferences.length - 1].identifier
                : unusedVar.identifiers[0];
            const { start } = id.loc;
            const idLength = id.name.length;
            const loc = {
                start,
                end: {
                    column: start.column + idLength,
                    line: start.line,
                },
            };
            const fixer = (() => {
                const { messageId, fix, useAutofix } = (() => {
                    if (unusedVar.defs.length !== 1) {
                        // If there's multiple definitions then we'd have to clean them all
                        // up! That's complicated and messy so for now let's just ignore it.
                        return {};
                    }
                    const { type, def } = defToVariableType(unusedVar.defs[0]);
                    switch (type) {
                        case VariableType.ArrayDestructure:
                            // TODO(bradzacher) -- this would be really easy to implement and
                            // is side-effect free!
                            return {};
                        case VariableType.CatchClause:
                            // TODO(bradzacher) -- this would be really easy to implement and
                            // is side-effect free!
                            return {};
                        case VariableType.ClassName:
                            // This would be easy to implement -- but classes can have
                            // side-effects in static initializers / static blocks. So it's
                            // dangerous to ever auto-fix remove them.
                            //
                            // Perhaps as an always-suggestion fixer...?
                            return {};
                        case VariableType.FunctionName:
                            // TODO(bradzacher) -- this would be really easy to implement and
                            // is side-effect free!
                            return {};
                        case VariableType.ImportBinding:
                            return {
                                ...getImportFixer(def),
                                useAutofix: options.enableAutofixRemoval.imports,
                            };
                        case VariableType.ImplicitGlobalVariable:
                            // We don't report these via this code path, so no fixer is possible
                            return {};
                        case VariableType.Parameter:
                            // This is easy to implement -- but we cannot implement it cos it
                            // changes the signature of the function which in turn might
                            // introduce type errors in consumers.
                            //
                            // Also parameters can have default values which might have
                            // side-effects.
                            //
                            // Perhaps as an always-suggestion fixer...?
                            return {};
                        case VariableType.TSEnumMember:
                            // We don't report unused enum members so no fixer is ever possible
                            return {};
                        case VariableType.TSEnumName:
                            // TODO(bradzacher) -- this would be really easy to implement and
                            // is side-effect free!
                            return {};
                        case VariableType.TSModuleName:
                            // This is easy to implement -- but TS namespaces are eagerly
                            // initialized -- meaning that they might have side-effects in
                            // the body. So it's dangerous to ever auto-fix remove them.
                            //
                            // Perhaps as an always-suggestion fixer...?
                            return {};
                        case VariableType.Type:
                            // TODO(bradzacher) -- this would be really easy to implement and
                            // is side-effect free!
                            return {};
                        case VariableType.Variable:
                            // TODO(bradzacher) -- this would be really easy to implement
                            return {};
                    }
                })();
                if (!fix) {
                    return {};
                }
                if (useAutofix) {
                    return { fix };
                }
                const data = {
                    varName: unusedVar.name,
                };
                return {
                    suggest: [
                        {
                            messageId: messageId ?? 'removeUnusedVar',
                            data,
                            fix,
                        },
                    ],
                };
            })();
            context.report({
                ...opts,
                ...fixer,
                loc,
                node: id,
            });
        };
        const options = (() => {
            const options = {
                args: 'after-used',
                caughtErrors: 'all',
                enableAutofixRemoval: {
                    imports: false,
                },
                ignoreClassWithStaticInitBlock: false,
                ignoreRestSiblings: false,
                ignoreUsingDeclarations: false,
                reportUsedIgnorePattern: false,
                vars: 'all',
            };
            if (typeof firstOption === 'string') {
                options.vars = firstOption;
            }
            else {
                options.vars = firstOption.vars ?? options.vars;
                options.args = firstOption.args ?? options.args;
                options.ignoreRestSiblings =
                    firstOption.ignoreRestSiblings ?? options.ignoreRestSiblings;
                options.ignoreUsingDeclarations =
                    firstOption.ignoreUsingDeclarations ??
                        options.ignoreUsingDeclarations;
                options.caughtErrors = firstOption.caughtErrors ?? options.caughtErrors;
                options.ignoreClassWithStaticInitBlock =
                    firstOption.ignoreClassWithStaticInitBlock ??
                        options.ignoreClassWithStaticInitBlock;
                options.reportUsedIgnorePattern =
                    firstOption.reportUsedIgnorePattern ??
                        options.reportUsedIgnorePattern;
                if (firstOption.varsIgnorePattern) {
                    options.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, 'u');
                }
                if (firstOption.argsIgnorePattern) {
                    options.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, 'u');
                }
                if (firstOption.caughtErrorsIgnorePattern) {
                    options.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, 'u');
                }
                if (firstOption.destructuredArrayIgnorePattern) {
                    options.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, 'u');
                }
                if (firstOption.enableAutofixRemoval) {
                    // eslint-disable-next-line unicorn/no-lonely-if -- will add more cases later
                    if (firstOption.enableAutofixRemoval.imports != null) {
                        options.enableAutofixRemoval.imports =
                            firstOption.enableAutofixRemoval.imports;
                    }
                }
            }
            return options;
        })();
        function getImportFixer(def) {
            switch (def.node.type) {
                case utils_1.AST_NODE_TYPES.TSImportEqualsDeclaration:
                    // import equals declarations can only have one binding -- so we can
                    // just remove entire import declaration
                    return {
                        messageId: 'removeUnusedImportDeclaration',
                        fix: fixer => fixer.remove(def.node),
                    };
                case utils_1.AST_NODE_TYPES.ImportDefaultSpecifier: {
                    const importDecl = def.node.parent;
                    if (importDecl.specifiers.length === 1 ||
                        areAllSpecifiersUnused(importDecl)) {
                        // all specifiers are unused -- so we can just remove entire import
                        // declaration
                        return {
                            messageId: 'removeUnusedImportDeclaration',
                            fix: fixer => fixer.remove(importDecl),
                        };
                    }
                    // in this branch we know the following things:
                    // 1) there is at least one specifier that is used
                    // 2) the default specifier is unused
                    //
                    // by process of elimination we can deduce that there is at least one
                    // named specifier that is used
                    //
                    // i.e. the code must be import Unused, { Used, ... } from 'module';
                    //
                    // there's one or more unused named specifiers, so we must remove the
                    // default specifier in isolation including the trailing comma.
                    //
                    //     import Unused, { Used, ... } from 'module';
                    //            ^^^^^^^ remove this
                    //
                    // NOTE: we could also remove the spaces between the comma and the
                    // opening curly brace -- but this does risk removing comments. To be
                    // safe we'll be conservative for now
                    //
                    // TODO(bradzacher) -- consider removing the extra space whilst also
                    //                     preserving comments.
                    return {
                        messageId: 'removeUnusedVar',
                        fix: fixer => {
                            const comma = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(def.node), util_1.NullThrowsReasons.MissingToken(',', 'import specifier'));
                            assertToken(isCommaToken, comma);
                            return fixer.removeRange([
                                Math.min(def.node.range[0], comma.range[0]),
                                Math.max(def.node.range[1], comma.range[1]),
                            ]);
                        },
                    };
                }
                case utils_1.AST_NODE_TYPES.ImportSpecifier: {
                    // guaranteed to NOT be in an export statement as we're inspecting an
                    // import
                    const importDecl = def.node.parent;
                    if (importDecl.specifiers.length === 1 ||
                        areAllSpecifiersUnused(importDecl)) {
                        // all specifiers are unused -- so we can just remove entire import
                        // declaration
                        return {
                            messageId: 'removeUnusedImportDeclaration',
                            fix: fixer => fixer.remove(importDecl),
                        };
                    }
                    return {
                        messageId: 'removeUnusedVar',
                        fix: fixer => {
                            const usedNamedSpecifiers = context.sourceCode
                                .getDeclaredVariables(importDecl)
                                .map(variable => {
                                if (reportedUnusedVariables.has(variable)) {
                                    return null;
                                }
                                const specifier = variable.defs[0].node;
                                if (specifier.type !== utils_1.AST_NODE_TYPES.ImportSpecifier) {
                                    return null;
                                }
                                return specifier;
                            })
                                .filter(v => v != null);
                            if (usedNamedSpecifiers.length === 0) {
                                // in this branch we know the following things:
                                // 1) there is at least one specifier that is used
                                // 2) all named specifiers are unused
                                //
                                // by process of elimination we can deduce that there is a
                                // default specifier and it is the only used specifier
                                //
                                // i.e. the code must be import Used, { Unused, ... } from
                                //     'module';
                                //
                                // So we can just remove the entire curly content and the comma
                                // before, eg import Used, { Unused, ... } from 'module';
                                // ^^^^^^^^^^^^^^^^^ remove this
                                const leftCurly = assertToken(isLeftCurlyToken, context.sourceCode.getFirstToken(importDecl, isLeftCurlyToken.predicate));
                                const leftToken = assertToken(isCommaToken, context.sourceCode.getTokenBefore(leftCurly));
                                const rightToken = assertToken(isRightCurlyToken, context.sourceCode.getFirstToken(importDecl, isRightCurlyToken.predicate));
                                return fixer.removeRange([
                                    leftToken.range[0],
                                    rightToken.range[1],
                                ]);
                            }
                            // in this branch we know there is at least one used named
                            // specifier which means we have to remove each unused specifier
                            // in isolation.
                            //
                            // there's 3 possible cases to care about: import { Unused,
                            //    Used... } from 'module'; import { ...Used, Unused } from
                            //    'module'; import { ...Used, Unused, } from 'module';
                            //
                            // Note that because of the above usedNamedSpecifiers check we
                            // know that we don't have one of these cases: import { Unused }
                            // from 'module'; import { Unused, Unused... } from 'module';
                            // import { ...Unused, Unused, } from 'module';
                            //
                            // The result is that we know that there _must_ be a comma that
                            // needs cleaning up
                            //
                            // try to remove the leading comma first as it leads to a nicer
                            // fix output in most cases
                            //
                            // leading preferred: import { Used, Unused, Used } from 'module';
                            //   ^^^^^^^^ remove import { Used, Used } from 'module';
                            //
                            // trailing preferred: import { Used, Unused, Used } from
                            //   'module'; ^^^^^^^ remove import { Used,  Used } from
                            //   'module'; ^^ ugly double space
                            //
                            // But we need to still fallback to the trailing comma for cases
                            // where the unused specifier is the first in the import eg:
                            // import { Unused, Used } from 'module';
                            const maybeComma = context.sourceCode.getTokenBefore(def.node);
                            const comma = maybeComma && isCommaToken.predicate(maybeComma)
                                ? maybeComma
                                : assertToken(isCommaToken, context.sourceCode.getTokenAfter(def.node));
                            return fixer.removeRange([
                                Math.min(def.node.range[0], comma.range[0]),
                                Math.max(def.node.range[1], comma.range[1]),
                            ]);
                        },
                    };
                }
                case utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier: {
                    // namespace specifiers cannot be used with any other specifier -- so
                    // we can just remove entire import declaration
                    const importDecl = def.node.parent;
                    return {
                        messageId: 'removeUnusedImportDeclaration',
                        fix: fixer => fixer.remove(importDecl),
                    };
                }
            }
        }
        /**
         * Determines what variable type a def is.
         * @param def the declaration to check
         * @returns a simple name for the types of variables that this rule supports
         */
        function defToVariableType(def) {
            /*
             * This `destructuredArrayIgnorePattern` error report works differently from the catch
             * clause and parameter error reports. _Both_ the `varsIgnorePattern` and the
             * `destructuredArrayIgnorePattern` will be checked for array destructuring. However,
             * for the purposes of the report, the currently defined behavior is to only inform the
             * user of the `destructuredArrayIgnorePattern` if it's present (regardless of the fact
             * that the `varsIgnorePattern` would also apply). If it's not present, the user will be
             * informed of the `varsIgnorePattern`, assuming that's present.
             */
            if (options.destructuredArrayIgnorePattern &&
                def.name.parent.type === utils_1.AST_NODE_TYPES.ArrayPattern) {
                return { type: VariableType.ArrayDestructure, def };
            }
            switch (def.type) {
                case scope_manager_1.DefinitionType.CatchClause:
                    return { type: VariableType.CatchClause, def };
                case scope_manager_1.DefinitionType.ClassName:
                    return { type: VariableType.ClassName, def };
                case scope_manager_1.DefinitionType.FunctionName:
                    return { type: VariableType.FunctionName, def };
                case scope_manager_1.DefinitionType.ImplicitGlobalVariable:
                    return { type: VariableType.ImplicitGlobalVariable, def };
                case scope_manager_1.DefinitionType.ImportBinding:
                    return { type: VariableType.ImportBinding, def };
                case scope_manager_1.DefinitionType.Parameter:
                    return { type: VariableType.Parameter, def };
                case scope_manager_1.DefinitionType.TSEnumName:
                    return { type: VariableType.TSEnumName, def };
                case scope_manager_1.DefinitionType.TSEnumMember:
                    return { type: VariableType.TSEnumMember, def };
                case scope_manager_1.DefinitionType.TSModuleName:
                    return { type: VariableType.TSModuleName, def };
                case scope_manager_1.DefinitionType.Type:
                    return { type: VariableType.Type, def };
                case scope_manager_1.DefinitionType.Variable:
                    return { type: VariableType.Variable, def };
            }
        }
        /**
         * Gets a given variable's description and configured ignore pattern
         * based on the provided variableType
         * @param variableType a simple name for the types of variables that this rule supports
         * @returns the given variable's description and
         * ignore pattern
         */
        function getVariableDescription(variableType) {
            switch (variableType) {
                case VariableType.ArrayDestructure:
                    return {
                        pattern: options.destructuredArrayIgnorePattern?.toString(),
                        variableDescription: 'elements of array destructuring',
                    };
                case VariableType.CatchClause:
                    return {
                        pattern: options.caughtErrorsIgnorePattern?.toString(),
                        variableDescription: 'caught errors',
                    };
                case VariableType.Parameter:
                    return {
                        pattern: options.argsIgnorePattern?.toString(),
                        variableDescription: 'args',
                    };
                default:
                    return {
                        pattern: options.varsIgnorePattern?.toString(),
                        variableDescription: 'vars',
                    };
            }
        }
        /**
         * Generates the message data about the variable being defined and unused,
         * including the ignore pattern if configured.
         * @param unusedVar eslint-scope variable object.
         * @returns The message data to be used with this unused variable.
         */
        function getDefinedMessageData(unusedVar) {
            const def = unusedVar.defs.at(0);
            let additionalMessageData = '';
            if (def) {
                const { pattern, variableDescription } = getVariableDescription(defToVariableType(def).type);
                if (pattern && variableDescription) {
                    additionalMessageData = `. Allowed unused ${variableDescription} must match ${pattern}`;
                }
            }
            return {
                action: 'defined',
                additional: additionalMessageData,
                varName: unusedVar.name,
            };
        }
        /**
         * Generate the warning message about the variable being
         * assigned and unused, including the ignore pattern if configured.
         * @param unusedVar eslint-scope variable object.
         * @returns The message data to be used with this unused variable.
         */
        function getAssignedMessageData(unusedVar) {
            const def = unusedVar.defs.at(0);
            let additionalMessageData = '';
            if (def) {
                const { pattern, variableDescription } = getVariableDescription(defToVariableType(def).type);
                if (pattern && variableDescription) {
                    additionalMessageData = `. Allowed unused ${variableDescription} must match ${pattern}`;
                }
            }
            return {
                action: 'assigned a value',
                additional: additionalMessageData,
                varName: unusedVar.name,
            };
        }
        /**
         * Generate the warning message about a variable being used even though
         * it is marked as being ignored.
         * @param variable eslint-scope variable object
         * @param variableType a simple name for the types of variables that this rule supports
         * @returns The message data to be used with this used ignored variable.
         */
        function getUsedIgnoredMessageData(variable, variableType) {
            const { pattern, variableDescription } = getVariableDescription(variableType);
            let additionalMessageData = '';
            if (pattern && variableDescription) {
                additionalMessageData = `. Used ${variableDescription} must not match ${pattern}`;
            }
            return {
                additional: additionalMessageData,
                varName: variable.name,
            };
        }
        function collectUnusedVariables() {
            /**
             * Checks whether a node is a sibling of the rest property or not.
             * @param node a node to check
             * @returns True if the node is a sibling of the rest property, otherwise false.
             */
            function hasRestSibling(node) {
                return (node.type === utils_1.AST_NODE_TYPES.Property &&
                    node.parent.type === utils_1.AST_NODE_TYPES.ObjectPattern &&
                    node.parent.properties[node.parent.properties.length - 1].type ===
                        utils_1.AST_NODE_TYPES.RestElement);
            }
            /**
             * Determines if a variable has a sibling rest property
             * @param variable eslint-scope variable object.
             * @returns True if the variable is exported, false if not.
             */
            function hasRestSpreadSibling(variable) {
                if (options.ignoreRestSiblings) {
                    const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));
                    const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));
                    return hasRestSiblingDefinition || hasRestSiblingReference;
                }
                return false;
            }
            /**
             * Checks whether the given variable is after the last used parameter.
             * @param variable The variable to check.
             * @returns `true` if the variable is defined after the last used parameter.
             */
            function isAfterLastUsedArg(variable) {
                const def = variable.defs[0];
                const params = context.sourceCode.getDeclaredVariables(def.node);
                const posteriorParams = params.slice(params.indexOf(variable) + 1);
                // If any used parameters occur after this parameter, do not report.
                return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);
            }
            const analysisResults = (0, util_1.collectVariables)(context);
            const variables = [
                ...Array.from(analysisResults.unusedVariables, variable => ({
                    used: false,
                    variable,
                })),
                ...Array.from(analysisResults.usedVariables, variable => ({
                    used: true,
                    variable,
                })),
            ];
            const unusedVariablesReturn = [];
            for (const { used, variable } of variables) {
                // explicit global variables don't have definitions.
                if (variable.defs.length === 0) {
                    if (!used) {
                        unusedVariablesReturn.push(variable);
                    }
                    continue;
                }
                const def = variable.defs[0];
                if (variable.scope.type === utils_1.TSESLint.Scope.ScopeType.global &&
                    options.vars === 'local') {
                    // skip variables in the global scope if configured to
                    continue;
                }
                const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === utils_1.AST_NODE_TYPES.ArrayPattern);
                // skip elements of array destructuring patterns
                if ((def.name.parent.type === utils_1.AST_NODE_TYPES.ArrayPattern ||
                    refUsedInArrayPatterns) &&
                    def.name.type === utils_1.AST_NODE_TYPES.Identifier &&
                    options.destructuredArrayIgnorePattern?.test(def.name.name)) {
                    if (options.reportUsedIgnorePattern && used) {
                        report(variable, {
                            messageId: 'usedIgnoredVar',
                            data: getUsedIgnoredMessageData(variable, VariableType.ArrayDestructure),
                        });
                    }
                    continue;
                }
                if (def.type === utils_1.TSESLint.Scope.DefinitionType.ClassName) {
                    const hasStaticBlock = def.node.body.body.some(node => node.type === utils_1.AST_NODE_TYPES.StaticBlock);
                    if (options.ignoreClassWithStaticInitBlock && hasStaticBlock) {
                        continue;
                    }
                }
                // skip catch variables
                if (def.type === utils_1.TSESLint.Scope.DefinitionType.CatchClause) {
                    if (options.caughtErrors === 'none') {
                        continue;
                    }
                    // skip ignored parameters
                    if (def.name.type === utils_1.AST_NODE_TYPES.Identifier &&
                        options.caughtErrorsIgnorePattern?.test(def.name.name)) {
                        if (options.reportUsedIgnorePattern && used) {
                            report(variable, {
                                messageId: 'usedIgnoredVar',
                                data: getUsedIgnoredMessageData(variable, VariableType.CatchClause),
                            });
                        }
                        continue;
                    }
                }
                else if (def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {
                    // if "args" option is "none", skip any parameter
                    if (options.args === 'none') {
                        continue;
                    }
                    // skip ignored parameters
                    if (def.name.type === utils_1.AST_NODE_TYPES.Identifier &&
                        options.argsIgnorePattern?.test(def.name.name)) {
                        if (options.reportUsedIgnorePattern && used) {
                            report(variable, {
                                messageId: 'usedIgnoredVar',
                                data: getUsedIgnoredMessageData(variable, VariableType.Parameter),
                            });
                        }
                        continue;
                    }
                    // if "args" option is "after-used", skip used variables
                    if (options.args === 'after-used' &&
                        (0, util_1.isFunction)(def.name.parent) &&
                        !isAfterLastUsedArg(variable)) {
                        continue;
                    }
                }
                // skip ignored variables
                else if (def.name.type === utils_1.AST_NODE_TYPES.Identifier &&
                    options.varsIgnorePattern?.test(def.name.name)) {
                    if (options.reportUsedIgnorePattern &&
                        used &&
                        /* enum members are always marked as 'used' by `collectVariables`, but in reality they may be used or
                           unused. either way, don't complain about their naming. */
                        def.type !== utils_1.TSESLint.Scope.DefinitionType.TSEnumMember) {
                        report(variable, {
                            messageId: 'usedIgnoredVar',
                            data: getUsedIgnoredMessageData(variable, VariableType.Variable),
                        });
                    }
                    continue;
                }
                if (def.type === utils_1.TSESLint.Scope.DefinitionType.Variable &&
                    options.ignoreUsingDeclarations &&
                    (def.parent.kind === 'await using' || def.parent.kind === 'using')) {
                    continue;
                }
                if (hasRestSpreadSibling(variable)) {
                    continue;
                }
                // in case another rule has run and used the collectUnusedVariables,
                // we want to ensure our selectors that marked variables as used are respected
                if (variable.eslintUsed) {
                    continue;
                }
                if (!used) {
                    unusedVariablesReturn.push(variable);
                }
            }
            return unusedVariablesReturn;
        }
        return {
            // top-level declaration file handling
            [ambientDeclarationSelector(utils_1.AST_NODE_TYPES.Program)](node) {
                if (!(0, util_1.isDefinitionFile)(context.filename)) {
                    return;
                }
                const moduleDecl = (0, util_1.nullThrows)(node.parent, util_1.NullThrowsReasons.MissingParent);
                if (checkForOverridingExportStatements(moduleDecl)) {
                    return;
                }
                markDeclarationChildAsUsed(node);
            },
            // children of a namespace that is a child of a declared namespace are auto-exported
            [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock TSModuleDeclaration > TSModuleBlock')](node) {
                const moduleDecl = (0, util_1.nullThrows)(node.parent.parent, util_1.NullThrowsReasons.MissingParent);
                if (checkForOverridingExportStatements(moduleDecl)) {
                    return;
                }
                markDeclarationChildAsUsed(node);
            },
            // declared namespace handling
            [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock')](node) {
                const moduleDecl = (0, util_1.nullThrows)(node.parent.parent, util_1.NullThrowsReasons.MissingParent);
                if (checkForOverridingExportStatements(moduleDecl)) {
                    return;
                }
                markDeclarationChildAsUsed(node);
            },
            // namespace handling in definition files
            [ambientDeclarationSelector('TSModuleDeclaration > TSModuleBlock')](node) {
                if (!(0, util_1.isDefinitionFile)(context.filename)) {
                    return;
                }
                const moduleDecl = (0, util_1.nullThrows)(node.parent.parent, util_1.NullThrowsReasons.MissingParent);
                if (checkForOverridingExportStatements(moduleDecl)) {
                    return;
                }
                markDeclarationChildAsUsed(node);
            },
            // collect
            'Program:exit'(programNode) {
                const unusedVars = collectUnusedVariables();
                for (const unusedVar of unusedVars) {
                    // Report the first declaration.
                    if (unusedVar.defs.length > 0) {
                        const usedOnlyAsType = unusedVar.references.some(ref => (0, referenceContainsTypeQuery_1.referenceContainsTypeQuery)(ref.identifier));
                        const messageId = usedOnlyAsType ? 'usedOnlyAsType' : 'unusedVar';
                        const isImportUsedOnlyAsType = usedOnlyAsType &&
                            unusedVar.defs.some(def => def.type === scope_manager_1.DefinitionType.ImportBinding);
                        if (isImportUsedOnlyAsType) {
                            continue;
                        }
                        report(unusedVar, {
                            messageId,
                            data: unusedVar.references.some(ref => ref.isWrite())
                                ? getAssignedMessageData(unusedVar)
                                : getDefinedMessageData(unusedVar),
                        });
                        // If there are no regular declaration, report the first `/*globals*/` comment directive.
                    }
                    else if ('eslintExplicitGlobalComments' in unusedVar &&
                        unusedVar.eslintExplicitGlobalComments) {
                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];
                        context.report({
                            loc: (0, util_1.getNameLocationInGlobalDirectiveComment)(context.sourceCode, directiveComment, unusedVar.name),
                            node: programNode,
                            messageId: 'unusedVar',
                            data: getDefinedMessageData(unusedVar),
                        });
                    }
                }
            },
        };
        function checkForOverridingExportStatements(node) {
            const cached = MODULE_DECL_CACHE.get(node);
            if (cached != null) {
                return cached;
            }
            const body = getStatementsOfNode(node);
            if (hasOverridingExportStatement(body)) {
                MODULE_DECL_CACHE.set(node, true);
                return true;
            }
            MODULE_DECL_CACHE.set(node, false);
            return false;
        }
        function ambientDeclarationSelector(parent) {
            return [
                // Types are ambiently exported
                `${parent} > :matches(${[
                    utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,
                    utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration,
                ].join(', ')})`,
                // Value things are ambiently exported if they are "declare"d
                `${parent} > :matches(${[
                    utils_1.AST_NODE_TYPES.ClassDeclaration,
                    utils_1.AST_NODE_TYPES.TSDeclareFunction,
                    utils_1.AST_NODE_TYPES.TSEnumDeclaration,
                    utils_1.AST_NODE_TYPES.TSModuleDeclaration,
                    utils_1.AST_NODE_TYPES.VariableDeclaration,
                ].join(', ')})`,
            ].join(', ');
        }
        function markDeclarationChildAsUsed(node) {
            const identifiers = [];
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:
                case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:
                case utils_1.AST_NODE_TYPES.ClassDeclaration:
                case utils_1.AST_NODE_TYPES.FunctionDeclaration:
                case utils_1.AST_NODE_TYPES.TSDeclareFunction:
                case utils_1.AST_NODE_TYPES.TSEnumDeclaration:
                case utils_1.AST_NODE_TYPES.TSModuleDeclaration:
                    if (node.id?.type === utils_1.AST_NODE_TYPES.Identifier) {
                        identifiers.push(node.id);
                    }
                    break;
                case utils_1.AST_NODE_TYPES.VariableDeclaration:
                    for (const declaration of node.declarations) {
                        visitPattern(declaration, pattern => {
                            identifiers.push(pattern);
                        });
                    }
                    break;
            }
            let scope = context.sourceCode.getScope(node);
            const shouldUseUpperScope = [
                utils_1.AST_NODE_TYPES.TSDeclareFunction,
                utils_1.AST_NODE_TYPES.TSModuleDeclaration,
            ].includes(node.type);
            if (scope.variableScope !== scope) {
                scope = scope.variableScope;
            }
            else if (shouldUseUpperScope && scope.upper) {
                scope = scope.upper;
            }
            for (const id of identifiers) {
                const superVar = scope.set.get(id.name);
                if (superVar) {
                    superVar.eslintUsed = true;
                }
            }
        }
        function visitPattern(node, cb) {
            const visitor = new scope_manager_1.PatternVisitor({}, node, cb);
            visitor.visit(node);
        }
    },
});
function hasOverridingExportStatement(body) {
    for (const statement of body) {
        if ((statement.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration &&
            statement.declaration == null) ||
            statement.type === utils_1.AST_NODE_TYPES.ExportAllDeclaration ||
            statement.type === utils_1.AST_NODE_TYPES.TSExportAssignment) {
            return true;
        }
        if (statement.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration &&
            statement.declaration.type === utils_1.AST_NODE_TYPES.Identifier) {
            return true;
        }
    }
    return false;
}
function getStatementsOfNode(block) {
    if (block.type === utils_1.AST_NODE_TYPES.Program) {
        return block.body;
    }
    return block.body.body;
}
/*

###### TODO ######

Edge cases that aren't currently handled due to laziness and them being super edgy edge cases


--- function params referenced in typeof type refs in the function declaration ---
--- NOTE - TS gets these cases wrong

function _foo(
  arg: number // arg should be unused
): typeof arg {
  return 1 as any;
}

function _bar(
  arg: number, // arg should be unused
  _arg2: typeof arg,
) {}


--- function names referenced in typeof type refs in the function declaration ---
--- NOTE - TS gets these cases right

function foo( // foo should be unused
): typeof foo {
    return 1 as any;
}

function bar( // bar should be unused
  _arg: typeof bar
) {}


--- if an interface is merged into a namespace  ---
--- NOTE - TS gets these cases wrong

namespace Test {
    interface Foo { // Foo should be unused here
        a: string;
    }
    export namespace Foo {
       export type T = 'b';
    }
}
type T = Test.Foo; // Error: Namespace 'Test' has no exported member 'Foo'.


namespace Test {
    export interface Foo {
        a: string;
    }
    namespace Foo { // Foo should be unused here
       export type T = 'b';
    }
}
type T = Test.Foo.T; // Error: Namespace 'Test' has no exported member 'Foo'.

---

These cases are mishandled because the base rule assumes that each variable has one def, but type-value shadowing
creates a variable with two defs

--- type-only or value-only references to type/value shadowed variables ---
--- NOTE - TS gets these cases wrong

type T = 1;
const T = 2; // this T should be unused

type U = T; // this U should be unused
const U = 3;

const _V = U;


--- partially exported type/value shadowed variables ---
--- NOTE - TS gets these cases wrong

export interface Foo {}
const Foo = 1; // this Foo should be unused

interface Bar {} // this Bar should be unused
export const Bar = 1;

*/


--------------------------------------------------------------------------------
FILE: no-use-before-define.d.ts
--------------------------------------------------------------------------------

import { TSESLint } from '@typescript-eslint/utils';
export interface Config {
    allowNamedExports?: boolean;
    classes?: boolean;
    enums?: boolean;
    functions?: boolean;
    ignoreTypeReferences?: boolean;
    typedefs?: boolean;
    variables?: boolean;
}
export type Options = ['nofunc' | Config];
export type MessageIds = 'noUseBeforeDefine';
declare const _default: TSESLint.RuleModule<"noUseBeforeDefine", Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-use-before-define.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const referenceContainsTypeQuery_1 = require("../util/referenceContainsTypeQuery");
const SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;
/**
 * Parses a given value as options.
 */
function parseOptions(options) {
    let functions = true;
    let classes = true;
    let enums = true;
    let variables = true;
    let typedefs = true;
    let ignoreTypeReferences = true;
    let allowNamedExports = false;
    if (typeof options === 'string') {
        functions = options !== 'nofunc';
    }
    else if (typeof options === 'object' && options != null) {
        functions = options.functions !== false;
        classes = options.classes !== false;
        enums = options.enums !== false;
        variables = options.variables !== false;
        typedefs = options.typedefs !== false;
        ignoreTypeReferences = options.ignoreTypeReferences !== false;
        allowNamedExports = options.allowNamedExports !== false;
    }
    return {
        allowNamedExports,
        classes,
        enums,
        functions,
        ignoreTypeReferences,
        typedefs,
        variables,
    };
}
/**
 * Checks whether or not a given variable is a function declaration.
 */
function isFunction(variable) {
    return variable.defs[0].type === scope_manager_1.DefinitionType.FunctionName;
}
/**
 * Checks whether or not a given variable is a type declaration.
 */
function isTypedef(variable) {
    return variable.defs[0].type === scope_manager_1.DefinitionType.Type;
}
/**
 * Checks whether or not a given variable is a enum declaration.
 */
function isOuterEnum(variable, reference) {
    return (variable.defs[0].type === scope_manager_1.DefinitionType.TSEnumName &&
        variable.scope.variableScope !== reference.from.variableScope);
}
/**
 * Checks whether or not a given variable is a class declaration in an upper function scope.
 */
function isOuterClass(variable, reference) {
    return (variable.defs[0].type === scope_manager_1.DefinitionType.ClassName &&
        variable.scope.variableScope !== reference.from.variableScope);
}
/**
 * Checks whether or not a given variable is a variable declaration in an upper function scope.
 */
function isOuterVariable(variable, reference) {
    return (variable.defs[0].type === scope_manager_1.DefinitionType.Variable &&
        variable.scope.variableScope !== reference.from.variableScope);
}
/**
 * Checks whether or not a given reference is a export reference.
 */
function isNamedExports(reference) {
    const { identifier } = reference;
    return (identifier.parent.type === utils_1.AST_NODE_TYPES.ExportSpecifier &&
        identifier.parent.local === identifier);
}
/**
 * Checks whether or not a given reference is a type reference.
 */
function isTypeReference(reference) {
    return (reference.isTypeReference ||
        (0, referenceContainsTypeQuery_1.referenceContainsTypeQuery)(reference.identifier));
}
/**
 * Checks whether or not a given location is inside of the range of a given node.
 */
function isInRange(node, location) {
    return !!node && node.range[0] <= location && location <= node.range[1];
}
/**
 * Decorators are transpiled such that the decorator is placed after the class declaration
 * So it is considered safe
 */
function isClassRefInClassDecorator(variable, reference) {
    if (variable.defs[0].type !== scope_manager_1.DefinitionType.ClassName ||
        variable.defs[0].node.decorators.length === 0) {
        return false;
    }
    for (const deco of variable.defs[0].node.decorators) {
        if (reference.identifier.range[0] >= deco.range[0] &&
            reference.identifier.range[1] <= deco.range[1]) {
            return true;
        }
    }
    return false;
}
/**
 * Checks whether or not a given reference is inside of the initializers of a given variable.
 *
 * @returns `true` in the following cases:
 * - var a = a
 * - var [a = a] = list
 * - var {a = a} = obj
 * - for (var a in a) {}
 * - for (var a of a) {}
 */
function isInInitializer(variable, reference) {
    if (variable.scope !== reference.from) {
        return false;
    }
    let node = variable.identifiers[0].parent;
    const location = reference.identifier.range[1];
    while (node) {
        if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {
            if (isInRange(node.init, location)) {
                return true;
            }
            if ((node.parent.parent.type === utils_1.AST_NODE_TYPES.ForInStatement ||
                node.parent.parent.type === utils_1.AST_NODE_TYPES.ForOfStatement) &&
                isInRange(node.parent.parent.right, location)) {
                return true;
            }
            break;
        }
        else if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {
            if (isInRange(node.right, location)) {
                return true;
            }
        }
        else if (SENTINEL_TYPE.test(node.type)) {
            break;
        }
        node = node.parent;
    }
    return false;
}
exports.default = (0, util_1.createRule)({
    name: 'no-use-before-define',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow the use of variables before they are defined',
            extendsBaseRule: true,
        },
        messages: {
            noUseBeforeDefine: "'{{name}}' was used before it was defined.",
        },
        schema: [
            {
                oneOf: [
                    {
                        type: 'string',
                        description: 'Broadly set functions and allowNamedExports to false.',
                        enum: ['nofunc'],
                    },
                    {
                        type: 'object',
                        additionalProperties: false,
                        properties: {
                            allowNamedExports: {
                                type: 'boolean',
                                description: 'Whether to ignore named exports.',
                            },
                            classes: {
                                type: 'boolean',
                                description: 'Whether to ignore references to class declarations.',
                            },
                            enums: {
                                type: 'boolean',
                                description: 'Whether to check references to enums.',
                            },
                            functions: {
                                type: 'boolean',
                                description: 'Whether to ignore references to function declarations.',
                            },
                            ignoreTypeReferences: {
                                type: 'boolean',
                                description: 'Whether to ignore type references, such as in type annotations and assertions.',
                            },
                            typedefs: {
                                type: 'boolean',
                                description: 'Whether to check references to types.',
                            },
                            variables: {
                                type: 'boolean',
                                description: 'Whether to ignore references to variables.',
                            },
                        },
                    },
                ],
            },
        ],
    },
    defaultOptions: [
        {
            allowNamedExports: false,
            classes: true,
            enums: true,
            functions: true,
            ignoreTypeReferences: true,
            typedefs: true,
            variables: true,
        },
    ],
    create(context, optionsWithDefault) {
        const options = parseOptions(optionsWithDefault[0]);
        /**
         * Determines whether a given use-before-define case should be reported according to the options.
         * @param variable The variable that gets used before being defined
         * @param reference The reference to the variable
         */
        function isForbidden(variable, reference) {
            if (options.ignoreTypeReferences && isTypeReference(reference)) {
                return false;
            }
            if (isFunction(variable)) {
                return options.functions;
            }
            if (isOuterClass(variable, reference)) {
                return options.classes;
            }
            if (isOuterVariable(variable, reference)) {
                return options.variables;
            }
            if (isOuterEnum(variable, reference)) {
                return options.enums;
            }
            if (isTypedef(variable)) {
                return options.typedefs;
            }
            return true;
        }
        function isDefinedBeforeUse(variable, reference) {
            return (variable.identifiers[0].range[1] <= reference.identifier.range[1] &&
                !(reference.isValueReference && isInInitializer(variable, reference)));
        }
        /**
         * Finds and validates all variables in a given scope.
         */
        function findVariablesInScope(scope) {
            scope.references.forEach(reference => {
                const variable = reference.resolved;
                function report() {
                    context.report({
                        node: reference.identifier,
                        messageId: 'noUseBeforeDefine',
                        data: {
                            name: reference.identifier.name,
                        },
                    });
                }
                // Skips when the reference is:
                // - initializations.
                // - referring to an undefined variable.
                // - referring to a global environment variable (there're no identifiers).
                // - located preceded by the variable (except in initializers).
                // - allowed by options.
                if (reference.init) {
                    return;
                }
                if (!options.allowNamedExports && isNamedExports(reference)) {
                    if (!variable || !isDefinedBeforeUse(variable, reference)) {
                        report();
                    }
                    return;
                }
                if (!variable) {
                    return;
                }
                if (variable.identifiers.length === 0 ||
                    isDefinedBeforeUse(variable, reference) ||
                    !isForbidden(variable, reference) ||
                    isClassRefInClassDecorator(variable, reference) ||
                    reference.from.type === utils_1.TSESLint.Scope.ScopeType.functionType) {
                    return;
                }
                // Reports.
                report();
            });
            scope.childScopes.forEach(findVariablesInScope);
        }
        return {
            Program(node) {
                findVariablesInScope(context.sourceCode.getScope(node));
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-useless-constructor.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noUselessConstructor" | "removeConstructor", [], unknown, {
    MethodDefinition(node: TSESTree.MethodDefinition): void;
}>;
export type Options = InferOptionsTypeFromRule<typeof baseRule>;
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noUselessConstructor" | "removeConstructor", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-useless-constructor.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-useless-constructor');
/**
 * Check if method with accessibility is not useless
 */
function checkAccessibility(node) {
    switch (node.accessibility) {
        case 'protected':
        case 'private':
            return false;
        case 'public':
            if (node.parent.parent.superClass) {
                return false;
            }
            break;
    }
    return true;
}
/**
 * Check if method is not useless due to typescript parameter properties and decorators
 */
function checkParams(node) {
    return !node.value.params.some(param => param.type === utils_1.AST_NODE_TYPES.TSParameterProperty ||
        param.decorators.length);
}
exports.default = (0, util_1.createRule)({
    name: 'no-useless-constructor',
    meta: {
        type: 'problem',
        // defaultOptions, -- base rule does not use defaultOptions
        docs: {
            description: 'Disallow unnecessary constructors',
            extendsBaseRule: true,
            recommended: 'strict',
        },
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema: baseRule.meta.schema,
    },
    defaultOptions: [],
    create(context) {
        const rules = baseRule.create(context);
        return {
            MethodDefinition(node) {
                if (node.value.type === utils_1.AST_NODE_TYPES.FunctionExpression &&
                    checkAccessibility(node) &&
                    checkParams(node)) {
                    rules.MethodDefinition(node);
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-useless-default-assignment.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
type MessageId = 'preferOptionalSyntax' | 'uselessDefaultAssignment' | 'uselessUndefined';
declare const _default: TSESLint.RuleModule<MessageId, [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-useless-default-assignment.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-useless-default-assignment',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow default values that will never be used',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            preferOptionalSyntax: 'Using `= undefined` to make a parameter optional adds unnecessary runtime logic. Use the `?` optional syntax instead.',
            uselessDefaultAssignment: 'Default value is useless because the {{ type }} is not optional.',
            uselessUndefined: 'Default value is useless because it is undefined. Optional {{ type }}s are already undefined by default.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function canBeUndefined(type) {
            if ((0, util_1.isTypeAnyType)(type) || (0, util_1.isTypeUnknownType)(type)) {
                return true;
            }
            return tsutils
                .unionConstituents(type)
                .some(part => (0, util_1.isTypeFlagSet)(part, ts.TypeFlags.Undefined));
        }
        function getArrayElementType(arrayType, elementIndex) {
            if (checker.isTupleType(arrayType)) {
                const tupleArgs = checker.getTypeArguments(arrayType);
                if (elementIndex < tupleArgs.length) {
                    return tupleArgs[elementIndex];
                }
            }
            return arrayType.getNumberIndexType() ?? null;
        }
        function checkAssignmentPattern(node) {
            if (node.right.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.right.name === 'undefined') {
                const tsNode = services.esTreeNodeToTSNodeMap.get(node);
                if (ts.isParameter(tsNode) &&
                    tsNode.type &&
                    canBeUndefined(checker.getTypeFromTypeNode(tsNode.type))) {
                    reportPreferOptionalSyntax(node);
                    return;
                }
                const type = node.parent.type === utils_1.AST_NODE_TYPES.Property ||
                    node.parent.type === utils_1.AST_NODE_TYPES.ArrayPattern
                    ? 'property'
                    : 'parameter';
                reportUselessUndefined(node, type);
                return;
            }
            const parent = node.parent;
            if (parent.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                parent.type === utils_1.AST_NODE_TYPES.FunctionExpression) {
                const paramIndex = parent.params.indexOf(node);
                if (paramIndex !== -1) {
                    const tsFunc = services.esTreeNodeToTSNodeMap.get(parent);
                    if (ts.isFunctionLike(tsFunc)) {
                        const contextualType = checker.getContextualType(tsFunc);
                        if (!contextualType) {
                            return;
                        }
                        const signatures = contextualType.getCallSignatures();
                        if (signatures.length === 0 ||
                            signatures[0].getDeclaration() === tsFunc) {
                            return;
                        }
                        const params = signatures[0].getParameters();
                        if (paramIndex < params.length) {
                            const paramSymbol = params[paramIndex];
                            if (paramSymbol.valueDeclaration &&
                                ts.isParameter(paramSymbol.valueDeclaration) &&
                                paramSymbol.valueDeclaration.dotDotDotToken != null) {
                                return;
                            }
                            if ((paramSymbol.flags & ts.SymbolFlags.Optional) === 0) {
                                const paramType = checker.getTypeOfSymbol(paramSymbol);
                                if (!canBeUndefined(paramType)) {
                                    reportUselessDefaultAssignment(node, 'parameter');
                                }
                            }
                        }
                    }
                }
                return;
            }
            if (parent.type === utils_1.AST_NODE_TYPES.Property) {
                const propertyType = getTypeOfProperty(parent);
                if (!propertyType) {
                    return;
                }
                if (!canBeUndefined(propertyType)) {
                    reportUselessDefaultAssignment(node, 'property');
                }
            }
            else if (parent.type === utils_1.AST_NODE_TYPES.ArrayPattern) {
                const sourceType = getSourceTypeForPattern(parent);
                if (!sourceType) {
                    return;
                }
                if (!checker.isTupleType(sourceType)) {
                    return;
                }
                const tupleArgs = checker.getTypeArguments(sourceType);
                const elementIndex = parent.elements.indexOf(node);
                if (elementIndex < 0 || elementIndex >= tupleArgs.length) {
                    return;
                }
                const elementType = tupleArgs[elementIndex];
                if (!canBeUndefined(elementType)) {
                    reportUselessDefaultAssignment(node, 'property');
                }
            }
        }
        function getTypeOfProperty(node) {
            const objectPattern = node.parent;
            const sourceType = getSourceTypeForPattern(objectPattern);
            if (!sourceType) {
                return null;
            }
            const propertyName = getPropertyName(node.key);
            if (!propertyName) {
                return null;
            }
            const symbol = sourceType.getProperty(propertyName);
            if (!symbol) {
                return null;
            }
            if (symbol.flags & ts.SymbolFlags.Optional &&
                hasConditionalInitializer(objectPattern)) {
                return null;
            }
            return checker.getTypeOfSymbol(symbol);
        }
        function hasConditionalInitializer(node) {
            const parent = node.parent;
            if (!parent) {
                return false;
            }
            if (parent.type === utils_1.AST_NODE_TYPES.VariableDeclarator && parent.init) {
                return (parent.init.type === utils_1.AST_NODE_TYPES.ConditionalExpression ||
                    parent.init.type === utils_1.AST_NODE_TYPES.LogicalExpression);
            }
            return hasConditionalInitializer(parent);
        }
        function getSourceTypeForPattern(pattern) {
            const parent = (0, util_1.nullThrows)(pattern.parent, util_1.NullThrowsReasons.MissingParent);
            if (parent.type === utils_1.AST_NODE_TYPES.VariableDeclarator && parent.init) {
                const tsNode = services.esTreeNodeToTSNodeMap.get(parent.init);
                return checker.getTypeAtLocation(tsNode);
            }
            if ((0, util_1.isFunction)(parent)) {
                const paramIndex = parent.params.indexOf(pattern);
                const tsFunc = services.esTreeNodeToTSNodeMap.get(parent);
                const signature = (0, util_1.nullThrows)(checker.getSignatureFromDeclaration(tsFunc), util_1.NullThrowsReasons.MissingToken('signature', 'function'));
                const params = signature.getParameters();
                return checker.getTypeOfSymbol(params[paramIndex]);
            }
            if (parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {
                return getSourceTypeForPattern(parent);
            }
            if (parent.type === utils_1.AST_NODE_TYPES.Property) {
                return getTypeOfProperty(parent);
            }
            if (parent.type === utils_1.AST_NODE_TYPES.ArrayPattern) {
                const arrayType = getSourceTypeForPattern(parent);
                if (!arrayType) {
                    return null;
                }
                const elementIndex = parent.elements.indexOf(pattern);
                return getArrayElementType(arrayType, elementIndex);
            }
            return null;
        }
        function getPropertyName(key) {
            switch (key.type) {
                case utils_1.AST_NODE_TYPES.Identifier:
                    return key.name;
                case utils_1.AST_NODE_TYPES.Literal:
                    return String(key.value);
                default:
                    return null;
            }
        }
        function reportUselessDefaultAssignment(node, type) {
            context.report({
                node: node.right,
                messageId: 'uselessDefaultAssignment',
                data: { type },
                fix: fixer => removeDefault(fixer, node),
            });
        }
        function reportUselessUndefined(node, type) {
            context.report({
                node: node.right,
                messageId: 'uselessUndefined',
                data: { type },
                fix: fixer => removeDefault(fixer, node),
            });
        }
        function reportPreferOptionalSyntax(node) {
            context.report({
                node: node.right,
                messageId: 'preferOptionalSyntax',
                *fix(fixer) {
                    yield removeDefault(fixer, node);
                    const { left } = node;
                    if (left.type === utils_1.AST_NODE_TYPES.Identifier) {
                        yield fixer.insertTextAfterRange([left.range[0], left.range[0] + left.name.length], '?');
                    }
                },
            });
        }
        function removeDefault(fixer, node) {
            const start = node.left.range[1];
            const end = node.range[1];
            return fixer.removeRange([start, end]);
        }
        return {
            AssignmentPattern: checkAssignmentPattern,
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-useless-empty-export.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"uselessExport", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-useless-empty-export.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
function isEmptyExport(node) {
    return (node.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration &&
        node.specifiers.length === 0 &&
        !node.declaration);
}
const exportOrImportNodeTypes = new Set([
    utils_1.AST_NODE_TYPES.ExportAllDeclaration,
    utils_1.AST_NODE_TYPES.ExportDefaultDeclaration,
    utils_1.AST_NODE_TYPES.ExportNamedDeclaration,
    utils_1.AST_NODE_TYPES.ExportSpecifier,
    utils_1.AST_NODE_TYPES.ImportDeclaration,
    utils_1.AST_NODE_TYPES.TSExportAssignment,
    utils_1.AST_NODE_TYPES.TSImportEqualsDeclaration,
]);
exports.default = (0, util_1.createRule)({
    name: 'no-useless-empty-export',
    meta: {
        type: 'suggestion',
        docs: {
            description: "Disallow empty exports that don't change anything in a module file",
        },
        fixable: 'code',
        hasSuggestions: false,
        messages: {
            uselessExport: 'Empty export does nothing and can be removed.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        // In a definition file, export {} is necessary to make the module properly
        // encapsulated, even when there are other exports
        // https://github.com/typescript-eslint/typescript-eslint/issues/4975
        if ((0, util_1.isDefinitionFile)(context.filename)) {
            return {};
        }
        function checkNode(node) {
            if (!Array.isArray(node.body)) {
                return;
            }
            const emptyExports = [];
            let foundOtherExport = false;
            for (const statement of node.body) {
                if (isEmptyExport(statement)) {
                    emptyExports.push(statement);
                }
                else if (exportOrImportNodeTypes.has(statement.type)) {
                    foundOtherExport = true;
                }
            }
            if (foundOtherExport) {
                for (const emptyExport of emptyExports) {
                    context.report({
                        node: emptyExport,
                        messageId: 'uselessExport',
                        fix: fixer => fixer.remove(emptyExport),
                    });
                }
            }
        }
        return {
            Program: checkNode,
            TSModuleDeclaration: checkNode,
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-var-requires.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allow: string[];
    }
];
export type MessageIds = 'noVarReqs';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"noVarReqs", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-var-requires.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'no-var-requires',
    meta: {
        type: 'problem',
        deprecated: {
            deprecatedSince: '8.0.0',
            replacedBy: [
                {
                    rule: {
                        name: '@typescript-eslint/no-require-imports',
                        url: 'https://typescript-eslint.io/rules/no-require-imports',
                    },
                },
            ],
            url: 'https://github.com/typescript-eslint/typescript-eslint/pull/8334',
        },
        docs: {
            description: 'Disallow `require` statements except in import statements',
        },
        messages: {
            noVarReqs: 'Require statement not part of import statement.',
        },
        replacedBy: ['@typescript-eslint/no-require-imports'],
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allow: {
                        type: 'array',
                        description: 'Patterns of import paths to allow requiring from.',
                        items: { type: 'string' },
                    },
                },
            },
        ],
    },
    defaultOptions: [{ allow: [] }],
    create(context, options) {
        const allowPatterns = options[0].allow.map(pattern => new RegExp(pattern, 'u'));
        function isImportPathAllowed(importPath) {
            return allowPatterns.some(pattern => importPath.match(pattern));
        }
        function isStringOrTemplateLiteral(node) {
            return ((node.type === utils_1.AST_NODE_TYPES.Literal &&
                typeof node.value === 'string') ||
                node.type === utils_1.AST_NODE_TYPES.TemplateLiteral);
        }
        return {
            'CallExpression[callee.name="require"]'(node) {
                if (node.arguments[0] && isStringOrTemplateLiteral(node.arguments[0])) {
                    const argValue = (0, util_1.getStaticStringValue)(node.arguments[0]);
                    if (typeof argValue === 'string' && isImportPathAllowed(argValue)) {
                        return;
                    }
                }
                const parent = node.parent.type === utils_1.AST_NODE_TYPES.ChainExpression
                    ? node.parent.parent
                    : node.parent;
                if ([
                    utils_1.AST_NODE_TYPES.CallExpression,
                    utils_1.AST_NODE_TYPES.MemberExpression,
                    utils_1.AST_NODE_TYPES.NewExpression,
                    utils_1.AST_NODE_TYPES.TSAsExpression,
                    utils_1.AST_NODE_TYPES.TSTypeAssertion,
                    utils_1.AST_NODE_TYPES.VariableDeclarator,
                ].includes(parent.type)) {
                    const variable = utils_1.ASTUtils.findVariable(context.sourceCode.getScope(node), 'require');
                    if (!variable?.identifiers.length) {
                        context.report({
                            node,
                            messageId: 'noVarReqs',
                        });
                    }
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: no-wrapper-object-types.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"bannedClassType", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: no-wrapper-object-types.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const classNames = new Set([
    'BigInt',
    // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
    'Boolean',
    'Number',
    'Object',
    // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
    'String',
    'Symbol',
]);
exports.default = (0, util_1.createRule)({
    name: 'no-wrapper-object-types',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow using confusing built-in primitive class wrappers',
            recommended: 'recommended',
        },
        fixable: 'code',
        messages: {
            bannedClassType: 'Prefer using the primitive `{{preferred}}` as a type name, rather than the upper-cased `{{typeName}}`.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function checkBannedTypes(node, includeFix) {
            const typeName = node.type === utils_1.AST_NODE_TYPES.Identifier && node.name;
            if (!typeName ||
                !classNames.has(typeName) ||
                !(0, util_1.isReferenceToGlobalFunction)(typeName, node, context.sourceCode)) {
                return;
            }
            const preferred = typeName.toLowerCase();
            context.report({
                node,
                messageId: 'bannedClassType',
                data: { preferred, typeName },
                fix: includeFix
                    ? (fixer) => fixer.replaceText(node, preferred)
                    : undefined,
            });
        }
        return {
            TSClassImplements(node) {
                checkBannedTypes(node.expression, false);
            },
            TSInterfaceHeritage(node) {
                checkBannedTypes(node.expression, false);
            },
            TSTypeReference(node) {
                checkBannedTypes(node.typeName, true);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: non-nullable-type-assertion-style.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferNonNullAssertion", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: non-nullable-type-assertion-style.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'non-nullable-type-assertion-style',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce non-null assertions over explicit type assertions',
            recommended: 'stylistic',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            preferNonNullAssertion: 'Use a ! assertion to more succinctly remove null and undefined from the type.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const getTypesIfNotLoose = (node) => {
            const type = services.getTypeAtLocation(node);
            if (tsutils.isTypeFlagSet(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
                return undefined;
            }
            return tsutils.unionConstituents(type);
        };
        const couldBeNullish = (type) => {
            if (type.flags & ts.TypeFlags.TypeParameter) {
                const constraint = type.getConstraint();
                return constraint == null || couldBeNullish(constraint);
            }
            if (tsutils.isUnionType(type)) {
                for (const part of type.types) {
                    if (couldBeNullish(part)) {
                        return true;
                    }
                }
                return false;
            }
            return (type.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) !== 0;
        };
        const sameTypeWithoutNullish = (assertedTypes, originalTypes) => {
            const nonNullishOriginalTypes = originalTypes.filter(type => (type.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) === 0);
            if (nonNullishOriginalTypes.length === originalTypes.length) {
                return false;
            }
            for (const assertedType of assertedTypes) {
                if (couldBeNullish(assertedType) ||
                    !nonNullishOriginalTypes.includes(assertedType)) {
                    return false;
                }
            }
            for (const originalType of nonNullishOriginalTypes) {
                if (!assertedTypes.includes(originalType)) {
                    return false;
                }
            }
            return true;
        };
        const isConstAssertion = (node) => {
            return (node.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference &&
                node.typeAnnotation.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.typeAnnotation.typeName.name === 'const');
        };
        return {
            'TSAsExpression, TSTypeAssertion'(node) {
                if (isConstAssertion(node)) {
                    return;
                }
                const originalTypes = getTypesIfNotLoose(node.expression);
                if (!originalTypes) {
                    return;
                }
                const assertedTypes = getTypesIfNotLoose(node.typeAnnotation);
                if (!assertedTypes) {
                    return;
                }
                if (sameTypeWithoutNullish(assertedTypes, originalTypes)) {
                    const expressionSourceCode = context.sourceCode.getText(node.expression);
                    const higherPrecedenceThanUnary = (0, util_1.getOperatorPrecedence)(services.esTreeNodeToTSNodeMap.get(node.expression).kind, ts.SyntaxKind.Unknown) > util_1.OperatorPrecedence.Unary;
                    context.report({
                        node,
                        messageId: 'preferNonNullAssertion',
                        fix(fixer) {
                            return fixer.replaceText(node, higherPrecedenceThanUnary
                                ? `${expressionSourceCode}!`
                                : `(${expressionSourceCode})!`);
                        },
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: only-throw-error.d.ts
--------------------------------------------------------------------------------

import type { TypeOrValueSpecifier } from '../util';
export type MessageIds = 'object' | 'undef';
export type Options = [
    {
        allow?: TypeOrValueSpecifier[];
        allowRethrowing?: boolean;
        allowThrowingAny?: boolean;
        allowThrowingUnknown?: boolean;
    }
];
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: only-throw-error.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const ts_api_utils_1 = require("ts-api-utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const promiseUtils_1 = require("../util/promiseUtils");
exports.default = (0, util_1.createRule)({
    name: 'only-throw-error',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow throwing non-`Error` values as exceptions',
            extendsBaseRule: 'no-throw-literal',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            object: 'Expected an error object to be thrown.',
            undef: 'Do not throw undefined.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allow: {
                        ...util_1.typeOrValueSpecifiersSchema,
                        description: 'Type specifiers that can be thrown.',
                    },
                    allowRethrowing: {
                        type: 'boolean',
                        description: 'Whether to allow rethrowing caught values that are not `Error` objects.',
                    },
                    allowThrowingAny: {
                        type: 'boolean',
                        description: 'Whether to always allow throwing values typed as `any`.',
                    },
                    allowThrowingUnknown: {
                        type: 'boolean',
                        description: 'Whether to always allow throwing values typed as `unknown`.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allow: [],
            allowRethrowing: true,
            allowThrowingAny: true,
            allowThrowingUnknown: true,
        },
    ],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const allow = options.allow;
        function isRethrownError(node) {
            if (node.type !== utils_1.AST_NODE_TYPES.Identifier) {
                return false;
            }
            const scope = context.sourceCode.getScope(node);
            const smVariable = (0, util_1.nullThrows)((0, util_1.findVariable)(scope, node), `Variable ${node.name} should exist in scope manager`);
            const variableDefinitions = smVariable.defs.filter(def => def.isVariableDefinition);
            if (variableDefinitions.length !== 1) {
                return false;
            }
            const def = smVariable.defs[0];
            // try { /* ... */ } catch (x) { throw x; }
            if (def.node.type === utils_1.AST_NODE_TYPES.CatchClause) {
                return true;
            }
            // promise.catch(x => { throw x; })
            // promise.then(onFulfilled, x => { throw x; })
            if (def.node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&
                def.node.params.length >= 1 &&
                def.node.params[0] === def.name &&
                def.node.parent.type === utils_1.AST_NODE_TYPES.CallExpression) {
                const callExpression = def.node.parent;
                const parsedPromiseHandlingCall = (0, promiseUtils_1.parseCatchCall)(callExpression, context) ??
                    (0, promiseUtils_1.parseThenCall)(callExpression, context);
                if (parsedPromiseHandlingCall != null) {
                    const { object, onRejected } = parsedPromiseHandlingCall;
                    if (onRejected === def.node) {
                        const tsObjectNode = services.esTreeNodeToTSNodeMap.get(object);
                        // make sure we're actually dealing with a promise
                        if ((0, ts_api_utils_1.isThenableType)(services.program.getTypeChecker(), tsObjectNode)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        function checkThrowArgument(node) {
            if (options.allowRethrowing && isRethrownError(node)) {
                return;
            }
            const type = services.getTypeAtLocation(node);
            if ((0, util_1.typeMatchesSomeSpecifier)(type, allow, services.program)) {
                return;
            }
            if (type.flags & ts.TypeFlags.Undefined) {
                context.report({ node, messageId: 'undef' });
                return;
            }
            if (options.allowThrowingAny && (0, util_1.isTypeAnyType)(type)) {
                return;
            }
            if (options.allowThrowingUnknown && (0, util_1.isTypeUnknownType)(type)) {
                return;
            }
            if ((0, util_1.isErrorLike)(services.program, type)) {
                return;
            }
            context.report({ node, messageId: 'object' });
        }
        return {
            ThrowStatement(node) {
                checkThrowArgument(node.argument);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: parameter-properties.d.ts
--------------------------------------------------------------------------------

type Modifier = 'private' | 'private readonly' | 'protected' | 'protected readonly' | 'public' | 'public readonly' | 'readonly';
type Prefer = 'class-property' | 'parameter-property';
export type Options = [
    {
        allow?: Modifier[];
        prefer?: Prefer;
    }
];
export type MessageIds = 'preferClassProperty' | 'preferParameterProperty';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: parameter-properties.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'parameter-properties',
    meta: {
        type: 'problem',
        docs: {
            description: 'Require or disallow parameter properties in class constructors',
        },
        messages: {
            preferClassProperty: 'Property {{parameter}} should be declared as a class property.',
            preferParameterProperty: 'Property {{parameter}} should be declared as a parameter property.',
        },
        schema: [
            {
                type: 'object',
                $defs: {
                    modifier: {
                        type: 'string',
                        enum: [
                            'readonly',
                            'private',
                            'protected',
                            'public',
                            'private readonly',
                            'protected readonly',
                            'public readonly',
                        ],
                    },
                },
                additionalProperties: false,
                properties: {
                    allow: {
                        type: 'array',
                        description: 'Whether to allow certain kinds of properties to be ignored.',
                        items: {
                            $ref: '#/items/0/$defs/modifier',
                        },
                    },
                    prefer: {
                        type: 'string',
                        description: 'Whether to prefer class properties or parameter properties.',
                        enum: ['class-property', 'parameter-property'],
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allow: [],
            prefer: 'class-property',
        },
    ],
    create(context, [{ allow = [], prefer = 'class-property' }]) {
        /**
         * Gets the modifiers of `node`.
         * @param node the node to be inspected.
         */
        function getModifiers(node) {
            const modifiers = [];
            if (node.accessibility) {
                modifiers.push(node.accessibility);
            }
            if (node.readonly) {
                modifiers.push('readonly');
            }
            return modifiers.filter(Boolean).join(' ');
        }
        if (prefer === 'class-property') {
            return {
                TSParameterProperty(node) {
                    const modifiers = getModifiers(node);
                    if (!allow.includes(modifiers)) {
                        const name = node.parameter.type === utils_1.AST_NODE_TYPES.Identifier
                            ? node.parameter.name
                            : node.parameter.left.name;
                        context.report({
                            node,
                            messageId: 'preferClassProperty',
                            data: {
                                parameter: name,
                            },
                        });
                    }
                },
            };
        }
        const propertyNodesByNameStack = [];
        function getNodesByName(name) {
            const propertyNodesByName = propertyNodesByNameStack[propertyNodesByNameStack.length - 1];
            const existing = propertyNodesByName.get(name);
            if (existing) {
                return existing;
            }
            const created = {};
            propertyNodesByName.set(name, created);
            return created;
        }
        function typeAnnotationsMatch(classProperty, constructorParameter) {
            if (!classProperty.typeAnnotation ||
                !constructorParameter.typeAnnotation) {
                return (classProperty.typeAnnotation === constructorParameter.typeAnnotation);
            }
            return (context.sourceCode.getText(classProperty.typeAnnotation) ===
                context.sourceCode.getText(constructorParameter.typeAnnotation));
        }
        return {
            ':matches(ClassDeclaration, ClassExpression):exit'() {
                const propertyNodesByName = (0, util_1.nullThrows)(propertyNodesByNameStack.pop(), 'Stack should exist on class exit');
                for (const [name, nodes] of propertyNodesByName) {
                    if (nodes.classProperty &&
                        nodes.constructorAssignment &&
                        nodes.constructorParameter &&
                        typeAnnotationsMatch(nodes.classProperty, nodes.constructorParameter)) {
                        context.report({
                            node: nodes.classProperty,
                            messageId: 'preferParameterProperty',
                            data: {
                                parameter: name,
                            },
                        });
                    }
                }
            },
            ClassBody(node) {
                for (const element of node.body) {
                    if (element.type === utils_1.AST_NODE_TYPES.PropertyDefinition &&
                        element.key.type === utils_1.AST_NODE_TYPES.Identifier &&
                        !element.value &&
                        !allow.includes(getModifiers(element))) {
                        getNodesByName(element.key.name).classProperty = element;
                    }
                }
            },
            'ClassDeclaration, ClassExpression'() {
                propertyNodesByNameStack.push(new Map());
            },
            'MethodDefinition[kind="constructor"]'(node) {
                for (const parameter of node.value.params) {
                    if (parameter.type === utils_1.AST_NODE_TYPES.Identifier) {
                        getNodesByName(parameter.name).constructorParameter = parameter;
                    }
                }
                for (const statement of node.value.body?.body ?? []) {
                    if (statement.type !== utils_1.AST_NODE_TYPES.ExpressionStatement ||
                        statement.expression.type !== utils_1.AST_NODE_TYPES.AssignmentExpression ||
                        statement.expression.left.type !==
                            utils_1.AST_NODE_TYPES.MemberExpression ||
                        statement.expression.left.object.type !==
                            utils_1.AST_NODE_TYPES.ThisExpression ||
                        statement.expression.left.property.type !==
                            utils_1.AST_NODE_TYPES.Identifier ||
                        statement.expression.right.type !== utils_1.AST_NODE_TYPES.Identifier) {
                        break;
                    }
                    getNodesByName(statement.expression.right.name).constructorAssignment = statement.expression;
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-as-const.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"preferConstAssertion" | "variableConstAssertion" | "variableSuggest", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-as-const.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-as-const',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce the use of `as const` over literal type',
            recommended: 'recommended',
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            preferConstAssertion: 'Expected a `const` instead of a literal type assertion.',
            variableConstAssertion: 'Expected a `const` assertion instead of a literal type annotation.',
            variableSuggest: 'You should use `as const` instead of type annotation.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function compareTypes(valueNode, typeNode, canFix) {
            if (valueNode.type === utils_1.AST_NODE_TYPES.Literal &&
                typeNode.type === utils_1.AST_NODE_TYPES.TSLiteralType &&
                typeNode.literal.type === utils_1.AST_NODE_TYPES.Literal &&
                valueNode.raw === typeNode.literal.raw) {
                if (canFix) {
                    context.report({
                        node: typeNode,
                        messageId: 'preferConstAssertion',
                        fix: fixer => fixer.replaceText(typeNode, 'const'),
                    });
                }
                else {
                    context.report({
                        node: typeNode,
                        messageId: 'variableConstAssertion',
                        suggest: [
                            {
                                messageId: 'variableSuggest',
                                fix: (fixer) => [
                                    fixer.remove(typeNode.parent),
                                    fixer.insertTextAfter(valueNode, ' as const'),
                                ],
                            },
                        ],
                    });
                }
            }
        }
        return {
            PropertyDefinition(node) {
                if (node.value && node.typeAnnotation) {
                    compareTypes(node.value, node.typeAnnotation.typeAnnotation, false);
                }
            },
            TSAsExpression(node) {
                compareTypes(node.expression, node.typeAnnotation, true);
            },
            TSTypeAssertion(node) {
                compareTypes(node.expression, node.typeAnnotation, true);
            },
            VariableDeclarator(node) {
                if (node.init && node.id.typeAnnotation) {
                    compareTypes(node.init, node.id.typeAnnotation.typeAnnotation, false);
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-destructuring.d.ts
--------------------------------------------------------------------------------

import type { TSESLint, TSESTree } from '@typescript-eslint/utils';
import type { InferMessageIdsTypeFromRule, InferOptionsTypeFromRule } from '../util';
declare const baseRule: TSESLint.RuleModule<"preferDestructuring", [import("eslint/lib/rules/prefer-destructuring").DestructuringTypeConfig | {
    AssignmentExpression?: import("eslint/lib/rules/prefer-destructuring").DestructuringTypeConfig;
    VariableDeclarator?: import("eslint/lib/rules/prefer-destructuring").DestructuringTypeConfig;
}, (import("eslint/lib/rules/prefer-destructuring").Option1 | undefined)?], unknown, {
    AssignmentExpression(node: TSESTree.AssignmentExpression): void;
    VariableDeclarator(node: TSESTree.VariableDeclarator): void;
}>;
type BaseOptions = InferOptionsTypeFromRule<typeof baseRule>;
type EnforcementOptions = {
    enforceForDeclarationWithTypeAnnotation?: boolean;
} & BaseOptions[1];
export type Options = [BaseOptions[0], EnforcementOptions];
export type MessageIds = InferMessageIdsTypeFromRule<typeof baseRule>;
declare const _default: TSESLint.RuleModule<"preferDestructuring", Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-destructuring.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('prefer-destructuring');
const destructuringTypeConfig = {
    type: 'object',
    additionalProperties: false,
    properties: {
        array: {
            type: 'boolean',
        },
        object: {
            type: 'boolean',
        },
    },
};
const schema = [
    {
        oneOf: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    AssignmentExpression: destructuringTypeConfig,
                    VariableDeclarator: destructuringTypeConfig,
                },
            },
            destructuringTypeConfig,
        ],
    },
    {
        type: 'object',
        additionalProperties: false,
        properties: {
            enforceForDeclarationWithTypeAnnotation: {
                type: 'boolean',
                description: 'Whether to enforce destructuring on variable declarations with type annotations.',
            },
            enforceForRenamedProperties: {
                type: 'boolean',
                description: 'Whether to enforce destructuring that use a different variable name than the property name.',
            },
        },
    },
];
exports.default = (0, util_1.createRule)({
    name: 'prefer-destructuring',
    meta: {
        type: 'suggestion',
        // defaultOptions, -- base rule does not use defaultOptions
        docs: {
            description: 'Require destructuring from arrays and/or objects',
            extendsBaseRule: true,
            frozen: true,
            requiresTypeChecking: true,
        },
        fixable: baseRule.meta.fixable,
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
        schema,
    },
    defaultOptions: [
        {
            AssignmentExpression: {
                array: true,
                object: true,
            },
            VariableDeclarator: {
                array: true,
                object: true,
            },
        },
        {},
    ],
    create(context, [enabledTypes, options]) {
        const { enforceForDeclarationWithTypeAnnotation = false, enforceForRenamedProperties = false, } = options;
        const { esTreeNodeToTSNodeMap, program } = (0, util_1.getParserServices)(context);
        const typeChecker = program.getTypeChecker();
        const baseRules = baseRule.create(context);
        let baseRulesWithoutFixCache = null;
        return {
            AssignmentExpression(node) {
                if (node.operator !== '=') {
                    return;
                }
                performCheck(node.left, node.right, node);
            },
            VariableDeclarator(node) {
                performCheck(node.id, node.init, node);
            },
        };
        function performCheck(leftNode, rightNode, reportNode) {
            const rules = leftNode.type === utils_1.AST_NODE_TYPES.Identifier &&
                leftNode.typeAnnotation == null
                ? baseRules
                : baseRulesWithoutFix();
            if ((leftNode.type === utils_1.AST_NODE_TYPES.ArrayPattern ||
                leftNode.type === utils_1.AST_NODE_TYPES.Identifier ||
                leftNode.type === utils_1.AST_NODE_TYPES.ObjectPattern) &&
                leftNode.typeAnnotation != null &&
                !enforceForDeclarationWithTypeAnnotation) {
                return;
            }
            if (rightNode != null &&
                isArrayLiteralIntegerIndexAccess(rightNode) &&
                rightNode.object.type !== utils_1.AST_NODE_TYPES.Super) {
                const tsObj = esTreeNodeToTSNodeMap.get(rightNode.object);
                const objType = typeChecker.getTypeAtLocation(tsObj);
                if (!isTypeAnyOrIterableType(objType, typeChecker)) {
                    if (!enforceForRenamedProperties ||
                        !getNormalizedEnabledType(reportNode.type, 'object')) {
                        return;
                    }
                    context.report({
                        node: reportNode,
                        messageId: 'preferDestructuring',
                        data: { type: 'object' },
                    });
                    return;
                }
            }
            if (reportNode.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {
                rules.AssignmentExpression(reportNode);
            }
            else {
                rules.VariableDeclarator(reportNode);
            }
        }
        function getNormalizedEnabledType(nodeType, destructuringType) {
            if ('object' in enabledTypes || 'array' in enabledTypes) {
                return enabledTypes[destructuringType];
            }
            return enabledTypes[nodeType][destructuringType];
        }
        function baseRulesWithoutFix() {
            baseRulesWithoutFixCache ??= baseRule.create(noFixContext(context));
            return baseRulesWithoutFixCache;
        }
    },
});
function noFixContext(context) {
    const customContext = {
        report: (descriptor) => {
            context.report({
                ...descriptor,
                fix: undefined,
            });
        },
    };
    // we can't directly proxy `context` because its `report` property is non-configurable
    // and non-writable. So we proxy `customContext` and redirect all
    // property access to the original context except for `report`
    return new Proxy(customContext, {
        get(target, path, receiver) {
            if (path !== 'report') {
                return Reflect.get(context, path, receiver);
            }
            return Reflect.get(target, path, receiver);
        },
    });
}
function isTypeAnyOrIterableType(type, typeChecker) {
    if ((0, util_1.isTypeAnyType)(type)) {
        return true;
    }
    if (!type.isUnion()) {
        const iterator = tsutils.getWellKnownSymbolPropertyOfType(type, 'iterator', typeChecker);
        return iterator != null;
    }
    return type.types.every(t => isTypeAnyOrIterableType(t, typeChecker));
}
function isArrayLiteralIntegerIndexAccess(node) {
    if (node.type !== utils_1.AST_NODE_TYPES.MemberExpression) {
        return false;
    }
    if (node.property.type !== utils_1.AST_NODE_TYPES.Literal) {
        return false;
    }
    return Number.isInteger(node.property.value);
}


--------------------------------------------------------------------------------
FILE: prefer-enum-initializers.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageIds = 'defineInitializer' | 'defineInitializerSuggestion';
declare const _default: TSESLint.RuleModule<MessageIds, [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-enum-initializers.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-enum-initializers',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require each enum member value to be explicitly initialized',
        },
        hasSuggestions: true,
        messages: {
            defineInitializer: "The value of the member '{{ name }}' should be explicitly defined.",
            defineInitializerSuggestion: 'Can be fixed to {{ name }} = {{ suggested }}',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function TSEnumDeclaration(node) {
            const { members } = node.body;
            members.forEach((member, index) => {
                if (member.initializer == null) {
                    const name = context.sourceCode.getText(member);
                    context.report({
                        node: member,
                        messageId: 'defineInitializer',
                        data: {
                            name,
                        },
                        suggest: [
                            {
                                messageId: 'defineInitializerSuggestion',
                                data: { name, suggested: index },
                                fix: (fixer) => {
                                    return fixer.replaceText(member, `${name} = ${index}`);
                                },
                            },
                            {
                                messageId: 'defineInitializerSuggestion',
                                data: { name, suggested: index + 1 },
                                fix: (fixer) => {
                                    return fixer.replaceText(member, `${name} = ${index + 1}`);
                                },
                            },
                            {
                                messageId: 'defineInitializerSuggestion',
                                data: { name, suggested: `'${name}'` },
                                fix: (fixer) => {
                                    return fixer.replaceText(member, `${name} = '${name}'`);
                                },
                            },
                        ],
                    });
                }
            });
        }
        return {
            TSEnumDeclaration,
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-find.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"preferFind" | "preferFindSuggestion", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-find.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-find',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce the use of Array.prototype.find() over Array.prototype.filter() followed by [0] when looking for a single result',
            recommended: 'stylistic',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            preferFind: 'Prefer .find(...) instead of .filter(...)[0].',
            preferFindSuggestion: 'Use .find(...) instead of .filter(...)[0].',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const globalScope = context.sourceCode.getScope(context.sourceCode.ast);
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function parseArrayFilterExpressions(expression) {
            const node = (0, util_1.skipChainExpression)(expression);
            if (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {
                // Only the last expression in (a, b, [1, 2, 3].filter(condition))[0] matters
                const lastExpression = (0, util_1.nullThrows)(node.expressions.at(-1), 'Expected to have more than zero expressions in a sequence expression');
                return parseArrayFilterExpressions(lastExpression);
            }
            // This is the only reason we're returning a list rather than a single value.
            if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {
                // Both branches of the ternary _must_ return results.
                const consequentResult = parseArrayFilterExpressions(node.consequent);
                if (consequentResult.length === 0) {
                    return [];
                }
                const alternateResult = parseArrayFilterExpressions(node.alternate);
                if (alternateResult.length === 0) {
                    return [];
                }
                // Accumulate the results from both sides and pass up the chain.
                return [...consequentResult, ...alternateResult];
            }
            // Check if it looks like <<stuff>>(...), but not <<stuff>>?.(...)
            if (node.type === utils_1.AST_NODE_TYPES.CallExpression && !node.optional) {
                const callee = node.callee;
                // Check if it looks like <<stuff>>.filter(...) or <<stuff>>['filter'](...),
                // or the optional chaining variants.
                if (callee.type === utils_1.AST_NODE_TYPES.MemberExpression) {
                    const isBracketSyntaxForFilter = callee.computed;
                    if ((0, util_1.isStaticMemberAccessOfValue)(callee, context, 'filter')) {
                        const filterNode = callee.property;
                        const filteredObjectType = (0, util_1.getConstrainedTypeAtLocation)(services, callee.object);
                        // As long as the object is a (possibly nullable) array,
                        // this is an Array.prototype.filter expression.
                        if (isArrayish(filteredObjectType)) {
                            return [
                                {
                                    filterNode,
                                    isBracketSyntaxForFilter,
                                },
                            ];
                        }
                    }
                }
            }
            // not a filter expression.
            return [];
        }
        /**
         * Tells whether the type is a possibly nullable array/tuple or union thereof.
         */
        function isArrayish(type) {
            let isAtLeastOneArrayishComponent = false;
            for (const unionPart of tsutils.unionConstituents(type)) {
                if (tsutils.isIntrinsicNullType(unionPart) ||
                    tsutils.isIntrinsicUndefinedType(unionPart)) {
                    continue;
                }
                // apparently checker.isArrayType(T[] & S[]) => false.
                // so we need to check the intersection parts individually.
                const isArrayOrIntersectionThereof = tsutils
                    .intersectionConstituents(unionPart)
                    .every(intersectionPart => checker.isArrayType(intersectionPart) ||
                    checker.isTupleType(intersectionPart));
                if (!isArrayOrIntersectionThereof) {
                    // There is a non-array, non-nullish type component,
                    // so it's not an array.
                    return false;
                }
                isAtLeastOneArrayishComponent = true;
            }
            return isAtLeastOneArrayishComponent;
        }
        function getObjectIfArrayAtZeroExpression(node) {
            // .at() should take exactly one argument.
            if (node.arguments.length !== 1) {
                return undefined;
            }
            const callee = node.callee;
            if (callee.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                !callee.optional &&
                (0, util_1.isStaticMemberAccessOfValue)(callee, context, 'at')) {
                const atArgument = (0, util_1.getStaticValue)(node.arguments[0], globalScope);
                if (atArgument != null && isTreatedAsZeroByArrayAt(atArgument.value)) {
                    return callee.object;
                }
            }
            return undefined;
        }
        /**
         * Implements the algorithm for array indexing by `.at()` method.
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at#parameters
         */
        function isTreatedAsZeroByArrayAt(value) {
            // This would cause the number constructor coercion to throw. Other static
            // values are safe.
            if (typeof value === 'symbol') {
                return false;
            }
            const asNumber = Number(value);
            if (isNaN(asNumber)) {
                return true;
            }
            return Math.trunc(asNumber) === 0;
        }
        function isMemberAccessOfZero(node) {
            const property = (0, util_1.getStaticValue)(node.property, globalScope);
            // Check if it looks like <<stuff>>[0] or <<stuff>>['0'], but not <<stuff>>?.[0]
            return (!node.optional &&
                property != null &&
                isTreatedAsZeroByMemberAccess(property.value));
        }
        /**
         * Implements the algorithm for array indexing by member operator.
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array_indices
         */
        function isTreatedAsZeroByMemberAccess(value) {
            return String(value) === '0';
        }
        function generateFixToRemoveArrayElementAccess(fixer, arrayNode, wholeExpressionBeingFlagged) {
            const tokenToStartDeletingFrom = (0, util_1.nullThrows)(
            // The next `.` or `[` is what we're looking for.
            // think of (...).at(0) or (...)[0] or even (...)["at"](0).
            context.sourceCode.getTokenAfter(arrayNode, token => token.value === '.' || token.value === '['), 'Expected to find a member access token!');
            return fixer.removeRange([
                tokenToStartDeletingFrom.range[0],
                wholeExpressionBeingFlagged.range[1],
            ]);
        }
        function generateFixToReplaceFilterWithFind(fixer, filterExpression) {
            return fixer.replaceText(filterExpression.filterNode, filterExpression.isBracketSyntaxForFilter ? '"find"' : 'find');
        }
        return {
            // This query will be used to find things like `filteredResults.at(0)`.
            CallExpression(node) {
                const object = getObjectIfArrayAtZeroExpression(node);
                if (object) {
                    const filterExpressions = parseArrayFilterExpressions(object);
                    if (filterExpressions.length !== 0) {
                        context.report({
                            node,
                            messageId: 'preferFind',
                            suggest: [
                                {
                                    messageId: 'preferFindSuggestion',
                                    fix: (fixer) => {
                                        return [
                                            ...filterExpressions.map(filterExpression => generateFixToReplaceFilterWithFind(fixer, filterExpression)),
                                            // Get rid of the .at(0) or ['at'](0).
                                            generateFixToRemoveArrayElementAccess(fixer, object, node),
                                        ];
                                    },
                                },
                            ],
                        });
                    }
                }
            },
            // This query will be used to find things like `filteredResults[0]`.
            //
            // Note: we're always looking for array member access to be "computed",
            // i.e. `filteredResults[0]`, since `filteredResults.0` isn't a thing.
            'MemberExpression[computed=true]'(node) {
                if (isMemberAccessOfZero(node)) {
                    const object = node.object;
                    const filterExpressions = parseArrayFilterExpressions(object);
                    if (filterExpressions.length !== 0) {
                        context.report({
                            node,
                            messageId: 'preferFind',
                            suggest: [
                                {
                                    messageId: 'preferFindSuggestion',
                                    fix: (fixer) => {
                                        return [
                                            ...filterExpressions.map(filterExpression => generateFixToReplaceFilterWithFind(fixer, filterExpression)),
                                            // Get rid of the [0].
                                            generateFixToRemoveArrayElementAccess(fixer, object, node),
                                        ];
                                    },
                                },
                            ],
                        });
                    }
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-for-of.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"preferForOf", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-for-of.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-for-of',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce the use of `for-of` loop over the standard `for` loop where possible',
            recommended: 'stylistic',
        },
        messages: {
            preferForOf: 'Expected a `for-of` loop instead of a `for` loop with this simple iteration.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        function isSingleVariableDeclaration(node) {
            return (node?.type === utils_1.AST_NODE_TYPES.VariableDeclaration &&
                node.kind !== 'const' &&
                node.declarations.length === 1);
        }
        function isLiteral(node, value) {
            return node.type === utils_1.AST_NODE_TYPES.Literal && node.value === value;
        }
        function isZeroInitialized(node) {
            return node.init != null && isLiteral(node.init, 0);
        }
        function isMatchingIdentifier(node, name) {
            return node.type === utils_1.AST_NODE_TYPES.Identifier && node.name === name;
        }
        function isLessThanLengthExpression(node, name) {
            if (node?.type === utils_1.AST_NODE_TYPES.BinaryExpression &&
                node.operator === '<' &&
                isMatchingIdentifier(node.left, name) &&
                node.right.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                isMatchingIdentifier(node.right.property, 'length')) {
                return node.right.object;
            }
            return null;
        }
        function isIncrement(node, name) {
            if (!node) {
                return false;
            }
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.UpdateExpression:
                    // x++ or ++x
                    return (node.operator === '++' && isMatchingIdentifier(node.argument, name));
                case utils_1.AST_NODE_TYPES.AssignmentExpression:
                    if (isMatchingIdentifier(node.left, name)) {
                        if (node.operator === '+=') {
                            // x += 1
                            return isLiteral(node.right, 1);
                        }
                        if (node.operator === '=') {
                            // x = x + 1 or x = 1 + x
                            const expr = node.right;
                            return (expr.type === utils_1.AST_NODE_TYPES.BinaryExpression &&
                                expr.operator === '+' &&
                                ((isMatchingIdentifier(expr.left, name) &&
                                    isLiteral(expr.right, 1)) ||
                                    (isLiteral(expr.left, 1) &&
                                        isMatchingIdentifier(expr.right, name))));
                        }
                    }
            }
            return false;
        }
        function contains(outer, inner) {
            return (outer.range[0] <= inner.range[0] && outer.range[1] >= inner.range[1]);
        }
        function isIndexOnlyUsedWithArray(body, indexVar, arrayExpression) {
            const arrayText = context.sourceCode.getText(arrayExpression);
            return indexVar.references.every(reference => {
                const id = reference.identifier;
                const node = id.parent;
                return (!contains(body, id) ||
                    (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                        node.object.type !== utils_1.AST_NODE_TYPES.ThisExpression &&
                        node.property === id &&
                        context.sourceCode.getText(node.object) === arrayText &&
                        !(0, util_1.isAssignee)(node)));
            });
        }
        return {
            'ForStatement:exit'(node) {
                if (!isSingleVariableDeclaration(node.init)) {
                    return;
                }
                const declarator = node.init.declarations[0];
                if (!declarator ||
                    !isZeroInitialized(declarator) ||
                    declarator.id.type !== utils_1.AST_NODE_TYPES.Identifier) {
                    return;
                }
                const indexName = declarator.id.name;
                const arrayExpression = isLessThanLengthExpression(node.test, indexName);
                if (!arrayExpression) {
                    return;
                }
                const [indexVar] = context.sourceCode.getDeclaredVariables(node.init);
                if (isIncrement(node.update, indexName) &&
                    isIndexOnlyUsedWithArray(node.body, indexVar, arrayExpression)) {
                    context.report({
                        node,
                        messageId: 'preferForOf',
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-function-type.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export declare const phrases: {
    readonly TSInterfaceDeclaration: "Interface";
    readonly TSTypeLiteral: "Type literal";
};
declare const _default: TSESLint.RuleModule<"functionTypeOverCallableType" | "unexpectedThisOnFunctionOnlyInterface", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-function-type.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.phrases = void 0;
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.phrases = {
    [utils_1.AST_NODE_TYPES.TSInterfaceDeclaration]: 'Interface',
    [utils_1.AST_NODE_TYPES.TSTypeLiteral]: 'Type literal',
};
exports.default = (0, util_1.createRule)({
    name: 'prefer-function-type',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce using function types instead of interfaces with call signatures',
            recommended: 'stylistic',
        },
        fixable: 'code',
        messages: {
            functionTypeOverCallableType: '{{ literalOrInterface }} only has a call signature, you should use a function type instead.',
            unexpectedThisOnFunctionOnlyInterface: "`this` refers to the function type '{{ interfaceName }}', did you intend to use a generic `this` parameter like `<Self>(this: Self, ...) => Self` instead?",
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        /**
         * Checks if there the interface has exactly one supertype that isn't named 'Function'
         * @param node The node being checked
         */
        function hasOneSupertype(node) {
            if (node.extends.length === 0) {
                return false;
            }
            if (node.extends.length !== 1) {
                return true;
            }
            const expr = node.extends[0].expression;
            return (expr.type !== utils_1.AST_NODE_TYPES.Identifier || expr.name !== 'Function');
        }
        /**
         * @param parent The parent of the call signature causing the diagnostic
         */
        function shouldWrapSuggestion(parent) {
            if (!parent) {
                return false;
            }
            switch (parent.type) {
                case utils_1.AST_NODE_TYPES.TSUnionType:
                case utils_1.AST_NODE_TYPES.TSIntersectionType:
                case utils_1.AST_NODE_TYPES.TSArrayType:
                    return true;
                default:
                    return false;
            }
        }
        /**
         * @param member The TypeElement being checked
         * @param node The parent of member being checked
         */
        function checkMember(member, node, tsThisTypes = null) {
            if ((member.type === utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration ||
                member.type === utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration) &&
                member.returnType != null) {
                if (tsThisTypes?.length &&
                    node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) {
                    // the message can be confusing if we don't point directly to the `this` node instead of the whole member
                    // and in favour of generating at most one error we'll only report the first occurrence of `this` if there are multiple
                    context.report({
                        node: tsThisTypes[0],
                        messageId: 'unexpectedThisOnFunctionOnlyInterface',
                        data: {
                            interfaceName: node.id.name,
                        },
                    });
                    return;
                }
                const fixable = node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration;
                const fix = fixable
                    ? null
                    : (fixer) => {
                        const fixes = [];
                        const start = member.range[0];
                        // https://github.com/microsoft/TypeScript/pull/56908
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const colonPos = member.returnType.range[0] - start;
                        const text = context.sourceCode
                            .getText()
                            .slice(start, member.range[1]);
                        const comments = [
                            ...context.sourceCode.getCommentsBefore(member),
                            ...context.sourceCode.getCommentsAfter(member),
                        ];
                        let suggestion = `${text.slice(0, colonPos)} =>${text.slice(colonPos + 1)}`;
                        const lastChar = suggestion.endsWith(';') ? ';' : '';
                        if (lastChar) {
                            suggestion = suggestion.slice(0, -1);
                        }
                        if (shouldWrapSuggestion(node.parent)) {
                            suggestion = `(${suggestion})`;
                        }
                        if (node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) {
                            if (node.typeParameters != null) {
                                suggestion = `type ${context.sourceCode
                                    .getText()
                                    .slice(node.id.range[0], node.typeParameters.range[1])} = ${suggestion}${lastChar}`;
                            }
                            else {
                                suggestion = `type ${node.id.name} = ${suggestion}${lastChar}`;
                            }
                        }
                        const isParentExported = node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration;
                        if (node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration &&
                            isParentExported) {
                            const commentsText = comments
                                .map(({ type, value }) => type === utils_1.AST_TOKEN_TYPES.Line
                                ? `//${value}\n`
                                : `/*${value}*/\n`)
                                .join('');
                            // comments should move before export and not between export and interface declaration
                            fixes.push(fixer.insertTextBefore(node.parent, commentsText));
                        }
                        else {
                            comments.forEach(comment => {
                                let commentText = comment.type === utils_1.AST_TOKEN_TYPES.Line
                                    ? `//${comment.value}`
                                    : `/*${comment.value}*/`;
                                const isCommentOnTheSameLine = comment.loc.start.line === member.loc.start.line;
                                if (!isCommentOnTheSameLine) {
                                    commentText += '\n';
                                }
                                else {
                                    commentText += ' ';
                                }
                                suggestion = commentText + suggestion;
                            });
                        }
                        const fixStart = node.range[0];
                        fixes.push(fixer.replaceTextRange([fixStart, node.range[1]], suggestion));
                        return fixes;
                    };
                context.report({
                    node: member,
                    messageId: 'functionTypeOverCallableType',
                    data: {
                        literalOrInterface: exports.phrases[node.type],
                    },
                    fix,
                });
            }
        }
        let tsThisTypes = null;
        let literalNesting = 0;
        return {
            TSInterfaceDeclaration() {
                // when entering an interface reset the count of `this`s to empty.
                tsThisTypes = [];
            },
            'TSInterfaceDeclaration:exit'(node) {
                if (!hasOneSupertype(node) && node.body.body.length === 1) {
                    checkMember(node.body.body[0], node, tsThisTypes);
                }
                // on exit check member and reset the array to nothing.
                tsThisTypes = null;
            },
            'TSInterfaceDeclaration TSThisType'(node) {
                // inside an interface keep track of all ThisType references.
                // unless it's inside a nested type literal in which case it's invalid code anyway
                // we don't want to incorrectly say "it refers to name" while typescript says it's completely invalid.
                if (literalNesting === 0 && tsThisTypes != null) {
                    tsThisTypes.push(node);
                }
            },
            // keep track of nested literals to avoid complaining about invalid `this` uses
            'TSInterfaceDeclaration TSTypeLiteral'() {
                literalNesting += 1;
            },
            'TSInterfaceDeclaration TSTypeLiteral:exit'() {
                literalNesting -= 1;
            },
            'TSTypeLiteral[members.length = 1]'(node) {
                checkMember(node.members[0], node);
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-includes.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"preferIncludes" | "preferStringIncludes", [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-includes.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const regexpp_1 = require("@eslint-community/regexpp");
const utils_1 = require("@typescript-eslint/utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-includes',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce `includes` method over `indexOf` method',
            recommended: 'stylistic',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            preferIncludes: "Use 'includes()' method instead.",
            preferStringIncludes: 'Use `String#includes()` method with a string instead.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const globalScope = context.sourceCode.getScope(context.sourceCode.ast);
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function isNumber(node, value) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            return evaluated?.value === value;
        }
        function isPositiveCheck(node) {
            switch (node.operator) {
                case '!==':
                case '!=':
                case '>':
                    return isNumber(node.right, -1);
                case '>=':
                    return isNumber(node.right, 0);
                default:
                    return false;
            }
        }
        function isNegativeCheck(node) {
            switch (node.operator) {
                case '===':
                case '==':
                case '<=':
                    return isNumber(node.right, -1);
                case '<':
                    return isNumber(node.right, 0);
                default:
                    return false;
            }
        }
        function hasSameParameters(nodeA, nodeB) {
            if (!ts.isFunctionLike(nodeA) || !ts.isFunctionLike(nodeB)) {
                return false;
            }
            const paramsA = nodeA.parameters;
            const paramsB = nodeB.parameters;
            if (paramsA.length !== paramsB.length) {
                return false;
            }
            for (let i = 0; i < paramsA.length; ++i) {
                const paramA = paramsA[i];
                const paramB = paramsB[i];
                // Check name, type, and question token once.
                if (paramA.getText() !== paramB.getText()) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Parse a given node if it's a `RegExp` instance.
         * @param node The node to parse.
         */
        function parseRegExp(node) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            if (evaluated == null || !(evaluated.value instanceof RegExp)) {
                return null;
            }
            const { flags, pattern } = (0, regexpp_1.parseRegExpLiteral)(evaluated.value);
            if (pattern.alternatives.length !== 1 ||
                flags.ignoreCase ||
                flags.global) {
                return null;
            }
            // Check if it can determine a unique string.
            const chars = pattern.alternatives[0].elements;
            if (!chars.every(c => c.type === 'Character')) {
                return null;
            }
            // To string.
            return String.fromCodePoint(...chars.map(c => c.value));
        }
        function escapeString(str) {
            const EscapeMap = {
                '\0': '\\0',
                '\t': '\\t',
                '\n': '\\n',
                '\v': '\\v',
                '\f': '\\f',
                '\r': '\\r',
                "'": "\\'",
                '\\': '\\\\',
                // "\b" cause unexpected replacements
                // '\b': '\\b',
            };
            const replaceRegex = new RegExp(Object.values(EscapeMap).join('|'), 'g');
            return str.replaceAll(replaceRegex, char => EscapeMap[char]);
        }
        function checkArrayIndexOf(node, allowFixing) {
            if (!(0, util_1.isStaticMemberAccessOfValue)(node, context, 'indexOf')) {
                return;
            }
            // Check if the comparison is equivalent to `includes()`.
            const callNode = node.parent;
            const compareNode = (callNode.parent.type === utils_1.AST_NODE_TYPES.ChainExpression
                ? callNode.parent.parent
                : callNode.parent);
            const negative = isNegativeCheck(compareNode);
            if (!negative && !isPositiveCheck(compareNode)) {
                return;
            }
            // Get the symbol of `indexOf` method.
            const indexofMethodDeclarations = services
                .getSymbolAtLocation(node.property)
                ?.getDeclarations();
            if (indexofMethodDeclarations == null ||
                indexofMethodDeclarations.length === 0) {
                return;
            }
            // Check if every declaration of `indexOf` method has `includes` method
            // and the two methods have the same parameters.
            for (const instanceofMethodDecl of indexofMethodDeclarations) {
                const typeDecl = instanceofMethodDecl.parent;
                const type = checker.getTypeAtLocation(typeDecl);
                const includesMethodDecl = type
                    .getProperty('includes')
                    ?.getDeclarations();
                if (!includesMethodDecl?.some(includesMethodDecl => hasSameParameters(includesMethodDecl, instanceofMethodDecl))) {
                    return;
                }
            }
            // Report it.
            context.report({
                node: compareNode,
                messageId: 'preferIncludes',
                ...(allowFixing && {
                    *fix(fixer) {
                        if (negative) {
                            yield fixer.insertTextBefore(callNode, '!');
                        }
                        yield fixer.replaceText(node.property, 'includes');
                        yield fixer.removeRange([callNode.range[1], compareNode.range[1]]);
                    },
                }),
            });
        }
        return {
            // a.indexOf(b) !== 1
            'BinaryExpression > CallExpression.left > MemberExpression'(node) {
                checkArrayIndexOf(node, /* allowFixing */ true);
            },
            // a?.indexOf(b) !== 1
            'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression'(node) {
                checkArrayIndexOf(node, /* allowFixing */ false);
            },
            // /bar/.test(foo)
            'CallExpression[arguments.length=1] > MemberExpression.callee[property.name="test"][computed=false]'(node) {
                const callNode = node.parent;
                const text = parseRegExp(node.object);
                if (text == null) {
                    return;
                }
                //check the argument type of test methods
                const argument = callNode.arguments[0];
                const type = (0, util_1.getConstrainedTypeAtLocation)(services, argument);
                const includesMethodDecl = type
                    .getProperty('includes')
                    ?.getDeclarations();
                if (includesMethodDecl == null) {
                    return;
                }
                context.report({
                    node: callNode,
                    messageId: 'preferStringIncludes',
                    *fix(fixer) {
                        const argNode = callNode.arguments[0];
                        const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal &&
                            argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral &&
                            argNode.type !== utils_1.AST_NODE_TYPES.Identifier &&
                            argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression &&
                            argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;
                        yield fixer.removeRange([callNode.range[0], argNode.range[0]]);
                        yield fixer.removeRange([argNode.range[1], callNode.range[1]]);
                        if (needsParen) {
                            yield fixer.insertTextBefore(argNode, '(');
                            yield fixer.insertTextAfter(argNode, ')');
                        }
                        yield fixer.insertTextAfter(argNode, `${node.optional ? '?.' : '.'}includes('${escapeString(text)}')`);
                    },
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-literal-enum-member.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"notLiteral" | "notLiteralOrBitwiseExpression", [{
    allowBitwiseExpressions: boolean;
}], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-literal-enum-member.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-literal-enum-member',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require all enum members to be literal values',
            recommended: 'strict',
            requiresTypeChecking: false,
        },
        messages: {
            notLiteral: `Explicit enum value must only be a literal value (string or number).`,
            notLiteralOrBitwiseExpression: `Explicit enum value must only be a literal value (string or number) or a bitwise expression.`,
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowBitwiseExpressions: {
                        type: 'boolean',
                        description: 'Whether to allow using bitwise expressions in enum initializers.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowBitwiseExpressions: false,
        },
    ],
    create(context, [{ allowBitwiseExpressions }]) {
        function isIdentifierWithName(node, name) {
            return node.type === utils_1.AST_NODE_TYPES.Identifier && node.name === name;
        }
        function hasEnumMember(decl, name) {
            return decl.body.members.some(member => isIdentifierWithName(member.id, name) ||
                (member.id.type === utils_1.AST_NODE_TYPES.Literal &&
                    (0, util_1.getStaticStringValue)(member.id) === name));
        }
        function isSelfEnumMember(decl, node) {
            if (node.type === utils_1.AST_NODE_TYPES.Identifier) {
                return hasEnumMember(decl, node.name);
            }
            if (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                isIdentifierWithName(node.object, decl.id.name)) {
                if (node.property.type === utils_1.AST_NODE_TYPES.Identifier) {
                    return hasEnumMember(decl, node.property.name);
                }
                if (node.computed) {
                    const propertyName = (0, util_1.getStaticStringValue)(node.property);
                    if (propertyName) {
                        return hasEnumMember(decl, propertyName);
                    }
                }
            }
            return false;
        }
        return {
            TSEnumMember(node) {
                // If there is no initializer, then this node is just the name of the member, so ignore.
                if (node.initializer == null) {
                    return;
                }
                const declaration = node.parent.parent;
                function isAllowedInitializerExpressionRecursive(node, partOfBitwiseComputation) {
                    // You can only refer to an enum member if it's part of a bitwise computation.
                    // so C = B isn't allowed (special case), but C = A | B is.
                    if (partOfBitwiseComputation && isSelfEnumMember(declaration, node)) {
                        return true;
                    }
                    switch (node.type) {
                        // any old literal
                        case utils_1.AST_NODE_TYPES.Literal:
                            return true;
                        // TemplateLiteral without expressions
                        case utils_1.AST_NODE_TYPES.TemplateLiteral:
                            return node.expressions.length === 0;
                        case utils_1.AST_NODE_TYPES.UnaryExpression:
                            // +123, -123, etc.
                            if (['-', '+'].includes(node.operator)) {
                                return isAllowedInitializerExpressionRecursive(node.argument, partOfBitwiseComputation);
                            }
                            if (allowBitwiseExpressions) {
                                return (node.operator === '~' &&
                                    isAllowedInitializerExpressionRecursive(node.argument, true));
                            }
                            return false;
                        case utils_1.AST_NODE_TYPES.BinaryExpression:
                            if (allowBitwiseExpressions) {
                                return (['&', '^', '<<', '>>', '>>>', '|'].includes(node.operator) &&
                                    isAllowedInitializerExpressionRecursive(node.left, true) &&
                                    isAllowedInitializerExpressionRecursive(node.right, true));
                            }
                            return false;
                        default:
                            return false;
                    }
                }
                if (isAllowedInitializerExpressionRecursive(node.initializer, false)) {
                    return;
                }
                context.report({
                    node: node.id,
                    messageId: allowBitwiseExpressions
                        ? 'notLiteralOrBitwiseExpression'
                        : 'notLiteral',
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-namespace-keyword.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"useNamespace", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-namespace-keyword.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-namespace-keyword',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require using `namespace` keyword over `module` keyword to declare custom TypeScript modules',
            recommended: 'recommended',
        },
        fixable: 'code',
        messages: {
            useNamespace: "Use 'namespace' instead of 'module' to declare custom TypeScript modules.",
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        return {
            TSModuleDeclaration(node) {
                // Do nothing if the name is a string.
                if (node.id.type === utils_1.AST_NODE_TYPES.Literal) {
                    return;
                }
                // Get tokens of the declaration header.
                const moduleType = context.sourceCode.getTokenBefore(node.id);
                if (moduleType?.type === utils_1.AST_TOKEN_TYPES.Identifier &&
                    moduleType.value === 'module') {
                    context.report({
                        node,
                        messageId: 'useNamespace',
                        fix(fixer) {
                            return fixer.replaceText(moduleType, 'namespace');
                        },
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-nullish-coalescing.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing?: boolean;
        ignoreBooleanCoercion?: boolean;
        ignoreConditionalTests?: boolean;
        ignoreIfStatements?: boolean;
        ignoreMixedLogicalExpressions?: boolean;
        ignorePrimitives?: true | {
            bigint?: boolean;
            boolean?: boolean;
            number?: boolean;
            string?: boolean;
        };
        ignoreTernaryTests?: boolean;
    }
];
export type MessageIds = 'noStrictNullCheck' | 'preferNullishOverAssignment' | 'preferNullishOverOr' | 'preferNullishOverTernary' | 'suggestNullish';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-nullish-coalescing.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const getWrappedCode_1 = require("../util/getWrappedCode");
const isMemberAccessLike = (0, util_1.isNodeOfTypes)([
    utils_1.AST_NODE_TYPES.ChainExpression,
    utils_1.AST_NODE_TYPES.Identifier,
    utils_1.AST_NODE_TYPES.MemberExpression,
]);
const isNullLiteralOrUndefinedIdentifier = (node) => (0, util_1.isNullLiteral)(node) || (0, util_1.isUndefinedIdentifier)(node);
const isNodeNullishComparison = (node) => isNullLiteralOrUndefinedIdentifier(node.left) &&
    isNullLiteralOrUndefinedIdentifier(node.right);
exports.default = (0, util_1.createRule)({
    name: 'prefer-nullish-coalescing',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce using the nullish coalescing operator instead of logical assignments or chaining',
            recommended: 'stylistic',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',
            preferNullishOverAssignment: 'Prefer using nullish coalescing operator (`??{{ equals }}`) instead of an assignment expression, as it is simpler to read.',
            preferNullishOverOr: 'Prefer using nullish coalescing operator (`??{{ equals }}`) instead of a logical {{ description }} (`||{{ equals }}`), as it is a safer operator.',
            preferNullishOverTernary: 'Prefer using nullish coalescing operator (`??{{ equals }}`) instead of a ternary expression, as it is simpler to read.',
            suggestNullish: 'Fix to nullish coalescing operator (`??{{ equals }}`).',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {
                        type: 'boolean',
                        description: 'Unless this is set to `true`, the rule will error on every file whose `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or `strict`) set to `true`.',
                    },
                    ignoreBooleanCoercion: {
                        type: 'boolean',
                        description: 'Whether to ignore arguments to the `Boolean` constructor',
                    },
                    ignoreConditionalTests: {
                        type: 'boolean',
                        description: 'Whether to ignore cases that are located within a conditional test.',
                    },
                    ignoreIfStatements: {
                        type: 'boolean',
                        description: 'Whether to ignore any if statements that could be simplified by using the nullish coalescing operator.',
                    },
                    ignoreMixedLogicalExpressions: {
                        type: 'boolean',
                        description: 'Whether to ignore any logical or expressions that are part of a mixed logical expression (with `&&`).',
                    },
                    ignorePrimitives: {
                        description: 'Whether to ignore all (`true`) or some (an object with properties) primitive types.',
                        oneOf: [
                            {
                                type: 'object',
                                additionalProperties: false,
                                description: 'Which primitives types may be ignored.',
                                properties: {
                                    bigint: {
                                        type: 'boolean',
                                        description: 'Ignore bigint primitive types.',
                                    },
                                    boolean: {
                                        type: 'boolean',
                                        description: 'Ignore boolean primitive types.',
                                    },
                                    number: {
                                        type: 'boolean',
                                        description: 'Ignore number primitive types.',
                                    },
                                    string: {
                                        type: 'boolean',
                                        description: 'Ignore string primitive types.',
                                    },
                                },
                            },
                            {
                                type: 'boolean',
                                description: 'Ignore all primitive types.',
                                enum: [true],
                            },
                        ],
                    },
                    ignoreTernaryTests: {
                        type: 'boolean',
                        description: 'Whether to ignore any ternary expressions that could be simplified by using the nullish coalescing operator.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,
            ignoreBooleanCoercion: false,
            ignoreConditionalTests: true,
            ignoreIfStatements: false,
            ignoreMixedLogicalExpressions: false,
            ignorePrimitives: {
                bigint: false,
                boolean: false,
                number: false,
                string: false,
            },
            ignoreTernaryTests: false,
        },
    ],
    create(context, [{ allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing, ignoreBooleanCoercion, ignoreConditionalTests, ignoreIfStatements, ignoreMixedLogicalExpressions, ignorePrimitives, ignoreTernaryTests, },]) {
        const parserServices = (0, util_1.getParserServices)(context);
        const compilerOptions = parserServices.program.getCompilerOptions();
        const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');
        if (!isStrictNullChecks &&
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {
            context.report({
                loc: {
                    start: { column: 0, line: 0 },
                    end: { column: 0, line: 0 },
                },
                messageId: 'noStrictNullCheck',
            });
        }
        /**
         * Checks whether a type tested for truthiness is eligible for conversion to
         * a nullishness check, taking into account the rule's configuration.
         */
        function isTypeEligibleForPreferNullish(type) {
            if (!(0, util_1.isNullableType)(type)) {
                return false;
            }
            const ignorableFlags = [
                /* eslint-disable @typescript-eslint/no-non-null-assertion */
                (ignorePrimitives === true || ignorePrimitives.bigint) &&
                    ts.TypeFlags.BigIntLike,
                (ignorePrimitives === true || ignorePrimitives.boolean) &&
                    ts.TypeFlags.BooleanLike,
                (ignorePrimitives === true || ignorePrimitives.number) &&
                    ts.TypeFlags.NumberLike,
                (ignorePrimitives === true || ignorePrimitives.string) &&
                    ts.TypeFlags.StringLike,
                /* eslint-enable @typescript-eslint/no-non-null-assertion */
            ]
                .filter((flag) => typeof flag === 'number')
                .reduce((previous, flag) => previous | flag, 0);
            if (ignorableFlags === 0) {
                // any types are eligible for conversion.
                return true;
            }
            // if the type is `any` or `unknown` we can't make any assumptions
            // about the value, so it could be any primitive, even though the flags
            // won't be set.
            //
            // technically, this is true of `void` as well, however, it's a TS error
            // to test `void` for truthiness, so we don't need to bother checking for
            // it in valid code.
            if (tsutils.isTypeFlagSet(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
                return false;
            }
            if (tsutils
                .typeConstituents(type)
                .some(t => tsutils
                .intersectionConstituents(t)
                .some(t => tsutils.isTypeFlagSet(t, ignorableFlags)))) {
                return false;
            }
            return true;
        }
        /**
         * Determines whether a control flow construct that uses the truthiness of
         * a test expression is eligible for conversion to the nullish coalescing
         * operator, taking into account (both dependent on the rule's configuration):
         * 1. Whether the construct is in a permitted syntactic context
         * 2. Whether the type of the test expression is deemed eligible for
         *    conversion
         *
         * @param node The overall node to be converted (e.g. `a || b` or `a ? a : b`)
         * @param testNode The node being tested (i.e. `a`)
         */
        function isTruthinessCheckEligibleForPreferNullish({ node, testNode, }) {
            const testType = parserServices.getTypeAtLocation(testNode);
            if (!isTypeEligibleForPreferNullish(testType)) {
                return false;
            }
            if (ignoreConditionalTests === true && isConditionalTest(node)) {
                return false;
            }
            if (ignoreBooleanCoercion === true &&
                isBooleanConstructorContext(node, context) &&
                !(node.type === utils_1.AST_NODE_TYPES.ConditionalExpression &&
                    node.parent.type === utils_1.AST_NODE_TYPES.CallExpression)) {
                return false;
            }
            return true;
        }
        function checkAndFixWithPreferNullishOverOr(node, description, equals) {
            if (!isTruthinessCheckEligibleForPreferNullish({
                node,
                testNode: node.left,
            })) {
                return;
            }
            if (ignoreMixedLogicalExpressions === true &&
                isMixedLogicalExpression(node)) {
                return;
            }
            const barBarOperator = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.left, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator &&
                token.value === node.operator), util_1.NullThrowsReasons.MissingToken('operator', node.type));
            function* fix(fixer) {
                if ((0, util_1.isLogicalOrOperator)(node.parent)) {
                    // '&&' and '??' operations cannot be mixed without parentheses (e.g. a && b ?? c)
                    if (node.left.type === utils_1.AST_NODE_TYPES.LogicalExpression &&
                        !(0, util_1.isLogicalOrOperator)(node.left.left)) {
                        yield fixer.insertTextBefore(node.left.right, '(');
                    }
                    else {
                        yield fixer.insertTextBefore(node.left, '(');
                    }
                    yield fixer.insertTextAfter(node.right, ')');
                }
                yield fixer.replaceText(barBarOperator, node.operator.replace('||', '??'));
            }
            context.report({
                node: barBarOperator,
                messageId: 'preferNullishOverOr',
                data: { description, equals },
                suggest: [
                    {
                        messageId: 'suggestNullish',
                        data: { equals },
                        fix,
                    },
                ],
            });
        }
        function getNullishCoalescingParams(node, nonNullishNode, nodesInsideTestExpression, operator) {
            let nullishCoalescingLeftNode;
            let hasTruthinessCheck = false;
            let hasNullCheckWithoutTruthinessCheck = false;
            let hasUndefinedCheckWithoutTruthinessCheck = false;
            if (!nodesInsideTestExpression.length) {
                hasTruthinessCheck = true;
                nullishCoalescingLeftNode =
                    node.test.type === utils_1.AST_NODE_TYPES.UnaryExpression
                        ? node.test.argument
                        : node.test;
                if (!areNodesSimilarMemberAccess(nullishCoalescingLeftNode, nonNullishNode)) {
                    return { isFixable: false };
                }
            }
            else {
                // we check that the test only contains null, undefined and the identifier
                for (const testNode of nodesInsideTestExpression) {
                    if ((0, util_1.isNullLiteral)(testNode)) {
                        hasNullCheckWithoutTruthinessCheck = true;
                    }
                    else if ((0, util_1.isUndefinedIdentifier)(testNode)) {
                        hasUndefinedCheckWithoutTruthinessCheck = true;
                    }
                    else if (areNodesSimilarMemberAccess(testNode, nonNullishNode)) {
                        // Only consider the first expression in a multi-part nullish check,
                        // as subsequent expressions might not require all the optional chaining operators.
                        // For example: a?.b?.c !== undefined && a.b.c !== null ? a.b.c : 'foo';
                        // This works because `node.test` is always evaluated first in the loop
                        // and has the same or more necessary optional chaining operators
                        // than `node.alternate` or `node.consequent`.
                        nullishCoalescingLeftNode ??= testNode;
                    }
                    else {
                        return { isFixable: false };
                    }
                }
            }
            if (!nullishCoalescingLeftNode) {
                return { isFixable: false };
            }
            const isFixable = (() => {
                if (hasTruthinessCheck) {
                    return isTruthinessCheckEligibleForPreferNullish({
                        node,
                        testNode: nullishCoalescingLeftNode,
                    });
                }
                // it is fixable if we check for both null and undefined, or not if neither
                if (hasUndefinedCheckWithoutTruthinessCheck ===
                    hasNullCheckWithoutTruthinessCheck) {
                    return hasUndefinedCheckWithoutTruthinessCheck;
                }
                // it is fixable if we loosely check for either null or undefined
                if (['==', '!='].includes(operator)) {
                    return true;
                }
                const type = parserServices.getTypeAtLocation(nullishCoalescingLeftNode);
                const flags = (0, util_1.getTypeFlags)(type);
                if (flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
                    return false;
                }
                const hasNullType = (flags & ts.TypeFlags.Null) !== 0;
                // it is fixable if we check for undefined and the type is not nullable
                if (hasUndefinedCheckWithoutTruthinessCheck && !hasNullType) {
                    return true;
                }
                const hasUndefinedType = (flags & ts.TypeFlags.Undefined) !== 0;
                // it is fixable if we check for null and the type can't be undefined
                return hasNullCheckWithoutTruthinessCheck && !hasUndefinedType;
            })();
            return isFixable
                ? { isFixable: true, nullishCoalescingLeftNode }
                : { isFixable: false };
        }
        return {
            'AssignmentExpression[operator = "||="]'(node) {
                checkAndFixWithPreferNullishOverOr(node, 'assignment', '=');
            },
            ConditionalExpression(node) {
                if (ignoreTernaryTests) {
                    return;
                }
                const { nodesInsideTestExpression, operator } = getOperatorAndNodesInsideTestExpression(node);
                if (operator == null) {
                    return;
                }
                const { nonNullishBranch, nullishBranch } = getBranchNodes(node, operator);
                const nullishCoalescingParams = getNullishCoalescingParams(node, nonNullishBranch, nodesInsideTestExpression, operator);
                if (nullishCoalescingParams.isFixable) {
                    context.report({
                        node,
                        messageId: 'preferNullishOverTernary',
                        // TODO: also account for = in the ternary clause
                        data: { equals: '' },
                        suggest: [
                            {
                                messageId: 'suggestNullish',
                                data: { equals: '' },
                                fix(fixer) {
                                    const nullishBranchText = (0, util_1.getTextWithParentheses)(context.sourceCode, nullishBranch);
                                    const rightOperandReplacement = (0, util_1.isParenthesized)(nullishBranch, context.sourceCode)
                                        ? nullishBranchText
                                        : (0, getWrappedCode_1.getWrappedCode)(nullishBranchText, (0, util_1.getOperatorPrecedenceForNode)(nullishBranch), util_1.OperatorPrecedence.Coalesce);
                                    return fixer.replaceText(node, `${(0, util_1.getTextWithParentheses)(context.sourceCode, nullishCoalescingParams.nullishCoalescingLeftNode)} ?? ${rightOperandReplacement}`);
                                },
                            },
                        ],
                    });
                }
            },
            IfStatement(node) {
                if (ignoreIfStatements || node.alternate != null) {
                    return;
                }
                let assignmentExpression;
                if (node.consequent.type === utils_1.AST_NODE_TYPES.BlockStatement &&
                    node.consequent.body.length === 1 &&
                    node.consequent.body[0].type === utils_1.AST_NODE_TYPES.ExpressionStatement) {
                    assignmentExpression = node.consequent.body[0].expression;
                }
                else if (node.consequent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {
                    assignmentExpression = node.consequent.expression;
                }
                if (assignmentExpression?.type !== utils_1.AST_NODE_TYPES.AssignmentExpression ||
                    !isMemberAccessLike(assignmentExpression.left)) {
                    return;
                }
                const nullishCoalescingLeftNode = assignmentExpression.left;
                const nullishCoalescingRightNode = assignmentExpression.right;
                const { nodesInsideTestExpression, operator } = getOperatorAndNodesInsideTestExpression(node);
                if (operator == null || !['!', '==', '==='].includes(operator)) {
                    return;
                }
                const nullishCoalescingParams = getNullishCoalescingParams(node, nullishCoalescingLeftNode, nodesInsideTestExpression, operator);
                if (nullishCoalescingParams.isFixable) {
                    // Handle comments
                    const isConsequentNodeBlockStatement = node.consequent.type === utils_1.AST_NODE_TYPES.BlockStatement;
                    const commentsBefore = formatComments(context.sourceCode.getCommentsBefore(assignmentExpression), isConsequentNodeBlockStatement ? '\n' : ' ');
                    const commentsAfter = isConsequentNodeBlockStatement
                        ? formatComments(context.sourceCode.getCommentsAfter(assignmentExpression.parent), '\n')
                        : '';
                    context.report({
                        node,
                        messageId: 'preferNullishOverAssignment',
                        data: { equals: '=' },
                        suggest: [
                            {
                                messageId: 'suggestNullish',
                                data: { equals: '=' },
                                fix(fixer) {
                                    const fixes = [];
                                    if (commentsBefore) {
                                        fixes.push(fixer.insertTextBefore(node, commentsBefore));
                                    }
                                    fixes.push(fixer.replaceText(node, `${(0, util_1.getTextWithParentheses)(context.sourceCode, nullishCoalescingLeftNode)} ??= ${(0, util_1.getTextWithParentheses)(context.sourceCode, nullishCoalescingRightNode)};`));
                                    if (commentsAfter) {
                                        fixes.push(fixer.insertTextAfter(node, ` ${commentsAfter.slice(0, -1)}`));
                                    }
                                    return fixes;
                                },
                            },
                        ],
                    });
                }
            },
            'LogicalExpression[operator = "||"]'(node) {
                checkAndFixWithPreferNullishOverOr(node, 'or', '');
            },
        };
    },
});
function isConditionalTest(node) {
    const parent = node.parent;
    if (parent == null) {
        return false;
    }
    if (parent.type === utils_1.AST_NODE_TYPES.LogicalExpression) {
        return isConditionalTest(parent);
    }
    if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression &&
        (parent.consequent === node || parent.alternate === node)) {
        return isConditionalTest(parent);
    }
    if (parent.type === utils_1.AST_NODE_TYPES.SequenceExpression &&
        parent.expressions.at(-1) === node) {
        return isConditionalTest(parent);
    }
    if (parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
        parent.operator === '!') {
        return isConditionalTest(parent);
    }
    if ((parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression ||
        parent.type === utils_1.AST_NODE_TYPES.DoWhileStatement ||
        parent.type === utils_1.AST_NODE_TYPES.IfStatement ||
        parent.type === utils_1.AST_NODE_TYPES.ForStatement ||
        parent.type === utils_1.AST_NODE_TYPES.WhileStatement) &&
        parent.test === node) {
        return true;
    }
    return false;
}
function isBooleanConstructorContext(node, context) {
    const parent = node.parent;
    if (parent == null) {
        return false;
    }
    if (parent.type === utils_1.AST_NODE_TYPES.LogicalExpression) {
        return isBooleanConstructorContext(parent, context);
    }
    if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression &&
        (parent.consequent === node || parent.alternate === node)) {
        return isBooleanConstructorContext(parent, context);
    }
    if (parent.type === utils_1.AST_NODE_TYPES.SequenceExpression &&
        parent.expressions.at(-1) === node) {
        return isBooleanConstructorContext(parent, context);
    }
    return isBuiltInBooleanCall(parent, context);
}
function isBuiltInBooleanCall(node, context) {
    if (node.type === utils_1.AST_NODE_TYPES.CallExpression &&
        node.callee.type === utils_1.AST_NODE_TYPES.Identifier &&
        // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
        node.callee.name === 'Boolean' &&
        node.arguments[0]) {
        const scope = context.sourceCode.getScope(node);
        const variable = scope.set.get(utils_1.AST_TOKEN_TYPES.Boolean);
        return variable == null || variable.defs.length === 0;
    }
    return false;
}
function isMixedLogicalExpression(node) {
    const seen = new Set();
    const queue = [node.parent, node.left, node.right];
    for (const current of queue) {
        if (seen.has(current)) {
            continue;
        }
        seen.add(current);
        if (current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {
            if (current.operator === '&&') {
                return true;
            }
            if (['||', '||='].includes(current.operator)) {
                // check the pieces of the node to catch cases like `a || b || c && d`
                queue.push(current.parent, current.left, current.right);
            }
        }
    }
    return false;
}
/**
 * Checks if two TSESTree nodes have the same member access sequence,
 * regardless of optional chaining differences.
 *
 * Note: This does not imply that the nodes are runtime-equivalent.
 *
 * Example: `a.b.c`, `a?.b.c`, `a.b?.c`, `(a?.b).c`, `(a.b)?.c` are considered similar.
 *
 * @param a First TSESTree node.
 * @param b Second TSESTree node.
 * @returns `true` if the nodes access members in the same order; otherwise, `false`.
 */
function areNodesSimilarMemberAccess(a, b) {
    if (a.type === utils_1.AST_NODE_TYPES.MemberExpression &&
        b.type === utils_1.AST_NODE_TYPES.MemberExpression) {
        if (!areNodesSimilarMemberAccess(a.object, b.object)) {
            return false;
        }
        if (a.computed === b.computed) {
            return (0, util_1.isNodeEqual)(a.property, b.property);
        }
        if (a.property.type === utils_1.AST_NODE_TYPES.Literal &&
            b.property.type === utils_1.AST_NODE_TYPES.Identifier) {
            return a.property.value === b.property.name;
        }
        if (a.property.type === utils_1.AST_NODE_TYPES.Identifier &&
            b.property.type === utils_1.AST_NODE_TYPES.Literal) {
            return a.property.name === b.property.value;
        }
        return false;
    }
    if (a.type === utils_1.AST_NODE_TYPES.ChainExpression ||
        b.type === utils_1.AST_NODE_TYPES.ChainExpression) {
        return areNodesSimilarMemberAccess((0, util_1.skipChainExpression)(a), (0, util_1.skipChainExpression)(b));
    }
    return (0, util_1.isNodeEqual)(a, b);
}
/**
 * Returns the branch nodes of a conditional expression:
 * - the "nonNullish branch" is the branch when test node is not nullish
 * - the "nullish branch" is the branch when test node is nullish
 */
function getBranchNodes(node, operator) {
    if (['', '!=', '!=='].includes(operator)) {
        return { nonNullishBranch: node.consequent, nullishBranch: node.alternate };
    }
    return { nonNullishBranch: node.alternate, nullishBranch: node.consequent };
}
function getOperatorAndNodesInsideTestExpression(node) {
    let operator = null;
    let nodesInsideTestExpression = [];
    if (isMemberAccessLike(node.test) ||
        node.test.type === utils_1.AST_NODE_TYPES.UnaryExpression) {
        operator = getNonBinaryNodeOperator(node.test);
    }
    else if (node.test.type === utils_1.AST_NODE_TYPES.BinaryExpression) {
        nodesInsideTestExpression = [node.test.left, node.test.right];
        if (node.test.operator === '==' ||
            node.test.operator === '!=' ||
            node.test.operator === '===' ||
            node.test.operator === '!==') {
            operator = node.test.operator;
        }
    }
    else if (node.test.type === utils_1.AST_NODE_TYPES.LogicalExpression &&
        node.test.left.type === utils_1.AST_NODE_TYPES.BinaryExpression &&
        node.test.right.type === utils_1.AST_NODE_TYPES.BinaryExpression) {
        if (isNodeNullishComparison(node.test.left) ||
            isNodeNullishComparison(node.test.right)) {
            return { nodesInsideTestExpression, operator };
        }
        nodesInsideTestExpression = [
            node.test.left.left,
            node.test.left.right,
            node.test.right.left,
            node.test.right.right,
        ];
        if (['||', '||='].includes(node.test.operator)) {
            if (node.test.left.operator === '===' &&
                node.test.right.operator === '===') {
                operator = '===';
            }
            else if (((node.test.left.operator === '===' ||
                node.test.right.operator === '===') &&
                (node.test.left.operator === '==' ||
                    node.test.right.operator === '==')) ||
                (node.test.left.operator === '==' && node.test.right.operator === '==')) {
                operator = '==';
            }
        }
        else if (node.test.operator === '&&') {
            if (node.test.left.operator === '!==' &&
                node.test.right.operator === '!==') {
                operator = '!==';
            }
            else if (((node.test.left.operator === '!==' ||
                node.test.right.operator === '!==') &&
                (node.test.left.operator === '!=' ||
                    node.test.right.operator === '!=')) ||
                (node.test.left.operator === '!=' && node.test.right.operator === '!=')) {
                operator = '!=';
            }
        }
    }
    return { nodesInsideTestExpression, operator };
}
function getNonBinaryNodeOperator(node) {
    if (node.type !== utils_1.AST_NODE_TYPES.UnaryExpression) {
        return '';
    }
    if (isMemberAccessLike(node.argument) && node.operator === '!') {
        return '!';
    }
    return null;
}
function formatComments(comments, separator) {
    return comments
        .map(({ type, value }) => type === utils_1.AST_TOKEN_TYPES.Line
        ? `//${value}${separator}`
        : `/*${value}*/${separator}`)
        .join('');
}


--------------------------------------------------------------------------------
FILE: prefer-optional-chain.d.ts
--------------------------------------------------------------------------------

import type { PreferOptionalChainMessageIds, PreferOptionalChainOptions } from './prefer-optional-chain-utils/PreferOptionalChainOptions';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<PreferOptionalChainMessageIds, [PreferOptionalChainOptions], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-optional-chain.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const analyzeChain_1 = require("./prefer-optional-chain-utils/analyzeChain");
const checkNullishAndReport_1 = require("./prefer-optional-chain-utils/checkNullishAndReport");
const gatherLogicalOperands_1 = require("./prefer-optional-chain-utils/gatherLogicalOperands");
exports.default = (0, util_1.createRule)({
    name: 'prefer-optional-chain',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce using concise optional chain expressions instead of chained logical ands, negated logical ors, or empty objects',
            recommended: 'stylistic',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            optionalChainSuggest: 'Change to an optional chain.',
            preferOptionalChain: "Prefer using an optional chain expression instead, as it's more concise and easier to read.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing: {
                        type: 'boolean',
                        description: 'Allow autofixers that will change the return type of the expression. This option is considered unsafe as it may break the build.',
                    },
                    checkAny: {
                        type: 'boolean',
                        description: 'Check operands that are typed as `any` when inspecting "loose boolean" operands.',
                    },
                    checkBigInt: {
                        type: 'boolean',
                        description: 'Check operands that are typed as `bigint` when inspecting "loose boolean" operands.',
                    },
                    checkBoolean: {
                        type: 'boolean',
                        description: 'Check operands that are typed as `boolean` when inspecting "loose boolean" operands.',
                    },
                    checkNumber: {
                        type: 'boolean',
                        description: 'Check operands that are typed as `number` when inspecting "loose boolean" operands.',
                    },
                    checkString: {
                        type: 'boolean',
                        description: 'Check operands that are typed as `string` when inspecting "loose boolean" operands.',
                    },
                    checkUnknown: {
                        type: 'boolean',
                        description: 'Check operands that are typed as `unknown` when inspecting "loose boolean" operands.',
                    },
                    requireNullish: {
                        type: 'boolean',
                        description: 'Skip operands that are not typed with `null` and/or `undefined` when inspecting "loose boolean" operands.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing: false,
            checkAny: true,
            checkBigInt: true,
            checkBoolean: true,
            checkNumber: true,
            checkString: true,
            checkUnknown: true,
            requireNullish: false,
        },
    ],
    create(context, [options]) {
        const parserServices = (0, util_1.getParserServices)(context);
        const seenLogicals = new Set();
        return {
            'LogicalExpression[operator!="??"]'(node) {
                if (seenLogicals.has(node)) {
                    return;
                }
                const { newlySeenLogicals, operands } = (0, gatherLogicalOperands_1.gatherLogicalOperands)(node, parserServices, context.sourceCode, options);
                for (const logical of newlySeenLogicals) {
                    seenLogicals.add(logical);
                }
                let currentChain = [];
                for (const operand of operands) {
                    if (operand.type === gatherLogicalOperands_1.OperandValidity.Invalid) {
                        (0, analyzeChain_1.analyzeChain)(context, parserServices, options, node, node.operator, currentChain);
                        currentChain = [];
                    }
                    else if (operand.type === gatherLogicalOperands_1.OperandValidity.Last) {
                        (0, analyzeChain_1.analyzeChain)(context, parserServices, options, node, node.operator, currentChain, operand);
                        currentChain = [];
                    }
                    else {
                        currentChain.push(operand);
                    }
                }
                // make sure to check whatever's left
                if (currentChain.length > 0) {
                    (0, analyzeChain_1.analyzeChain)(context, parserServices, options, node, node.operator, currentChain);
                }
            },
            // specific handling for `(foo ?? {}).bar` / `(foo || {}).bar`
            'LogicalExpression[operator="||"], LogicalExpression[operator="??"]'(node) {
                const leftNode = node.left;
                const rightNode = node.right;
                const parentNode = node.parent;
                const isRightNodeAnEmptyObjectLiteral = rightNode.type === utils_1.AST_NODE_TYPES.ObjectExpression &&
                    rightNode.properties.length === 0;
                if (!isRightNodeAnEmptyObjectLiteral ||
                    parentNode.type !== utils_1.AST_NODE_TYPES.MemberExpression ||
                    parentNode.optional) {
                    return;
                }
                seenLogicals.add(node);
                function isLeftSideLowerPrecedence() {
                    const logicalTsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
                    const leftTsNode = parserServices.esTreeNodeToTSNodeMap.get(leftNode);
                    const leftPrecedence = (0, util_1.getOperatorPrecedence)(leftTsNode.kind, logicalTsNode.operatorToken.kind);
                    return leftPrecedence < util_1.OperatorPrecedence.LeftHandSide;
                }
                (0, checkNullishAndReport_1.checkNullishAndReport)(context, parserServices, options, [leftNode], {
                    node: parentNode,
                    messageId: 'preferOptionalChain',
                    suggest: [
                        {
                            messageId: 'optionalChainSuggest',
                            fix: (fixer) => {
                                const leftNodeText = context.sourceCode.getText(leftNode);
                                // Any node that is made of an operator with higher or equal precedence,
                                const maybeWrappedLeftNode = isLeftSideLowerPrecedence()
                                    ? `(${leftNodeText})`
                                    : leftNodeText;
                                const propertyToBeOptionalText = context.sourceCode.getText(parentNode.property);
                                const maybeWrappedProperty = parentNode.computed
                                    ? `[${propertyToBeOptionalText}]`
                                    : propertyToBeOptionalText;
                                return fixer.replaceTextRange(parentNode.range, `${maybeWrappedLeftNode}?.${maybeWrappedProperty}`);
                            },
                        },
                    ],
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-promise-reject-errors.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'rejectAnError';
export type Options = [
    {
        allowEmptyReject?: boolean;
        allowThrowingAny?: boolean;
        allowThrowingUnknown?: boolean;
    }
];
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"rejectAnError", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-promise-reject-errors.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-promise-reject-errors',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require using Error objects as Promise rejection reasons',
            extendsBaseRule: true,
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            rejectAnError: 'Expected the Promise rejection reason to be an Error.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowEmptyReject: {
                        type: 'boolean',
                        description: 'Whether to allow calls to `Promise.reject()` with no arguments.',
                    },
                    allowThrowingAny: {
                        type: 'boolean',
                        description: 'Whether to always allow throwing values typed as `any`.',
                    },
                    allowThrowingUnknown: {
                        type: 'boolean',
                        description: 'Whether to always allow throwing values typed as `unknown`.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowEmptyReject: false,
            allowThrowingAny: false,
            allowThrowingUnknown: false,
        },
    ],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        function checkRejectCall(callExpression) {
            const argument = callExpression.arguments.at(0);
            if (argument) {
                const type = services.getTypeAtLocation(argument);
                if (options.allowThrowingAny && (0, util_1.isTypeAnyType)(type)) {
                    return;
                }
                if (options.allowThrowingUnknown && (0, util_1.isTypeUnknownType)(type)) {
                    return;
                }
                if ((0, util_1.isErrorLike)(services.program, type) ||
                    (0, util_1.isReadonlyErrorLike)(services.program, type)) {
                    return;
                }
            }
            else if (options.allowEmptyReject) {
                return;
            }
            context.report({
                node: callExpression,
                messageId: 'rejectAnError',
            });
        }
        function typeAtLocationIsLikePromise(node) {
            const type = services.getTypeAtLocation(node);
            return ((0, util_1.isPromiseConstructorLike)(services.program, type) ||
                (0, util_1.isPromiseLike)(services.program, type));
        }
        return {
            CallExpression(node) {
                const callee = (0, util_1.skipChainExpression)(node.callee);
                if (callee.type !== utils_1.AST_NODE_TYPES.MemberExpression) {
                    return;
                }
                if (!(0, util_1.isStaticMemberAccessOfValue)(callee, context, 'reject') ||
                    !typeAtLocationIsLikePromise(callee.object)) {
                    return;
                }
                checkRejectCall(node);
            },
            NewExpression(node) {
                const callee = (0, util_1.skipChainExpression)(node.callee);
                if (!(0, util_1.isPromiseConstructorLike)(services.program, services.getTypeAtLocation(callee))) {
                    return;
                }
                const executor = node.arguments.at(0);
                if (!executor || !(0, util_1.isFunction)(executor)) {
                    return;
                }
                const rejectParamNode = executor.params.at(1);
                if (!rejectParamNode || !(0, util_1.isIdentifier)(rejectParamNode)) {
                    return;
                }
                // reject param is always present in variables declared by executor
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const rejectVariable = context.sourceCode
                    .getDeclaredVariables(executor)
                    .find(variable => variable.identifiers.includes(rejectParamNode));
                rejectVariable.references.forEach(ref => {
                    if (ref.identifier.parent.type !== utils_1.AST_NODE_TYPES.CallExpression ||
                        ref.identifier !== ref.identifier.parent.callee) {
                        return;
                    }
                    checkRejectCall(ref.identifier.parent);
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-readonly-parameter-types.d.ts
--------------------------------------------------------------------------------

import type { TypeOrValueSpecifier } from '../util';
export type Options = [
    {
        allow?: TypeOrValueSpecifier[];
        checkParameterProperties?: boolean;
        ignoreInferredTypes?: boolean;
        treatMethodsAsReadonly?: boolean;
    }
];
export type MessageIds = 'shouldBeReadonly';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"shouldBeReadonly", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-readonly-parameter-types.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-readonly-parameter-types',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require function parameters to be typed as `readonly` to prevent accidental mutation of inputs',
            requiresTypeChecking: true,
        },
        messages: {
            shouldBeReadonly: 'Parameter should be a read only type.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allow: {
                        ...util_1.readonlynessOptionsSchema.properties.allow,
                        description: 'An array of type specifiers to ignore.',
                    },
                    checkParameterProperties: {
                        type: 'boolean',
                        description: 'Whether to check class parameter properties.',
                    },
                    ignoreInferredTypes: {
                        type: 'boolean',
                        description: "Whether to ignore parameters which don't explicitly specify a type.",
                    },
                    treatMethodsAsReadonly: {
                        ...util_1.readonlynessOptionsSchema.properties.treatMethodsAsReadonly,
                        description: 'Whether to treat all mutable methods as though they are readonly.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allow: util_1.readonlynessOptionsDefaults.allow,
            checkParameterProperties: true,
            ignoreInferredTypes: false,
            treatMethodsAsReadonly: util_1.readonlynessOptionsDefaults.treatMethodsAsReadonly,
        },
    ],
    create(context, [{ allow, checkParameterProperties, ignoreInferredTypes, treatMethodsAsReadonly, },]) {
        const services = (0, util_1.getParserServices)(context);
        return {
            [[
                utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
                utils_1.AST_NODE_TYPES.FunctionDeclaration,
                utils_1.AST_NODE_TYPES.FunctionExpression,
                utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration,
                utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration,
                utils_1.AST_NODE_TYPES.TSDeclareFunction,
                utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
                utils_1.AST_NODE_TYPES.TSFunctionType,
                utils_1.AST_NODE_TYPES.TSMethodSignature,
            ].join(', ')](node) {
                for (const param of node.params) {
                    if (!checkParameterProperties &&
                        param.type === utils_1.AST_NODE_TYPES.TSParameterProperty) {
                        continue;
                    }
                    const actualParam = param.type === utils_1.AST_NODE_TYPES.TSParameterProperty
                        ? param.parameter
                        : param;
                    if (ignoreInferredTypes && actualParam.typeAnnotation == null) {
                        continue;
                    }
                    const type = services.getTypeAtLocation(actualParam);
                    const isReadOnly = (0, util_1.isTypeReadonly)(services.program, type, {
                        allow,
                        treatMethodsAsReadonly: !!treatMethodsAsReadonly,
                    });
                    if (!isReadOnly && !(0, util_1.isTypeBrandedLiteralLike)(type)) {
                        context.report({
                            node: actualParam,
                            messageId: 'shouldBeReadonly',
                        });
                    }
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-readonly.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'preferReadonly';
export type Options = [
    {
        onlyInlineLambdas?: boolean;
    }
];
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferReadonly", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-readonly.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const getMemberHeadLoc_1 = require("../util/getMemberHeadLoc");
const functionScopeBoundaries = [
    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
    utils_1.AST_NODE_TYPES.FunctionDeclaration,
    utils_1.AST_NODE_TYPES.FunctionExpression,
    utils_1.AST_NODE_TYPES.MethodDefinition,
].join(', ');
exports.default = (0, util_1.createRule)({
    name: 'prefer-readonly',
    meta: {
        type: 'suggestion',
        docs: {
            description: "Require private members to be marked as `readonly` if they're never modified outside of the constructor",
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            preferReadonly: "Member '{{name}}' is never reassigned; mark it as `readonly`.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    onlyInlineLambdas: {
                        type: 'boolean',
                        description: 'Whether to restrict checking only to members immediately assigned a lambda value.',
                    },
                },
            },
        ],
    },
    defaultOptions: [{ onlyInlineLambdas: false }],
    create(context, [{ onlyInlineLambdas }]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const classScopeStack = [];
        function handlePropertyAccessExpression(node, parent, classScope) {
            if (ts.isBinaryExpression(parent)) {
                handleParentBinaryExpression(node, parent, classScope);
                return;
            }
            if (ts.isDeleteExpression(parent) || isDestructuringAssignment(node)) {
                classScope.addVariableModification(node);
                return;
            }
            if (ts.isPostfixUnaryExpression(parent) ||
                ts.isPrefixUnaryExpression(parent)) {
                handleParentPostfixOrPrefixUnaryExpression(parent, classScope);
            }
        }
        function handleParentBinaryExpression(node, parent, classScope) {
            if (parent.left === node &&
                tsutils.isAssignmentKind(parent.operatorToken.kind)) {
                classScope.addVariableModification(node);
            }
        }
        function handleParentPostfixOrPrefixUnaryExpression(node, classScope) {
            if (node.operator === ts.SyntaxKind.PlusPlusToken ||
                node.operator === ts.SyntaxKind.MinusMinusToken) {
                classScope.addVariableModification(node.operand);
            }
        }
        function isDestructuringAssignment(node) {
            let current = node.parent;
            while (current) {
                const parent = current.parent;
                if (ts.isObjectLiteralExpression(parent) ||
                    ts.isArrayLiteralExpression(parent) ||
                    ts.isSpreadAssignment(parent) ||
                    (ts.isSpreadElement(parent) &&
                        ts.isArrayLiteralExpression(parent.parent))) {
                    current = parent;
                }
                else if (ts.isBinaryExpression(parent) &&
                    !ts.isPropertyAccessExpression(current)) {
                    return (parent.left === current &&
                        parent.operatorToken.kind === ts.SyntaxKind.EqualsToken);
                }
                else {
                    break;
                }
            }
            return false;
        }
        function isFunctionScopeBoundaryInStack(node) {
            if (classScopeStack.length === 0) {
                return false;
            }
            const tsNode = services.esTreeNodeToTSNodeMap.get(node);
            if (ts.isConstructorDeclaration(tsNode)) {
                return false;
            }
            return tsutils.isFunctionScopeBoundary(tsNode);
        }
        function getEsNodesFromViolatingNode(violatingNode) {
            return {
                esNode: services.tsNodeToESTreeNodeMap.get(violatingNode),
                nameNode: services.tsNodeToESTreeNodeMap.get(violatingNode.name),
            };
        }
        function getTypeAnnotationForViolatingNode(node, type, initializerType) {
            const annotation = checker.typeToString(type);
            // verify the about-to-be-added type annotation is in-scope
            if (tsutils.isTypeFlagSet(initializerType, ts.TypeFlags.EnumLiteral)) {
                const scope = context.sourceCode.getScope(node);
                const variable = utils_1.ASTUtils.findVariable(scope, annotation);
                if (variable == null) {
                    return null;
                }
                const definition = variable.defs.find(def => def.isTypeDefinition);
                if (definition == null) {
                    return null;
                }
                const definitionType = services.getTypeAtLocation(definition.node);
                if (definitionType !== type) {
                    return null;
                }
            }
            return annotation;
        }
        return {
            [`${functionScopeBoundaries}:exit`](node) {
                if (utils_1.ASTUtils.isConstructor(node)) {
                    classScopeStack[classScopeStack.length - 1].exitConstructor();
                }
                else if (isFunctionScopeBoundaryInStack(node)) {
                    classScopeStack[classScopeStack.length - 1].exitNonConstructor();
                }
            },
            'ClassDeclaration, ClassExpression'(node) {
                classScopeStack.push(new ClassScope(checker, services.esTreeNodeToTSNodeMap.get(node), onlyInlineLambdas));
            },
            'ClassDeclaration, ClassExpression:exit'() {
                const finalizedClassScope = (0, util_1.nullThrows)(classScopeStack.pop(), 'Stack should exist on class exit');
                for (const violatingNode of finalizedClassScope.finalizeUnmodifiedPrivateNonReadonlys()) {
                    const { esNode, nameNode } = getEsNodesFromViolatingNode(violatingNode);
                    const reportNodeOrLoc = (() => {
                        switch (esNode.type) {
                            case utils_1.AST_NODE_TYPES.MethodDefinition:
                            case utils_1.AST_NODE_TYPES.PropertyDefinition:
                            case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
                                return { loc: (0, getMemberHeadLoc_1.getMemberHeadLoc)(context.sourceCode, esNode) };
                            case utils_1.AST_NODE_TYPES.TSParameterProperty:
                                return {
                                    loc: (0, getMemberHeadLoc_1.getParameterPropertyHeadLoc)(context.sourceCode, esNode, nameNode.name),
                                };
                            default:
                                return { node: esNode };
                        }
                    })();
                    const typeAnnotation = (() => {
                        if (esNode.type !== utils_1.AST_NODE_TYPES.PropertyDefinition) {
                            return null;
                        }
                        if (esNode.typeAnnotation || !esNode.value) {
                            return null;
                        }
                        if (nameNode.type !== utils_1.AST_NODE_TYPES.Identifier) {
                            return null;
                        }
                        const hasConstructorModifications = finalizedClassScope.memberHasConstructorModifications(nameNode.name);
                        if (!hasConstructorModifications) {
                            return null;
                        }
                        const violatingType = services.getTypeAtLocation(esNode);
                        const initializerType = services.getTypeAtLocation(esNode.value);
                        // if the RHS is a literal, its type would be narrowed, while the
                        // type of the initializer (which isn't `readonly`) would be the
                        // widened type
                        if (initializerType === violatingType) {
                            return null;
                        }
                        if (!tsutils.isLiteralType(initializerType)) {
                            return null;
                        }
                        return getTypeAnnotationForViolatingNode(esNode, violatingType, initializerType);
                    })();
                    context.report({
                        ...reportNodeOrLoc,
                        messageId: 'preferReadonly',
                        data: {
                            name: context.sourceCode.getText(nameNode),
                        },
                        *fix(fixer) {
                            yield fixer.insertTextBefore(nameNode, 'readonly ');
                            if (typeAnnotation) {
                                yield fixer.insertTextAfter(nameNode, `: ${typeAnnotation}`);
                            }
                        },
                    });
                }
            },
            [functionScopeBoundaries](node) {
                if (utils_1.ASTUtils.isConstructor(node)) {
                    classScopeStack[classScopeStack.length - 1].enterConstructor(services.esTreeNodeToTSNodeMap.get(node));
                }
                else if (isFunctionScopeBoundaryInStack(node)) {
                    classScopeStack[classScopeStack.length - 1].enterNonConstructor();
                }
            },
            MemberExpression(node) {
                if (classScopeStack.length !== 0 && !node.computed) {
                    const tsNode = services.esTreeNodeToTSNodeMap.get(node);
                    handlePropertyAccessExpression(tsNode, tsNode.parent, classScopeStack[classScopeStack.length - 1]);
                }
            },
        };
    },
});
const OUTSIDE_CONSTRUCTOR = -1;
const DIRECTLY_INSIDE_CONSTRUCTOR = 0;
var TypeToClassRelation;
(function (TypeToClassRelation) {
    TypeToClassRelation[TypeToClassRelation["ClassAndInstance"] = 0] = "ClassAndInstance";
    TypeToClassRelation[TypeToClassRelation["Class"] = 1] = "Class";
    TypeToClassRelation[TypeToClassRelation["Instance"] = 2] = "Instance";
    TypeToClassRelation[TypeToClassRelation["None"] = 3] = "None";
})(TypeToClassRelation || (TypeToClassRelation = {}));
class ClassScope {
    checker;
    onlyInlineLambdas;
    classType;
    constructorScopeDepth = OUTSIDE_CONSTRUCTOR;
    memberVariableModifications = new Set();
    memberVariableWithConstructorModifications = new Set();
    privateModifiableMembers = new Map();
    privateModifiableStatics = new Map();
    staticVariableModifications = new Set();
    constructor(checker, classNode, onlyInlineLambdas) {
        this.checker = checker;
        this.onlyInlineLambdas = onlyInlineLambdas;
        const classType = checker.getTypeAtLocation(classNode);
        if (tsutils.isIntersectionType(classType)) {
            this.classType = classType.types[0];
        }
        else {
            this.classType = classType;
        }
        for (const member of classNode.members) {
            if (ts.isPropertyDeclaration(member)) {
                this.addDeclaredVariable(member);
            }
        }
    }
    addDeclaredVariable(node) {
        if (!(tsutils.isModifierFlagSet(node, ts.ModifierFlags.Private) ||
            node.name.kind === ts.SyntaxKind.PrivateIdentifier) ||
            tsutils.isModifierFlagSet(node, ts.ModifierFlags.Accessor | ts.ModifierFlags.Readonly) ||
            ts.isComputedPropertyName(node.name)) {
            return;
        }
        if (this.onlyInlineLambdas &&
            node.initializer != null &&
            !ts.isArrowFunction(node.initializer)) {
            return;
        }
        (tsutils.isModifierFlagSet(node, ts.ModifierFlags.Static)
            ? this.privateModifiableStatics
            : this.privateModifiableMembers).set(node.name.getText(), node);
    }
    addVariableModification(node) {
        const modifierType = this.checker.getTypeAtLocation(node.expression);
        const relationOfModifierTypeToClass = this.getTypeToClassRelation(modifierType);
        if (relationOfModifierTypeToClass === TypeToClassRelation.Instance &&
            this.constructorScopeDepth === DIRECTLY_INSIDE_CONSTRUCTOR) {
            this.memberVariableWithConstructorModifications.add(node.name.text);
            return;
        }
        if (relationOfModifierTypeToClass === TypeToClassRelation.Instance ||
            relationOfModifierTypeToClass === TypeToClassRelation.ClassAndInstance) {
            this.memberVariableModifications.add(node.name.text);
        }
        if (relationOfModifierTypeToClass === TypeToClassRelation.Class ||
            relationOfModifierTypeToClass === TypeToClassRelation.ClassAndInstance) {
            this.staticVariableModifications.add(node.name.text);
        }
    }
    enterConstructor(node) {
        this.constructorScopeDepth = DIRECTLY_INSIDE_CONSTRUCTOR;
        for (const parameter of node.parameters) {
            if (tsutils.isModifierFlagSet(parameter, ts.ModifierFlags.Private)) {
                this.addDeclaredVariable(parameter);
            }
        }
    }
    enterNonConstructor() {
        if (this.constructorScopeDepth !== OUTSIDE_CONSTRUCTOR) {
            this.constructorScopeDepth += 1;
        }
    }
    exitConstructor() {
        this.constructorScopeDepth = OUTSIDE_CONSTRUCTOR;
    }
    exitNonConstructor() {
        if (this.constructorScopeDepth !== OUTSIDE_CONSTRUCTOR) {
            this.constructorScopeDepth -= 1;
        }
    }
    finalizeUnmodifiedPrivateNonReadonlys() {
        this.memberVariableModifications.forEach(variableName => {
            this.privateModifiableMembers.delete(variableName);
        });
        this.staticVariableModifications.forEach(variableName => {
            this.privateModifiableStatics.delete(variableName);
        });
        return [
            ...this.privateModifiableMembers.values(),
            ...this.privateModifiableStatics.values(),
        ];
    }
    getTypeToClassRelation(type) {
        if (type.isIntersection()) {
            let result = TypeToClassRelation.None;
            for (const subType of type.types) {
                const subTypeResult = this.getTypeToClassRelation(subType);
                switch (subTypeResult) {
                    case TypeToClassRelation.Class:
                        if (result === TypeToClassRelation.Instance) {
                            return TypeToClassRelation.ClassAndInstance;
                        }
                        result = TypeToClassRelation.Class;
                        break;
                    case TypeToClassRelation.Instance:
                        if (result === TypeToClassRelation.Class) {
                            return TypeToClassRelation.ClassAndInstance;
                        }
                        result = TypeToClassRelation.Instance;
                        break;
                }
            }
            return result;
        }
        if (type.isUnion()) {
            // any union of class/instance and something else will prevent access to
            // private members, so we assume that union consists only of classes
            // or class instances, because otherwise tsc will report an error
            return this.getTypeToClassRelation(type.types[0]);
        }
        if (!type.getSymbol() || !(0, util_1.typeIsOrHasBaseType)(type, this.classType)) {
            return TypeToClassRelation.None;
        }
        const typeIsClass = tsutils.isObjectType(type) &&
            tsutils.isObjectFlagSet(type, ts.ObjectFlags.Anonymous);
        if (typeIsClass) {
            return TypeToClassRelation.Class;
        }
        return TypeToClassRelation.Instance;
    }
    memberHasConstructorModifications(name) {
        return this.memberVariableWithConstructorModifications.has(name);
    }
}


--------------------------------------------------------------------------------
FILE: prefer-reduce-type-parameter.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferTypeParameter", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-reduce-type-parameter.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-reduce-type-parameter',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce using type parameter when calling `Array#reduce` instead of using a type assertion',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            preferTypeParameter: 'Unnecessary assertion: Array#reduce accepts a type parameter for the default value.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function isArrayType(type) {
            return tsutils
                .unionConstituents(type)
                .every(unionPart => tsutils
                .intersectionConstituents(unionPart)
                .every(t => checker.isArrayType(t) || checker.isTupleType(t)));
        }
        return {
            'CallExpression > MemberExpression.callee'(callee) {
                if (!(0, util_1.isStaticMemberAccessOfValue)(callee, context, 'reduce')) {
                    return;
                }
                const [, secondArg] = callee.parent.arguments;
                if (callee.parent.arguments.length < 2) {
                    return;
                }
                if ((0, util_1.isTypeAssertion)(secondArg)) {
                    const initializerType = services.getTypeAtLocation(secondArg.expression);
                    const assertedType = services.getTypeAtLocation(secondArg.typeAnnotation);
                    const isAssertionNecessary = !checker.isTypeAssignableTo(initializerType, assertedType);
                    // don't report this if the resulting fix will be a type error
                    if (isAssertionNecessary) {
                        return;
                    }
                }
                else {
                    return;
                }
                // Get the symbol of the `reduce` method.
                const calleeObjType = (0, util_1.getConstrainedTypeAtLocation)(services, callee.object);
                // Check the owner type of the `reduce` method.
                if (isArrayType(calleeObjType)) {
                    context.report({
                        node: secondArg,
                        messageId: 'preferTypeParameter',
                        fix: fixer => {
                            const fixes = [
                                fixer.removeRange([
                                    secondArg.range[0],
                                    secondArg.expression.range[0],
                                ]),
                                fixer.removeRange([
                                    secondArg.expression.range[1],
                                    secondArg.range[1],
                                ]),
                            ];
                            if (!callee.parent.typeArguments) {
                                fixes.push(fixer.insertTextAfter(callee, `<${context.sourceCode.getText(secondArg.typeAnnotation)}>`));
                            }
                            return fixes;
                        },
                    });
                    return;
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-regexp-exec.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"regExpExecOverStringMatch", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-regexp-exec.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
var ArgumentType;
(function (ArgumentType) {
    ArgumentType[ArgumentType["Other"] = 0] = "Other";
    ArgumentType[ArgumentType["String"] = 1] = "String";
    ArgumentType[ArgumentType["RegExp"] = 2] = "RegExp";
    ArgumentType[ArgumentType["Both"] = 3] = "Both";
})(ArgumentType || (ArgumentType = {}));
exports.default = (0, util_1.createRule)({
    name: 'prefer-regexp-exec',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce `RegExp#exec` over `String#match` if no global flag is provided',
            recommended: 'stylistic',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            regExpExecOverStringMatch: 'Use the `RegExp#exec()` method instead.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const globalScope = context.sourceCode.getScope(context.sourceCode.ast);
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        /**
         * Check if a given node type is a string.
         * @param type The node type to check.
         */
        function isStringType(type) {
            return (0, util_1.getTypeName)(checker, type) === 'string';
        }
        /**
         * Check if a given node type is a RegExp.
         * @param type The node type to check.
         */
        function isRegExpType(type) {
            return (0, util_1.getTypeName)(checker, type) === 'RegExp';
        }
        function collectArgumentTypes(types) {
            let result = ArgumentType.Other;
            for (const type of types) {
                if (isRegExpType(type)) {
                    result |= ArgumentType.RegExp;
                }
                else if (isStringType(type)) {
                    result |= ArgumentType.String;
                }
            }
            return result;
        }
        /**
         * Returns true if and only if we have syntactic proof that the /g flag is
         * absent. Returns false in all other cases (i.e. it still might or might
         * not contain the global flag).
         */
        function definitelyDoesNotContainGlobalFlag(node) {
            if ((node.type === utils_1.AST_NODE_TYPES.CallExpression ||
                node.type === utils_1.AST_NODE_TYPES.NewExpression) &&
                node.callee.type === utils_1.AST_NODE_TYPES.Identifier &&
                node.callee.name === 'RegExp') {
                const flags = node.arguments.at(1);
                return !(flags?.type === utils_1.AST_NODE_TYPES.Literal &&
                    typeof flags.value === 'string' &&
                    flags.value.includes('g'));
            }
            return false;
        }
        return {
            'CallExpression[arguments.length=1] > MemberExpression'(memberNode) {
                if (!(0, util_1.isStaticMemberAccessOfValue)(memberNode, context, 'match')) {
                    return;
                }
                const objectNode = memberNode.object;
                const callNode = memberNode.parent;
                const [argumentNode] = callNode.arguments;
                const argumentValue = (0, util_1.getStaticValue)(argumentNode, globalScope);
                if (!isStringType(services.getTypeAtLocation(objectNode))) {
                    return;
                }
                // Don't report regular expressions with global flag.
                if ((!argumentValue &&
                    !definitelyDoesNotContainGlobalFlag(argumentNode)) ||
                    (argumentValue &&
                        argumentValue.value instanceof RegExp &&
                        argumentValue.value.flags.includes('g'))) {
                    return;
                }
                if (argumentNode.type === utils_1.AST_NODE_TYPES.Literal &&
                    typeof argumentNode.value === 'string') {
                    let regExp;
                    try {
                        regExp = RegExp(argumentNode.value);
                    }
                    catch {
                        return;
                    }
                    return context.report({
                        node: memberNode.property,
                        messageId: 'regExpExecOverStringMatch',
                        fix: (0, util_1.getWrappingFixer)({
                            node: callNode,
                            innerNode: [objectNode],
                            sourceCode: context.sourceCode,
                            wrap: objectCode => `${regExp.toString()}.exec(${objectCode})`,
                        }),
                    });
                }
                const argumentType = services.getTypeAtLocation(argumentNode);
                const argumentTypes = collectArgumentTypes(tsutils.unionConstituents(argumentType));
                switch (argumentTypes) {
                    case ArgumentType.RegExp:
                        return context.report({
                            node: memberNode.property,
                            messageId: 'regExpExecOverStringMatch',
                            fix: (0, util_1.getWrappingFixer)({
                                node: callNode,
                                innerNode: [objectNode, argumentNode],
                                sourceCode: context.sourceCode,
                                wrap: (objectCode, argumentCode) => `${argumentCode}.exec(${objectCode})`,
                            }),
                        });
                    case ArgumentType.String:
                        return context.report({
                            node: memberNode.property,
                            messageId: 'regExpExecOverStringMatch',
                            fix: (0, util_1.getWrappingFixer)({
                                node: callNode,
                                innerNode: [objectNode, argumentNode],
                                sourceCode: context.sourceCode,
                                wrap: (objectCode, argumentCode) => `RegExp(${argumentCode}).exec(${objectCode})`,
                            }),
                        });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-return-this-type.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"useThisType", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-return-this-type.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const ts_api_utils_1 = require("ts-api-utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-return-this-type',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce that `this` is used when only `this` type is returned',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            useThisType: 'Use `this` type instead.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function tryGetNameInType(name, typeNode) {
            if (typeNode.type === utils_1.AST_NODE_TYPES.TSTypeReference &&
                typeNode.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
                typeNode.typeName.name === name) {
                return typeNode;
            }
            if (typeNode.type === utils_1.AST_NODE_TYPES.TSUnionType) {
                for (const type of typeNode.types) {
                    const found = tryGetNameInType(name, type);
                    if (found) {
                        return found;
                    }
                }
            }
            return undefined;
        }
        function isThisSpecifiedInParameters(originalFunc) {
            const firstArg = originalFunc.params.at(0);
            return (firstArg?.type === utils_1.AST_NODE_TYPES.Identifier && firstArg.name === 'this');
        }
        function isFunctionReturningThis(originalFunc, originalClass) {
            if (isThisSpecifiedInParameters(originalFunc)) {
                return false;
            }
            const func = services.esTreeNodeToTSNodeMap.get(originalFunc);
            if (!func.body) {
                return false;
            }
            const classType = services.getTypeAtLocation(originalClass);
            if (func.body.kind !== ts.SyntaxKind.Block) {
                const type = checker.getTypeAtLocation(func.body);
                return classType.thisType === type;
            }
            let hasReturnThis = false;
            let hasReturnClassType = false;
            (0, util_1.forEachReturnStatement)(func.body, stmt => {
                const expr = stmt.expression;
                if (!expr) {
                    return;
                }
                // fast check
                if (expr.kind === ts.SyntaxKind.ThisKeyword) {
                    hasReturnThis = true;
                    return;
                }
                const type = checker.getTypeAtLocation(expr);
                if (classType === type) {
                    hasReturnClassType = true;
                    return true;
                }
                if (classType.thisType === type) {
                    hasReturnThis = true;
                    return;
                }
                if ((0, ts_api_utils_1.isUnionType)(type) &&
                    type.types.some(typePart => typePart === classType)) {
                    hasReturnClassType = true;
                    return true;
                }
                return;
            });
            return !hasReturnClassType && hasReturnThis;
        }
        function checkFunction(originalFunc, originalClass) {
            const className = originalClass.id?.name;
            if (!className || !originalFunc.returnType) {
                return;
            }
            const node = tryGetNameInType(className, originalFunc.returnType.typeAnnotation);
            if (!node) {
                return;
            }
            if (isFunctionReturningThis(originalFunc, originalClass)) {
                context.report({
                    node,
                    messageId: 'useThisType',
                    fix: fixer => fixer.replaceText(node, 'this'),
                });
            }
        }
        function checkProperty(node) {
            if (!(node.value?.type === utils_1.AST_NODE_TYPES.FunctionExpression ||
                node.value?.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression)) {
                return;
            }
            checkFunction(node.value, node.parent.parent);
        }
        return {
            'ClassBody > AccessorProperty': checkProperty,
            'ClassBody > MethodDefinition'(node) {
                checkFunction(node.value, node.parent.parent);
            },
            'ClassBody > PropertyDefinition': checkProperty,
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-string-starts-ends-with.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
type AllowedSingleElementEquality = 'always' | 'never';
export type Options = [
    {
        allowSingleElementEquality?: AllowedSingleElementEquality;
    }
];
export type MessageIds = 'preferEndsWith' | 'preferStartsWith';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-string-starts-ends-with.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const regexpp_1 = require("@eslint-community/regexpp");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const EQ_OPERATORS = /^[=!]=/;
const regexpp = new regexpp_1.RegExpParser();
exports.default = (0, util_1.createRule)({
    name: 'prefer-string-starts-ends-with',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce using `String#startsWith` and `String#endsWith` over other equivalent methods of checking substrings',
            recommended: 'stylistic',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            preferEndsWith: "Use the 'String#endsWith' method instead.",
            preferStartsWith: "Use 'String#startsWith' method instead.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowSingleElementEquality: {
                        type: 'string',
                        description: 'Whether to allow equality checks against the first or last element of a string.',
                        enum: ['always', 'never'],
                    },
                },
            },
        ],
    },
    defaultOptions: [{ allowSingleElementEquality: 'never' }],
    create(context, [{ allowSingleElementEquality }]) {
        const globalScope = context.sourceCode.getScope(context.sourceCode.ast);
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        /**
         * Check if a given node is a string.
         * @param node The node to check.
         */
        function isStringType(node) {
            const objectType = services.getTypeAtLocation(node);
            return (0, util_1.getTypeName)(checker, objectType) === 'string';
        }
        /**
         * Check if a given node is a `Literal` node that is null.
         * @param node The node to check.
         */
        function isNull(node) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            return evaluated != null && evaluated.value == null;
        }
        /**
         * Check if a given node is a `Literal` node that is a given value.
         * @param node The node to check.
         * @param value The expected value of the `Literal` node.
         */
        function isNumber(node, value) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            return evaluated?.value === value;
        }
        /**
         * Check if a given node is a `Literal` node that is a character.
         * @param node The node to check.
         */
        function isCharacter(node) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            return (evaluated != null &&
                typeof evaluated.value === 'string' &&
                // checks if the string is a character long
                evaluated.value[0] === evaluated.value);
        }
        /**
         * Check if a given node is `==`, `===`, `!=`, or `!==`.
         * @param node The node to check.
         */
        function isEqualityComparison(node) {
            return (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &&
                EQ_OPERATORS.test(node.operator));
        }
        /**
         * Check if two given nodes are the same meaning.
         * @param node1 A node to compare.
         * @param node2 Another node to compare.
         */
        function isSameTokens(node1, node2) {
            const tokens1 = context.sourceCode.getTokens(node1);
            const tokens2 = context.sourceCode.getTokens(node2);
            if (tokens1.length !== tokens2.length) {
                return false;
            }
            for (let i = 0; i < tokens1.length; ++i) {
                const token1 = tokens1[i];
                const token2 = tokens2[i];
                if (token1.type !== token2.type || token1.value !== token2.value) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Check if a given node is the expression of the length of a string.
         *
         * - If `length` property access of `expectedObjectNode`, it's `true`.
         *   E.g., `foo` → `foo.length` / `"foo"` → `"foo".length`
         * - If `expectedObjectNode` is a string literal, `node` can be a number.
         *   E.g., `"foo"` → `3`
         *
         * @param node The node to check.
         * @param expectedObjectNode The node which is expected as the receiver of `length` property.
         */
        function isLengthExpression(node, expectedObjectNode) {
            if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {
                return ((0, util_1.getPropertyName)(node, globalScope) === 'length' &&
                    isSameTokens(node.object, expectedObjectNode));
            }
            const evaluatedLength = (0, util_1.getStaticValue)(node, globalScope);
            const evaluatedString = (0, util_1.getStaticValue)(expectedObjectNode, globalScope);
            return (evaluatedLength != null &&
                evaluatedString != null &&
                typeof evaluatedLength.value === 'number' &&
                typeof evaluatedString.value === 'string' &&
                evaluatedLength.value === evaluatedString.value.length);
        }
        /**
         * Returns true if `node` is `-substring.length` or
         * `parentString.length - substring.length`
         */
        function isLengthAheadOfEnd(node, substring, parentString) {
            return ((node.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                node.operator === '-' &&
                isLengthExpression(node.argument, substring)) ||
                (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &&
                    node.operator === '-' &&
                    isLengthExpression(node.left, parentString) &&
                    isLengthExpression(node.right, substring)));
        }
        /**
         * Check if a given node is the expression of the last index.
         *
         * E.g. `foo.length - 1`
         *
         * @param node The node to check.
         * @param expectedObjectNode The node which is expected as the receiver of `length` property.
         */
        function isLastIndexExpression(node, expectedObjectNode) {
            return (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &&
                node.operator === '-' &&
                isLengthExpression(node.left, expectedObjectNode) &&
                isNumber(node.right, 1));
        }
        /**
         * Get the range of the property of a given `MemberExpression` node.
         *
         * - `obj[foo]` → the range of `[foo]`
         * - `obf.foo` → the range of `.foo`
         * - `(obj).foo` → the range of `.foo`
         *
         * @param node The member expression node to get.
         */
        function getPropertyRange(node) {
            const dotOrOpenBracket = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.object, util_1.isNotClosingParenToken), util_1.NullThrowsReasons.MissingToken('closing parenthesis', 'member'));
            return [dotOrOpenBracket.range[0], node.range[1]];
        }
        /**
         * Parse a given `RegExp` pattern to that string if it's a static string.
         * @param pattern The RegExp pattern text to parse.
         * @param unicode Whether the RegExp is unicode.
         */
        function parseRegExpText(pattern, unicode) {
            // Parse it.
            const ast = regexpp.parsePattern(pattern, undefined, undefined, {
                unicode,
            });
            if (ast.alternatives.length !== 1) {
                return null;
            }
            // Drop `^`/`$` assertion.
            const chars = ast.alternatives[0].elements;
            const first = chars[0];
            if (first.type === 'Assertion' && first.kind === 'start') {
                chars.shift();
            }
            else {
                chars.pop();
            }
            // Check if it can determine a unique string.
            if (!chars.every(c => c.type === 'Character')) {
                return null;
            }
            // To string.
            return String.fromCodePoint(...chars.map(c => c.value));
        }
        /**
         * Parse a given node if it's a `RegExp` instance.
         * @param node The node to parse.
         */
        function parseRegExp(node) {
            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
            if (evaluated == null || !(evaluated.value instanceof RegExp)) {
                return null;
            }
            const { flags, source } = evaluated.value;
            const isStartsWith = source.startsWith('^');
            const isEndsWith = source.endsWith('$');
            if (isStartsWith === isEndsWith ||
                flags.includes('i') ||
                flags.includes('m')) {
                return null;
            }
            const text = parseRegExpText(source, flags.includes('u'));
            if (text == null) {
                return null;
            }
            return { isEndsWith, isStartsWith, text };
        }
        function getLeftNode(init) {
            const node = (0, util_1.skipChainExpression)(init);
            const leftNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node;
            if (leftNode.type !== utils_1.AST_NODE_TYPES.MemberExpression) {
                throw new Error(`Expected a MemberExpression, got ${leftNode.type}`);
            }
            return leftNode;
        }
        /**
         * Fix code with using the right operand as the search string.
         * For example: `foo.slice(0, 3) === 'bar'` → `foo.startsWith('bar')`
         * @param fixer The rule fixer.
         * @param node The node which was reported.
         * @param kind The kind of the report.
         * @param isNegative The flag to fix to negative condition.
         */
        function* fixWithRightOperand(fixer, node, kind, isNegative, isOptional) {
            // left is CallExpression or MemberExpression.
            const leftNode = getLeftNode(node.left);
            const propertyRange = getPropertyRange(leftNode);
            if (isNegative) {
                yield fixer.insertTextBefore(node, '!');
            }
            yield fixer.replaceTextRange([propertyRange[0], node.right.range[0]], `${isOptional ? '?.' : '.'}${kind}sWith(`);
            yield fixer.replaceTextRange([node.right.range[1], node.range[1]], ')');
        }
        /**
         * Fix code with using the first argument as the search string.
         * For example: `foo.indexOf('bar') === 0` → `foo.startsWith('bar')`
         * @param fixer The rule fixer.
         * @param node The node which was reported.
         * @param kind The kind of the report.
         * @param negative The flag to fix to negative condition.
         */
        function* fixWithArgument(fixer, node, callNode, calleeNode, kind, negative, isOptional) {
            if (negative) {
                yield fixer.insertTextBefore(node, '!');
            }
            yield fixer.replaceTextRange(getPropertyRange(calleeNode), `${isOptional ? '?.' : '.'}${kind}sWith`);
            yield fixer.removeRange([callNode.range[1], node.range[1]]);
        }
        function getParent(node) {
            return node.parent.type === utils_1.AST_NODE_TYPES.ChainExpression
                ? node.parent.parent
                : node.parent;
        }
        return {
            // foo[0] === "a"
            // foo.charAt(0) === "a"
            // foo[foo.length - 1] === "a"
            // foo.charAt(foo.length - 1) === "a"
            [[
                'BinaryExpression > MemberExpression.left[computed=true]',
                'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name="charAt"][computed=false]',
                'BinaryExpression > ChainExpression.left > MemberExpression[computed=true]',
                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name="charAt"][computed=false]',
            ].join(', ')](node) {
                let parentNode = getParent(node);
                let indexNode = null;
                if (parentNode.type === utils_1.AST_NODE_TYPES.CallExpression) {
                    if (parentNode.arguments.length === 1) {
                        indexNode = parentNode.arguments[0];
                    }
                    parentNode = getParent(parentNode);
                }
                else {
                    indexNode = node.property;
                }
                if (indexNode == null ||
                    !isEqualityComparison(parentNode) ||
                    !isStringType(node.object)) {
                    return;
                }
                const isEndsWith = isLastIndexExpression(indexNode, node.object);
                if (allowSingleElementEquality === 'always' && isEndsWith) {
                    return;
                }
                const isStartsWith = !isEndsWith && isNumber(indexNode, 0);
                if ((allowSingleElementEquality === 'always' && isStartsWith) ||
                    (!isStartsWith && !isEndsWith)) {
                    return;
                }
                const eqNode = parentNode;
                context.report({
                    node: parentNode,
                    messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',
                    fix(fixer) {
                        // Don't fix if it can change the behavior.
                        if (!isCharacter(eqNode.right)) {
                            return null;
                        }
                        return fixWithRightOperand(fixer, eqNode, isStartsWith ? 'start' : 'end', eqNode.operator.startsWith('!'), node.optional);
                    },
                });
            },
            // foo.indexOf('bar') === 0
            [[
                'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name="indexOf"][computed=false]',
                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name="indexOf"][computed=false]',
            ].join(', ')](node) {
                const callNode = getParent(node);
                const parentNode = getParent(callNode);
                if (callNode.arguments.length !== 1 ||
                    !isEqualityComparison(parentNode) ||
                    !isNumber(parentNode.right, 0) ||
                    !isStringType(node.object)) {
                    return;
                }
                context.report({
                    node: parentNode,
                    messageId: 'preferStartsWith',
                    fix(fixer) {
                        return fixWithArgument(fixer, parentNode, callNode, node, 'start', parentNode.operator.startsWith('!'), node.optional);
                    },
                });
            },
            // foo.lastIndexOf('bar') === foo.length - 3
            // foo.lastIndexOf(bar) === foo.length - bar.length
            [[
                'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name="lastIndexOf"][computed=false]',
                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name="lastIndexOf"][computed=false]',
            ].join(', ')](node) {
                const callNode = getParent(node);
                const parentNode = getParent(callNode);
                if (callNode.arguments.length !== 1 ||
                    !isEqualityComparison(parentNode) ||
                    parentNode.right.type !== utils_1.AST_NODE_TYPES.BinaryExpression ||
                    parentNode.right.operator !== '-' ||
                    !isLengthExpression(parentNode.right.left, node.object) ||
                    !isLengthExpression(parentNode.right.right, callNode.arguments[0]) ||
                    !isStringType(node.object)) {
                    return;
                }
                context.report({
                    node: parentNode,
                    messageId: 'preferEndsWith',
                    fix(fixer) {
                        return fixWithArgument(fixer, parentNode, callNode, node, 'end', parentNode.operator.startsWith('!'), node.optional);
                    },
                });
            },
            // foo.match(/^bar/) === null
            // foo.match(/bar$/) === null
            [[
                'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name="match"][computed=false]',
                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name="match"][computed=false]',
            ].join(', ')](node) {
                const callNode = getParent(node);
                const parentNode = getParent(callNode);
                if (!isNull(parentNode.right) || !isStringType(node.object)) {
                    return;
                }
                const parsed = callNode.arguments.length === 1
                    ? parseRegExp(callNode.arguments[0])
                    : null;
                if (parsed == null) {
                    return;
                }
                const { isStartsWith, text } = parsed;
                context.report({
                    node: callNode,
                    messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',
                    *fix(fixer) {
                        if (!parentNode.operator.startsWith('!')) {
                            yield fixer.insertTextBefore(parentNode, '!');
                        }
                        yield fixer.replaceTextRange(getPropertyRange(node), `${node.optional ? '?.' : '.'}${isStartsWith ? 'start' : 'end'}sWith`);
                        yield fixer.replaceText(callNode.arguments[0], JSON.stringify(text));
                        yield fixer.removeRange([callNode.range[1], parentNode.range[1]]);
                    },
                });
            },
            // foo.slice(0, 3) === 'bar'
            // foo.slice(-3) === 'bar'
            // foo.slice(-3, foo.length) === 'bar'
            // foo.substring(0, 3) === 'bar'
            // foo.substring(foo.length - 3) === 'bar'
            // foo.substring(foo.length - 3, foo.length) === 'bar'
            [[
                'BinaryExpression > CallExpression.left > MemberExpression',
                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression',
            ].join(', ')](node) {
                if (!(0, util_1.isStaticMemberAccessOfValue)(node, context, 'slice', 'substring')) {
                    return;
                }
                const callNode = getParent(node);
                const parentNode = getParent(callNode);
                if (!isEqualityComparison(parentNode) || !isStringType(node.object)) {
                    return;
                }
                let isEndsWith = false;
                let isStartsWith = false;
                if (callNode.arguments.length === 1) {
                    if (
                    // foo.slice(-bar.length) === bar
                    // foo.slice(foo.length - bar.length) === bar
                    isLengthAheadOfEnd(callNode.arguments[0], parentNode.right, node.object)) {
                        isEndsWith = true;
                    }
                }
                else if (callNode.arguments.length === 2) {
                    if (
                    // foo.slice(0, bar.length) === bar
                    isNumber(callNode.arguments[0], 0) &&
                        isLengthExpression(callNode.arguments[1], parentNode.right)) {
                        isStartsWith = true;
                    }
                    else if (
                    // foo.slice(foo.length - bar.length, foo.length) === bar
                    // foo.slice(foo.length - bar.length, 0) === bar
                    // foo.slice(-bar.length, foo.length) === bar
                    // foo.slice(-bar.length, 0) === bar
                    (isLengthExpression(callNode.arguments[1], node.object) ||
                        isNumber(callNode.arguments[1], 0)) &&
                        isLengthAheadOfEnd(callNode.arguments[0], parentNode.right, node.object)) {
                        isEndsWith = true;
                    }
                }
                if (!isStartsWith && !isEndsWith) {
                    return;
                }
                const eqNode = parentNode;
                const negativeIndexSupported = node.property.name === 'slice';
                context.report({
                    node: parentNode,
                    messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',
                    fix(fixer) {
                        // Don't fix if it can change the behavior.
                        if (eqNode.operator.length === 2 &&
                            (eqNode.right.type !== utils_1.AST_NODE_TYPES.Literal ||
                                typeof eqNode.right.value !== 'string')) {
                            return null;
                        }
                        // code being checked is likely mistake:
                        // unequal length of strings being checked for equality
                        // or reliant on behavior of substring (negative indices interpreted as 0)
                        if (isStartsWith) {
                            if (!isLengthExpression(callNode.arguments[1], eqNode.right)) {
                                return null;
                            }
                        }
                        else {
                            const posNode = callNode.arguments[0];
                            const posNodeIsAbsolutelyValid = (posNode.type === utils_1.AST_NODE_TYPES.BinaryExpression &&
                                posNode.operator === '-' &&
                                isLengthExpression(posNode.left, node.object) &&
                                isLengthExpression(posNode.right, eqNode.right)) ||
                                (negativeIndexSupported &&
                                    posNode.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                                    posNode.operator === '-' &&
                                    isLengthExpression(posNode.argument, eqNode.right));
                            if (!posNodeIsAbsolutelyValid) {
                                return null;
                            }
                        }
                        return fixWithRightOperand(fixer, parentNode, isStartsWith ? 'start' : 'end', parentNode.operator.startsWith('!'), node.optional);
                    },
                });
            },
            // /^bar/.test(foo)
            // /bar$/.test(foo)
            'CallExpression > MemberExpression.callee[property.name="test"][computed=false]'(node) {
                const callNode = getParent(node);
                const parsed = callNode.arguments.length === 1 ? parseRegExp(node.object) : null;
                if (parsed == null) {
                    return;
                }
                const { isStartsWith, text } = parsed;
                const messageId = isStartsWith ? 'preferStartsWith' : 'preferEndsWith';
                const methodName = isStartsWith ? 'startsWith' : 'endsWith';
                context.report({
                    node: callNode,
                    messageId,
                    *fix(fixer) {
                        const argNode = callNode.arguments[0];
                        const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal &&
                            argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral &&
                            argNode.type !== utils_1.AST_NODE_TYPES.Identifier &&
                            argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression &&
                            argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;
                        yield fixer.removeRange([callNode.range[0], argNode.range[0]]);
                        if (needsParen) {
                            yield fixer.insertTextBefore(argNode, '(');
                            yield fixer.insertTextAfter(argNode, ')');
                        }
                        yield fixer.insertTextAfter(argNode, `${node.optional ? '?.' : '.'}${methodName}(${JSON.stringify(text)}`);
                    },
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: prefer-ts-expect-error.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'preferExpectErrorComment';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"preferExpectErrorComment", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: prefer-ts-expect-error.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'prefer-ts-expect-error',
    meta: {
        type: 'problem',
        deprecated: {
            deprecatedSince: '7.11.0',
            replacedBy: [
                {
                    rule: {
                        name: '@typescript-eslint/ban-ts-comment',
                        url: 'https://typescript-eslint.io/rules/ban-ts-comment',
                    },
                },
            ],
            url: 'https://github.com/typescript-eslint/typescript-eslint/pull/9081',
        },
        docs: {
            description: 'Enforce using `@ts-expect-error` over `@ts-ignore`',
        },
        fixable: 'code',
        messages: {
            preferExpectErrorComment: 'Use "@ts-expect-error" to ensure an error is actually being suppressed.',
        },
        replacedBy: ['@typescript-eslint/ban-ts-comment'],
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const tsIgnoreRegExpSingleLine = /^\s*\/?\s*@ts-ignore/;
        const tsIgnoreRegExpMultiLine = /^\s*(?:\/|\*)*\s*@ts-ignore/;
        function isLineComment(comment) {
            return comment.type === utils_1.AST_TOKEN_TYPES.Line;
        }
        function getLastCommentLine(comment) {
            if (isLineComment(comment)) {
                return comment.value;
            }
            // For multiline comments - we look at only the last line.
            const commentlines = comment.value.split('\n');
            return commentlines[commentlines.length - 1];
        }
        function isValidTsIgnorePresent(comment) {
            const line = getLastCommentLine(comment);
            return isLineComment(comment)
                ? tsIgnoreRegExpSingleLine.test(line)
                : tsIgnoreRegExpMultiLine.test(line);
        }
        return {
            Program() {
                const comments = context.sourceCode.getAllComments();
                comments.forEach(comment => {
                    if (isValidTsIgnorePresent(comment)) {
                        const lineCommentRuleFixer = (fixer) => fixer.replaceText(comment, `//${comment.value.replace('@ts-ignore', '@ts-expect-error')}`);
                        const blockCommentRuleFixer = (fixer) => fixer.replaceText(comment, `/*${comment.value.replace('@ts-ignore', '@ts-expect-error')}*/`);
                        context.report({
                            node: comment,
                            messageId: 'preferExpectErrorComment',
                            fix: isLineComment(comment)
                                ? lineCommentRuleFixer
                                : blockCommentRuleFixer,
                        });
                    }
                });
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: promise-function-async.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowAny?: boolean;
        allowedPromiseNames?: string[];
        checkArrowFunctions?: boolean;
        checkFunctionDeclarations?: boolean;
        checkFunctionExpressions?: boolean;
        checkMethodDeclarations?: boolean;
    }
];
export type MessageIds = 'missingAsync' | 'missingAsyncHybridReturn';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: promise-function-async.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'promise-function-async',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require any function or method that returns a Promise to be marked async',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            missingAsync: 'Functions that return promises must be async.',
            missingAsyncHybridReturn: 'Functions that return promises must be async. Consider adding an explicit return type annotation if the function is intended to return a union of promise and non-promise types.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowAny: {
                        type: 'boolean',
                        description: 'Whether to consider `any` and `unknown` to be Promises.',
                    },
                    allowedPromiseNames: {
                        type: 'array',
                        description: 'Any extra names of classes or interfaces to be considered Promises.',
                        items: {
                            type: 'string',
                        },
                    },
                    checkArrowFunctions: {
                        type: 'boolean',
                        description: 'Whether to check arrow functions.',
                    },
                    checkFunctionDeclarations: {
                        type: 'boolean',
                        description: 'Whether to check standalone function declarations.',
                    },
                    checkFunctionExpressions: {
                        type: 'boolean',
                        description: 'Whether to check inline function expressions',
                    },
                    checkMethodDeclarations: {
                        type: 'boolean',
                        description: 'Whether to check methods on classes and object literals.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowAny: true,
            allowedPromiseNames: [],
            checkArrowFunctions: true,
            checkFunctionDeclarations: true,
            checkFunctionExpressions: true,
            checkMethodDeclarations: true,
        },
    ],
    create(context, [{ allowAny, allowedPromiseNames, checkArrowFunctions, checkFunctionDeclarations, checkFunctionExpressions, checkMethodDeclarations, },]) {
        const allAllowedPromiseNames = new Set([
            'Promise',
            // https://github.com/typescript-eslint/typescript-eslint/issues/5439
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ...allowedPromiseNames,
        ]);
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        function validateNode(node) {
            if (node.parent.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition) {
                // Abstract method can't be async
                return;
            }
            if ((node.parent.type === utils_1.AST_NODE_TYPES.Property ||
                node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition) &&
                (node.parent.kind === 'get' || node.parent.kind === 'set')) {
                // Getters and setters can't be async
                return;
            }
            const signatures = services.getTypeAtLocation(node).getCallSignatures();
            if (!signatures.length) {
                return;
            }
            const returnTypes = signatures.map(signature => checker.getReturnTypeOfSignature(signature));
            if (!allowAny &&
                returnTypes.some(type => (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown))) {
                // Report without auto fixer because the return type is unknown
                return context.report({
                    loc: (0, util_1.getFunctionHeadLoc)(node, context.sourceCode),
                    node,
                    messageId: 'missingAsync',
                });
            }
            if (
            // require all potential return types to be promise/any/unknown
            returnTypes.every(type => (0, util_1.containsAllTypesByName)(type, true, allAllowedPromiseNames, 
            // If no return type is explicitly set, we check if any parts of the return type match a Promise (instead of requiring all to match).
            node.returnType == null))) {
                const isHybridReturnType = returnTypes.some(type => type.isUnion() &&
                    !type.types.every(part => (0, util_1.containsAllTypesByName)(part, true, allAllowedPromiseNames)));
                context.report({
                    loc: (0, util_1.getFunctionHeadLoc)(node, context.sourceCode),
                    node,
                    messageId: isHybridReturnType
                        ? 'missingAsyncHybridReturn'
                        : 'missingAsync',
                    fix: fixer => {
                        if (node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition ||
                            (node.parent.type === utils_1.AST_NODE_TYPES.Property &&
                                node.parent.method)) {
                            // this function is a class method or object function property shorthand
                            const method = node.parent;
                            // the token to put `async` before
                            let keyToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(method), util_1.NullThrowsReasons.MissingToken('key token', 'method'));
                            // if there are decorators then skip past them
                            if (method.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                                method.decorators.length) {
                                const lastDecorator = method.decorators[method.decorators.length - 1];
                                keyToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(lastDecorator), util_1.NullThrowsReasons.MissingToken('key token', 'last decorator'));
                            }
                            // if current token is a keyword like `static` or `public`, or the `override` modifier, then skip it
                            while ((keyToken.type === utils_1.AST_TOKEN_TYPES.Keyword ||
                                (keyToken.type === utils_1.AST_TOKEN_TYPES.Identifier &&
                                    keyToken.value === 'override')) &&
                                keyToken.range[0] < method.key.range[0]) {
                                keyToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(keyToken), util_1.NullThrowsReasons.MissingToken('token', 'modifier keyword'));
                            }
                            // check if there is a space between key and previous token
                            const insertSpace = !context.sourceCode.isSpaceBetween((0, util_1.nullThrows)(context.sourceCode.getTokenBefore(keyToken), util_1.NullThrowsReasons.MissingToken('token', 'keyword')), keyToken);
                            let code = 'async ';
                            if (insertSpace) {
                                code = ` ${code}`;
                            }
                            return fixer.insertTextBefore(keyToken, code);
                        }
                        return fixer.insertTextBefore(node, 'async ');
                    },
                });
            }
        }
        return {
            ...(checkArrowFunctions && {
                'ArrowFunctionExpression[async = false]'(node) {
                    validateNode(node);
                },
            }),
            ...(checkFunctionDeclarations && {
                'FunctionDeclaration[async = false]'(node) {
                    validateNode(node);
                },
            }),
            'FunctionExpression[async = false]'(node) {
                if (node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                    node.parent.kind === 'method') {
                    if (checkMethodDeclarations) {
                        validateNode(node);
                    }
                    return;
                }
                if (checkFunctionExpressions) {
                    validateNode(node);
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: related-getter-setter-pairs.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"mismatch", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: related-getter-setter-pairs.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'related-getter-setter-pairs',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce that `get()` types should be assignable to their equivalent `set()` type',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        messages: {
            mismatch: '`get()` type should be assignable to its equivalent `set()` type.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const methodPairsStack = [];
        function addPropertyNode(member, inner, kind) {
            const methodPairs = methodPairsStack[methodPairsStack.length - 1];
            const { name } = (0, util_1.getNameFromMember)(member, context.sourceCode);
            methodPairs.set(name, {
                ...methodPairs.get(name),
                [kind]: inner,
            });
        }
        return {
            ':matches(ClassBody, TSInterfaceBody, TSTypeLiteral):exit'() {
                const methodPairs = methodPairsStack[methodPairsStack.length - 1];
                for (const pair of methodPairs.values()) {
                    if (!pair.get || !pair.set) {
                        continue;
                    }
                    const getter = pair.get;
                    const getType = services.getTypeAtLocation(getter);
                    const setType = services.getTypeAtLocation(pair.set.params[0]);
                    if (!checker.isTypeAssignableTo(getType, setType)) {
                        context.report({
                            node: getter.returnType.typeAnnotation,
                            messageId: 'mismatch',
                        });
                    }
                }
                methodPairsStack.pop();
            },
            ':matches(MethodDefinition, TSMethodSignature)[kind=get]'(node) {
                const getter = getMethodFromNode(node);
                if (getter.returnType) {
                    addPropertyNode(node, getter, 'get');
                }
            },
            ':matches(MethodDefinition, TSMethodSignature)[kind=set]'(node) {
                const setter = getMethodFromNode(node);
                if (setter.params.length === 1) {
                    addPropertyNode(node, setter, 'set');
                }
            },
            'ClassBody, TSInterfaceBody, TSTypeLiteral'() {
                methodPairsStack.push(new Map());
            },
        };
    },
});
function getMethodFromNode(node) {
    return node.type === utils_1.AST_NODE_TYPES.TSMethodSignature ? node : node.value;
}


--------------------------------------------------------------------------------
FILE: require-array-sort-compare.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        ignoreStringArrays?: boolean;
    }
];
export type MessageIds = 'requireCompare';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"requireCompare", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: require-array-sort-compare.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'require-array-sort-compare',
    meta: {
        type: 'problem',
        docs: {
            description: 'Require `Array#sort` and `Array#toSorted` calls to always provide a `compareFunction`',
            requiresTypeChecking: true,
        },
        messages: {
            requireCompare: "Require 'compare' argument.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ignoreStringArrays: {
                        type: 'boolean',
                        description: 'Whether to ignore arrays in which all elements are strings.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            ignoreStringArrays: true,
        },
    ],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        /**
         * Check if a given node is an array which all elements are string.
         */
        function isStringArrayNode(node) {
            const type = services.getTypeAtLocation(node);
            if (checker.isArrayType(type) || checker.isTupleType(type)) {
                const typeArgs = checker.getTypeArguments(type);
                return typeArgs.every(arg => (0, util_1.getTypeName)(checker, arg) === 'string');
            }
            return false;
        }
        function checkSortArgument(callee) {
            if (!(0, util_1.isStaticMemberAccessOfValue)(callee, context, 'sort', 'toSorted')) {
                return;
            }
            const calleeObjType = (0, util_1.getConstrainedTypeAtLocation)(services, callee.object);
            if (options.ignoreStringArrays && isStringArrayNode(callee.object)) {
                return;
            }
            if ((0, util_1.isTypeArrayTypeOrUnionOfArrayTypes)(calleeObjType, checker)) {
                context.report({ node: callee.parent, messageId: 'requireCompare' });
            }
        }
        return {
            'CallExpression[arguments.length=0] > MemberExpression': checkSortArgument,
        };
    },
});


--------------------------------------------------------------------------------
FILE: require-await.d.ts
--------------------------------------------------------------------------------

declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"missingAwait" | "removeAsync", [], import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: require-await.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'require-await',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow async functions which do not return promises and have no `await` expression',
            extendsBaseRule: true,
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            missingAwait: "{{name}} has no 'await' expression.",
            removeAsync: "Remove 'async'.",
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        let scopeInfo = null;
        /**
         * Push the scope info object to the stack.
         */
        function enterFunction(node) {
            scopeInfo = {
                hasAsync: node.async,
                hasAwait: false,
                isAsyncYield: false,
                isGen: node.generator || false,
                upper: scopeInfo,
            };
        }
        /**
         * Pop the top scope info object from the stack.
         * Also, it reports the function if needed.
         */
        function exitFunction(node) {
            /* istanbul ignore if */ if (!scopeInfo) {
                // this shouldn't ever happen, as we have to exit a function after we enter it
                return;
            }
            if (node.async &&
                !scopeInfo.hasAwait &&
                !isEmptyFunction(node) &&
                !(scopeInfo.isGen && scopeInfo.isAsyncYield)) {
                // If the function belongs to a method definition or
                // property, then the function's range may not include the
                // `async` keyword and we should look at the parent instead.
                const nodeWithAsyncKeyword = (node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                    node.parent.value === node) ||
                    (node.parent.type === utils_1.AST_NODE_TYPES.Property &&
                        node.parent.method &&
                        node.parent.value === node)
                    ? node.parent
                    : node;
                const asyncToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(nodeWithAsyncKeyword, token => token.value === 'async'), 'The node is an async function, so it must have an "async" token.');
                const asyncRange = [
                    asyncToken.range[0],
                    (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(asyncToken, {
                        includeComments: true,
                    }), 'There will always be a token after the "async" keyword.').range[0],
                ];
                // Removing the `async` keyword can cause parsing errors if the
                // current statement is relying on automatic semicolon insertion.
                // If ASI is currently being used, then we should replace the
                // `async` keyword with a semicolon.
                const nextToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(asyncToken), 'There will always be a token after the "async" keyword.');
                const addSemiColon = nextToken.type === utils_1.AST_TOKEN_TYPES.Punctuator &&
                    (nextToken.value === '[' || nextToken.value === '(') &&
                    (nodeWithAsyncKeyword.type === utils_1.AST_NODE_TYPES.MethodDefinition ||
                        (0, util_1.isStartOfExpressionStatement)(nodeWithAsyncKeyword)) &&
                    (0, util_1.needsPrecedingSemicolon)(context.sourceCode, nodeWithAsyncKeyword);
                const changes = [
                    { range: asyncRange, replacement: addSemiColon ? ';' : undefined },
                ];
                // If there's a return type annotation and it's a
                // `Promise<T>`, we can also change the return type
                // annotation to just `T` as part of the suggestion.
                // Alternatively, if the function is a generator and
                // the return type annotation is `AsyncGenerator<T>`,
                // then we can change it to `Generator<T>`.
                if (node.returnType?.typeAnnotation.type ===
                    utils_1.AST_NODE_TYPES.TSTypeReference) {
                    if (scopeInfo.isGen) {
                        if (hasTypeName(node.returnType.typeAnnotation, 'AsyncGenerator')) {
                            changes.push({
                                range: node.returnType.typeAnnotation.typeName.range,
                                replacement: 'Generator',
                            });
                        }
                    }
                    else if (hasTypeName(node.returnType.typeAnnotation, 'Promise') &&
                        node.returnType.typeAnnotation.typeArguments != null) {
                        const openAngle = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node.returnType.typeAnnotation, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator &&
                            token.value === '<'), 'There are type arguments, so the angle bracket will exist.');
                        const closeAngle = (0, util_1.nullThrows)(context.sourceCode.getLastToken(node.returnType.typeAnnotation, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator &&
                            token.value === '>'), 'There are type arguments, so the angle bracket will exist.');
                        changes.push(
                        // Remove the closing angled bracket.
                        { range: closeAngle.range, replacement: undefined }, 
                        // Remove the "Promise" identifier
                        // and the opening angled bracket.
                        {
                            range: [
                                node.returnType.typeAnnotation.typeName.range[0],
                                openAngle.range[1],
                            ],
                            replacement: undefined,
                        });
                    }
                }
                context.report({
                    loc: (0, util_1.getFunctionHeadLoc)(node, context.sourceCode),
                    node,
                    messageId: 'missingAwait',
                    data: {
                        name: (0, util_1.upperCaseFirst)((0, util_1.getFunctionNameWithKind)(node)),
                    },
                    suggest: [
                        {
                            messageId: 'removeAsync',
                            fix: (fixer) => changes.map(change => change.replacement != null
                                ? fixer.replaceTextRange(change.range, change.replacement)
                                : fixer.removeRange(change.range)),
                        },
                    ],
                });
            }
            scopeInfo = scopeInfo.upper;
        }
        /**
         * Checks if the node returns a thenable type
         */
        function isThenableType(node) {
            const type = checker.getTypeAtLocation(node);
            return tsutils.isThenableType(checker, node, type);
        }
        /**
         * Marks the current scope as having an await
         */
        function markAsHasAwait() {
            if (!scopeInfo) {
                return;
            }
            scopeInfo.hasAwait = true;
        }
        /**
         * Mark `scopeInfo.isAsyncYield` to `true` if it
         *  1) delegates async generator function
         *    or
         *  2) yields thenable type
         */
        function visitYieldExpression(node) {
            if (!scopeInfo?.isGen || !node.argument) {
                return;
            }
            if (node.argument.type === utils_1.AST_NODE_TYPES.Literal) {
                // ignoring this as for literals we don't need to check the definition
                // eg : async function* run() { yield* 1 }
                return;
            }
            if (!node.delegate) {
                if (isThenableType(services.esTreeNodeToTSNodeMap.get(node.argument))) {
                    scopeInfo.isAsyncYield = true;
                }
                return;
            }
            const type = services.getTypeAtLocation(node.argument);
            const typesToCheck = expandUnionOrIntersectionType(type);
            for (const type of typesToCheck) {
                const asyncIterator = tsutils.getWellKnownSymbolPropertyOfType(type, 'asyncIterator', checker);
                if (asyncIterator != null) {
                    scopeInfo.isAsyncYield = true;
                    break;
                }
            }
        }
        return {
            ArrowFunctionExpression: enterFunction,
            'ArrowFunctionExpression:exit': exitFunction,
            AwaitExpression: markAsHasAwait,
            'ForOfStatement[await = true]': markAsHasAwait,
            FunctionDeclaration: enterFunction,
            'FunctionDeclaration:exit': exitFunction,
            FunctionExpression: enterFunction,
            'FunctionExpression:exit': exitFunction,
            'VariableDeclaration[kind = "await using"]': markAsHasAwait,
            YieldExpression: visitYieldExpression,
            // check body-less async arrow function.
            // ignore `async () => await foo` because it's obviously correct
            'ArrowFunctionExpression[async = true] > :not(BlockStatement, AwaitExpression)'(node) {
                const expression = services.esTreeNodeToTSNodeMap.get(node);
                if (isThenableType(expression)) {
                    markAsHasAwait();
                }
            },
            ReturnStatement(node) {
                // short circuit early to avoid unnecessary type checks
                if (!scopeInfo || scopeInfo.hasAwait || !scopeInfo.hasAsync) {
                    return;
                }
                const { expression } = services.esTreeNodeToTSNodeMap.get(node);
                if (expression && isThenableType(expression)) {
                    markAsHasAwait();
                }
            },
        };
    },
});
function isEmptyFunction(node) {
    return (node.body.type === utils_1.AST_NODE_TYPES.BlockStatement &&
        node.body.body.length === 0);
}
function expandUnionOrIntersectionType(type) {
    if (type.isUnionOrIntersection()) {
        return type.types.flatMap(expandUnionOrIntersectionType);
    }
    return [type];
}
function hasTypeName(typeReference, typeName) {
    return (typeReference.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
        typeReference.typeName.name === typeName);
}


--------------------------------------------------------------------------------
FILE: restrict-plus-operands.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowAny?: boolean;
        allowBoolean?: boolean;
        allowNullish?: boolean;
        allowNumberAndString?: boolean;
        allowRegExp?: boolean;
        skipCompoundAssignments?: boolean;
    }
];
export type MessageIds = 'bigintAndNumber' | 'invalid' | 'mismatched';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: restrict-plus-operands.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'restrict-plus-operands',
    meta: {
        type: 'problem',
        docs: {
            description: 'Require both operands of addition to be the same type and be `bigint`, `number`, or `string`',
            recommended: {
                recommended: true,
                strict: [
                    {
                        allowAny: false,
                        allowBoolean: false,
                        allowNullish: false,
                        allowNumberAndString: false,
                        allowRegExp: false,
                    },
                ],
            },
            requiresTypeChecking: true,
        },
        messages: {
            bigintAndNumber: "Numeric '+' operations must either be both bigints or both numbers. Got `{{left}}` + `{{right}}`.",
            invalid: "Invalid operand for a '+' operation. Operands must each be a number or {{stringLike}}. Got `{{type}}`.",
            mismatched: "Operands of '+' operations must be a number or {{stringLike}}. Got `{{left}}` + `{{right}}`.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowAny: {
                        type: 'boolean',
                        description: 'Whether to allow `any` typed values.',
                    },
                    allowBoolean: {
                        type: 'boolean',
                        description: 'Whether to allow `boolean` typed values.',
                    },
                    allowNullish: {
                        type: 'boolean',
                        description: 'Whether to allow potentially `null` or `undefined` typed values.',
                    },
                    allowNumberAndString: {
                        type: 'boolean',
                        description: 'Whether to allow `bigint`/`number` typed values and `string` typed values to be added together.',
                    },
                    allowRegExp: {
                        type: 'boolean',
                        description: 'Whether to allow `regexp` typed values.',
                    },
                    skipCompoundAssignments: {
                        type: 'boolean',
                        description: 'Whether to skip compound assignments such as `+=`.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowAny: true,
            allowBoolean: true,
            allowNullish: true,
            allowNumberAndString: true,
            allowRegExp: true,
            skipCompoundAssignments: false,
        },
    ],
    create(context, [{ allowAny, allowBoolean, allowNullish, allowNumberAndString, allowRegExp, skipCompoundAssignments, },]) {
        const services = (0, util_1.getParserServices)(context);
        const typeChecker = services.program.getTypeChecker();
        const stringLikes = [
            allowAny && '`any`',
            allowBoolean && '`boolean`',
            allowNullish && '`null`',
            allowRegExp && '`RegExp`',
            allowNullish && '`undefined`',
        ].filter((value) => typeof value === 'string');
        const stringLike = stringLikes.length
            ? stringLikes.length === 1
                ? `string, allowing a string + ${stringLikes[0]}`
                : `string, allowing a string + any of: ${stringLikes.join(', ')}`
            : 'string';
        function getTypeConstrained(node) {
            return typeChecker.getBaseTypeOfLiteralType((0, util_1.getConstrainedTypeAtLocation)(services, node));
        }
        function checkPlusOperands(node) {
            const leftType = getTypeConstrained(node.left);
            const rightType = getTypeConstrained(node.right);
            if (leftType === rightType &&
                tsutils.isTypeFlagSet(leftType, ts.TypeFlags.BigIntLike |
                    ts.TypeFlags.NumberLike |
                    ts.TypeFlags.StringLike)) {
                return;
            }
            let hadIndividualComplaint = false;
            for (const [baseNode, baseType, otherType] of [
                [node.left, leftType, rightType],
                [node.right, rightType, leftType],
            ]) {
                if (isTypeFlagSetInUnion(baseType, ts.TypeFlags.ESSymbolLike |
                    ts.TypeFlags.Never |
                    ts.TypeFlags.Unknown) ||
                    (!allowAny && isTypeFlagSetInUnion(baseType, ts.TypeFlags.Any)) ||
                    (!allowBoolean &&
                        isTypeFlagSetInUnion(baseType, ts.TypeFlags.BooleanLike)) ||
                    (!allowNullish &&
                        (0, util_1.isTypeFlagSet)(baseType, ts.TypeFlags.Null | ts.TypeFlags.Undefined))) {
                    context.report({
                        node: baseNode,
                        messageId: 'invalid',
                        data: {
                            type: typeChecker.typeToString(baseType),
                            stringLike,
                        },
                    });
                    hadIndividualComplaint = true;
                    continue;
                }
                // RegExps also contain ts.TypeFlags.Any & ts.TypeFlags.Object
                for (const subBaseType of tsutils.unionConstituents(baseType)) {
                    const typeName = (0, util_1.getTypeName)(typeChecker, subBaseType);
                    if (typeName === 'RegExp'
                        ? !allowRegExp ||
                            tsutils.isTypeFlagSet(otherType, ts.TypeFlags.NumberLike)
                        : (!allowAny && (0, util_1.isTypeAnyType)(subBaseType)) ||
                            isDeeplyObjectType(subBaseType)) {
                        context.report({
                            node: baseNode,
                            messageId: 'invalid',
                            data: {
                                type: typeChecker.typeToString(subBaseType),
                                stringLike,
                            },
                        });
                        hadIndividualComplaint = true;
                        continue;
                    }
                }
            }
            if (hadIndividualComplaint) {
                return;
            }
            for (const [baseType, otherType] of [
                [leftType, rightType],
                [rightType, leftType],
            ]) {
                if (!allowNumberAndString &&
                    isTypeFlagSetInUnion(baseType, ts.TypeFlags.StringLike) &&
                    isTypeFlagSetInUnion(otherType, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike)) {
                    return context.report({
                        node,
                        messageId: 'mismatched',
                        data: {
                            left: typeChecker.typeToString(leftType),
                            right: typeChecker.typeToString(rightType),
                            stringLike,
                        },
                    });
                }
                if (isTypeFlagSetInUnion(baseType, ts.TypeFlags.NumberLike) &&
                    isTypeFlagSetInUnion(otherType, ts.TypeFlags.BigIntLike)) {
                    return context.report({
                        node,
                        messageId: 'bigintAndNumber',
                        data: {
                            left: typeChecker.typeToString(leftType),
                            right: typeChecker.typeToString(rightType),
                        },
                    });
                }
            }
        }
        return {
            "BinaryExpression[operator='+']": checkPlusOperands,
            ...(!skipCompoundAssignments && {
                "AssignmentExpression[operator='+=']"(node) {
                    checkPlusOperands(node);
                },
            }),
        };
    },
});
function isDeeplyObjectType(type) {
    return type.isIntersection()
        ? tsutils.intersectionConstituents(type).every(tsutils.isObjectType)
        : tsutils.unionConstituents(type).every(tsutils.isObjectType);
}
function isTypeFlagSetInUnion(type, flag) {
    return tsutils
        .unionConstituents(type)
        .some(subType => tsutils.isTypeFlagSet(subType, flag));
}


--------------------------------------------------------------------------------
FILE: restrict-template-expressions.d.ts
--------------------------------------------------------------------------------

import type { Type, TypeChecker } from 'typescript';
import type { TypeOrValueSpecifier } from '../util';
import { isTypeAnyType, isTypeNeverType } from '../util';
type OptionTester = (type: Type, checker: TypeChecker, recursivelyCheckType: (type: Type) => boolean) => boolean;
declare const optionTesters: {
    type: "Array" | "RegExp" | "Boolean" | "Number" | "Any" | "Nullish" | "Never";
    option: "allowAny" | "allowBoolean" | "allowNullish" | "allowRegExp" | "allowNever" | "allowNumber" | "allowArray";
    tester: typeof isTypeAnyType | typeof isTypeNeverType | OptionTester | ((type: Type, checker: TypeChecker, recursivelyCheckType: (type: Type) => boolean) => boolean) | ((type: Type, checker: TypeChecker) => boolean);
}[];
export type Options = [
    {
        allow?: TypeOrValueSpecifier[];
    } & Partial<Record<(typeof optionTesters)[number]['option'], boolean>>
];
export type MessageId = 'invalidType';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"invalidType", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: restrict-template-expressions.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const type_utils_1 = require("@typescript-eslint/type-utils");
const utils_1 = require("@typescript-eslint/utils");
const typescript_1 = require("typescript");
const util_1 = require("../util");
const testTypeFlag = (flagsToCheck) => type => (0, util_1.isTypeFlagSet)(type, flagsToCheck);
const optionTesters = [
    ['Any', util_1.isTypeAnyType],
    [
        'Array',
        (type, checker, recursivelyCheckType) => (checker.isArrayType(type) || checker.isTupleType(type)) &&
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            recursivelyCheckType(type.getNumberIndexType()),
    ],
    // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
    ['Boolean', testTypeFlag(typescript_1.TypeFlags.BooleanLike)],
    ['Nullish', testTypeFlag(typescript_1.TypeFlags.Null | typescript_1.TypeFlags.Undefined)],
    ['Number', testTypeFlag(typescript_1.TypeFlags.NumberLike | typescript_1.TypeFlags.BigIntLike)],
    [
        'RegExp',
        (type, checker) => (0, util_1.getTypeName)(checker, type) === 'RegExp',
    ],
    ['Never', util_1.isTypeNeverType],
].map(([type, tester]) => ({
    type,
    option: `allow${type}`,
    tester,
}));
exports.default = (0, util_1.createRule)({
    name: 'restrict-template-expressions',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce template literal expressions to be of `string` type',
            recommended: {
                recommended: true,
                strict: [
                    {
                        allowAny: false,
                        allowBoolean: false,
                        allowNever: false,
                        allowNullish: false,
                        allowNumber: false,
                        allowRegExp: false,
                    },
                ],
            },
            requiresTypeChecking: true,
        },
        messages: {
            invalidType: 'Invalid type "{{type}}" of template literal expression.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ...Object.fromEntries(optionTesters.map(({ type, option }) => [
                        option,
                        {
                            type: 'boolean',
                            description: `Whether to allow \`${type.toLowerCase()}\` typed values in template expressions.`,
                        },
                    ])),
                    allow: {
                        description: `Types to allow in template expressions.`,
                        ...type_utils_1.typeOrValueSpecifiersSchema,
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allow: [{ name: ['Error', 'URL', 'URLSearchParams'], from: 'lib' }],
            allowAny: true,
            allowBoolean: true,
            allowNullish: true,
            allowNumber: true,
            allowRegExp: true,
        },
    ],
    create(context, [{ allow, ...options }]) {
        const services = (0, util_1.getParserServices)(context);
        const { program } = services;
        const checker = program.getTypeChecker();
        const enabledOptionTesters = optionTesters.filter(({ option }) => options[option]);
        return {
            TemplateLiteral(node) {
                // don't check tagged template literals
                if (node.parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {
                    return;
                }
                for (const expression of node.expressions) {
                    const expressionType = (0, util_1.getConstrainedTypeAtLocation)(services, expression);
                    if (!recursivelyCheckType(expressionType)) {
                        context.report({
                            node: expression,
                            messageId: 'invalidType',
                            data: { type: checker.typeToString(expressionType) },
                        });
                    }
                }
            },
        };
        function recursivelyCheckType(innerType) {
            if (innerType.isUnion()) {
                return innerType.types.every(recursivelyCheckType);
            }
            if (innerType.isIntersection()) {
                return innerType.types.some(recursivelyCheckType);
            }
            return ((0, util_1.isTypeFlagSet)(innerType, typescript_1.TypeFlags.StringLike) ||
                (0, util_1.matchesTypeOrBaseType)(services, type => (0, type_utils_1.typeMatchesSomeSpecifier)(type, allow, program), innerType) ||
                enabledOptionTesters.some(({ tester }) => tester(innerType, checker, recursivelyCheckType)));
        }
    },
});


--------------------------------------------------------------------------------
FILE: return-await.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
declare const _default: TSESLint.RuleModule<"disallowedPromiseAwait" | "disallowedPromiseAwaitSuggestion" | "nonPromiseAwait" | "requiredPromiseAwait" | "requiredPromiseAwaitSuggestion", [string], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: return-await.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'return-await',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce consistent awaiting of returned promises',
            recommended: {
                strict: ['error-handling-correctness-only'],
            },
            requiresTypeChecking: true,
        },
        fixable: 'code',
        // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions -- suggestions are exposed through a helper.
        hasSuggestions: true,
        messages: {
            disallowedPromiseAwait: 'Returning an awaited promise is not allowed in this context.',
            disallowedPromiseAwaitSuggestion: 'Remove `await` before the expression. Use caution as this may impact control flow.',
            nonPromiseAwait: 'Returning an awaited value that is not a promise is not allowed.',
            requiredPromiseAwait: 'Returning an awaited promise is required in this context.',
            requiredPromiseAwaitSuggestion: 'Add `await` before the expression. Use caution as this may impact control flow.',
        },
        schema: [
            {
                type: 'string',
                oneOf: [
                    {
                        type: 'string',
                        description: 'Requires that all returned promises be awaited.',
                        enum: ['always'],
                    },
                    {
                        type: 'string',
                        description: 'In error-handling contexts, the rule enforces that returned promises must be awaited. In ordinary contexts, the rule does not enforce any particular behavior around whether returned promises are awaited.',
                        enum: ['error-handling-correctness-only'],
                    },
                    {
                        type: 'string',
                        description: 'In error-handling contexts, the rule enforces that returned promises must be awaited. In ordinary contexts, the rule enforces that returned promises _must not_ be awaited.',
                        enum: ['in-try-catch'],
                    },
                    {
                        type: 'string',
                        description: 'Disallows awaiting any returned promises.',
                        enum: ['never'],
                    },
                ],
            },
        ],
    },
    defaultOptions: ['in-try-catch'],
    create(context, [option]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const scopeInfoStack = [];
        function enterFunction(node) {
            scopeInfoStack.push({
                hasAsync: node.async,
                owningFunc: node,
            });
        }
        function exitFunction() {
            scopeInfoStack.pop();
        }
        function affectsExplicitResourceManagement(node) {
            // just need to determine if there is a `using` declaration in scope.
            let scope = context.sourceCode.getScope(node);
            const functionScope = scope.variableScope;
            while (true) {
                for (const variable of scope.variables) {
                    if (variable.defs.length !== 1) {
                        // This can't be the case for `using` or `await using` since it's
                        // an error to redeclare those more than once in the same scope,
                        // unlike, say, `var` declarations.
                        continue;
                    }
                    const declaration = variable.defs[0];
                    const declaratorNode = declaration.node;
                    const declarationNode = declaratorNode.parent;
                    // if it's a using/await using declaration, and it comes _before_ the
                    // node we're checking, it affects control flow for that node.
                    if (['await using', 'using'].includes(declarationNode.kind) &&
                        declaratorNode.range[1] < node.range[0]) {
                        return true;
                    }
                }
                if (scope === functionScope) {
                    // We've checked all the relevant scopes
                    break;
                }
                // This should always exist, since the rule should only be checking
                // contexts in which `return` statements are legal, which should always
                // be inside a function.
                scope = (0, util_1.nullThrows)(scope.upper, 'Expected parent scope to exist. return-await should only operate on return statements within functions');
            }
            return false;
        }
        /**
         * Tests whether a node is inside of an explicit error handling context
         * (try/catch/finally) in a way that throwing an exception will have an
         * impact on the program's control flow.
         */
        function affectsExplicitErrorHandling(node) {
            // If an error-handling block is followed by another error-handling block,
            // control flow is affected by whether promises in it are awaited or not.
            // Otherwise, we need to check recursively for nested try statements until
            // we get to the top level of a function or the program. If by then,
            // there's no offending error-handling blocks, it doesn't affect control
            // flow.
            const tryAncestorResult = findContainingTryStatement(node);
            if (tryAncestorResult == null) {
                return false;
            }
            const { block, tryStatement } = tryAncestorResult;
            switch (block) {
                case 'catch':
                    // Exceptions thrown in catch blocks followed by a finally block affect
                    // control flow.
                    if (tryStatement.finallyBlock != null) {
                        return true;
                    }
                    // Otherwise recurse.
                    return affectsExplicitErrorHandling(tryStatement);
                case 'finally':
                    return affectsExplicitErrorHandling(tryStatement);
                case 'try':
                    // Try blocks are always followed by either a catch or finally,
                    // so exceptions thrown here always affect control flow.
                    return true;
                default: {
                    const __never = block;
                    throw new Error(`Unexpected block type: ${String(__never)}`);
                }
            }
        }
        /**
         * A try _statement_ is the whole thing that encompasses try block,
         * catch clause, and finally block. This function finds the nearest
         * enclosing try statement (if present) for a given node, and reports which
         * part of the try statement the node is in.
         */
        function findContainingTryStatement(node) {
            let child = node;
            let ancestor = node.parent;
            while (ancestor && !ts.isFunctionLike(ancestor)) {
                if (ts.isTryStatement(ancestor)) {
                    let block;
                    if (child === ancestor.tryBlock) {
                        block = 'try';
                    }
                    else if (child === ancestor.catchClause) {
                        block = 'catch';
                    }
                    else if (child === ancestor.finallyBlock) {
                        block = 'finally';
                    }
                    return {
                        block: (0, util_1.nullThrows)(block, 'Child of a try statement must be a try block, catch clause, or finally block'),
                        tryStatement: ancestor,
                    };
                }
                child = ancestor;
                ancestor = ancestor.parent;
            }
            return undefined;
        }
        function removeAwait(fixer, node) {
            // Should always be an await node; but let's be safe.
            /* istanbul ignore if */ if (!(0, util_1.isAwaitExpression)(node)) {
                return null;
            }
            const awaitToken = context.sourceCode.getFirstToken(node, util_1.isAwaitKeyword);
            // Should always be the case; but let's be safe.
            /* istanbul ignore if */ if (!awaitToken) {
                return null;
            }
            const startAt = awaitToken.range[0];
            let endAt = awaitToken.range[1];
            // Also remove any extraneous whitespace after `await`, if there is any.
            const nextToken = context.sourceCode.getTokenAfter(awaitToken, {
                includeComments: true,
            });
            if (nextToken) {
                endAt = nextToken.range[0];
            }
            return fixer.removeRange([startAt, endAt]);
        }
        function insertAwait(fixer, node, isHighPrecedence) {
            if (isHighPrecedence) {
                return fixer.insertTextBefore(node, 'await ');
            }
            return [
                fixer.insertTextBefore(node, 'await ('),
                fixer.insertTextAfter(node, ')'),
            ];
        }
        function test(node, expression) {
            let child;
            const isAwait = ts.isAwaitExpression(expression);
            if (isAwait) {
                child = expression.getChildAt(1);
            }
            else {
                child = expression;
            }
            const type = checker.getTypeAtLocation(child);
            const certainty = (0, util_1.needsToBeAwaited)(checker, expression, type);
            // handle awaited _non_thenables
            if (certainty !== util_1.Awaitable.Always) {
                if (isAwait) {
                    if (certainty === util_1.Awaitable.May) {
                        return;
                    }
                    context.report({
                        node,
                        messageId: 'nonPromiseAwait',
                        fix: fixer => removeAwait(fixer, node),
                    });
                }
                return;
            }
            // At this point it's definitely a thenable.
            const affectsErrorHandling = affectsExplicitErrorHandling(expression) ||
                affectsExplicitResourceManagement(node);
            const useAutoFix = !affectsErrorHandling;
            const ruleConfiguration = getConfiguration(option);
            const shouldAwaitInCurrentContext = affectsErrorHandling
                ? ruleConfiguration.errorHandlingContext
                : ruleConfiguration.ordinaryContext;
            switch (shouldAwaitInCurrentContext) {
                case 'await':
                    if (!isAwait) {
                        context.report({
                            node,
                            messageId: 'requiredPromiseAwait',
                            ...(0, util_1.getFixOrSuggest)({
                                fixOrSuggest: useAutoFix ? 'fix' : 'suggest',
                                suggestion: {
                                    messageId: 'requiredPromiseAwaitSuggestion',
                                    fix: fixer => insertAwait(fixer, node, (0, util_1.isHigherPrecedenceThanAwait)(expression)),
                                },
                            }),
                        });
                    }
                    break;
                case "don't-care":
                    break;
                case 'no-await':
                    if (isAwait) {
                        context.report({
                            node,
                            messageId: 'disallowedPromiseAwait',
                            ...(0, util_1.getFixOrSuggest)({
                                fixOrSuggest: useAutoFix ? 'fix' : 'suggest',
                                suggestion: {
                                    messageId: 'disallowedPromiseAwaitSuggestion',
                                    fix: fixer => removeAwait(fixer, node),
                                },
                            }),
                        });
                    }
                    break;
            }
        }
        function findPossiblyReturnedNodes(node) {
            if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {
                return [
                    ...findPossiblyReturnedNodes(node.alternate),
                    ...findPossiblyReturnedNodes(node.consequent),
                ];
            }
            return [node];
        }
        return {
            ArrowFunctionExpression: enterFunction,
            'ArrowFunctionExpression:exit': exitFunction,
            FunctionDeclaration: enterFunction,
            'FunctionDeclaration:exit': exitFunction,
            FunctionExpression: enterFunction,
            'FunctionExpression:exit': exitFunction,
            // executes after less specific handler, so exitFunction is called
            'ArrowFunctionExpression[async = true]:exit'(node) {
                if (node.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
                    findPossiblyReturnedNodes(node.body).forEach(node => {
                        const tsNode = services.esTreeNodeToTSNodeMap.get(node);
                        test(node, tsNode);
                    });
                }
            },
            ReturnStatement(node) {
                const scopeInfo = scopeInfoStack.at(-1);
                if (!scopeInfo?.hasAsync || !node.argument) {
                    return;
                }
                findPossiblyReturnedNodes(node.argument).forEach(node => {
                    const tsNode = services.esTreeNodeToTSNodeMap.get(node);
                    test(node, tsNode);
                });
            },
        };
    },
});
function getConfiguration(option) {
    switch (option) {
        case 'always':
            return {
                errorHandlingContext: 'await',
                ordinaryContext: 'await',
            };
        case 'error-handling-correctness-only':
            return {
                errorHandlingContext: 'await',
                ordinaryContext: "don't-care",
            };
        case 'in-try-catch':
            return {
                errorHandlingContext: 'await',
                ordinaryContext: 'no-await',
            };
        case 'never':
            return {
                errorHandlingContext: 'no-await',
                ordinaryContext: 'no-await',
            };
    }
}


--------------------------------------------------------------------------------
FILE: sort-type-constituents.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        caseSensitive?: boolean;
        checkIntersections?: boolean;
        checkUnions?: boolean;
        groupOrder?: string[];
    }
];
export type MessageIds = 'notSorted' | 'notSortedNamed' | 'suggestFix';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: sort-type-constituents.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
var Group;
(function (Group) {
    Group["conditional"] = "conditional";
    Group["function"] = "function";
    Group["import"] = "import";
    Group["intersection"] = "intersection";
    Group["keyword"] = "keyword";
    Group["nullish"] = "nullish";
    Group["literal"] = "literal";
    Group["named"] = "named";
    Group["object"] = "object";
    Group["operator"] = "operator";
    Group["tuple"] = "tuple";
    Group["union"] = "union";
})(Group || (Group = {}));
function getGroup(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSConditionalType:
            return Group.conditional;
        case utils_1.AST_NODE_TYPES.TSConstructorType:
        case utils_1.AST_NODE_TYPES.TSFunctionType:
            return Group.function;
        case utils_1.AST_NODE_TYPES.TSImportType:
            return Group.import;
        case utils_1.AST_NODE_TYPES.TSIntersectionType:
            return Group.intersection;
        case utils_1.AST_NODE_TYPES.TSAnyKeyword:
        case utils_1.AST_NODE_TYPES.TSBigIntKeyword:
        case utils_1.AST_NODE_TYPES.TSBooleanKeyword:
        case utils_1.AST_NODE_TYPES.TSNeverKeyword:
        case utils_1.AST_NODE_TYPES.TSNumberKeyword:
        case utils_1.AST_NODE_TYPES.TSObjectKeyword:
        case utils_1.AST_NODE_TYPES.TSStringKeyword:
        case utils_1.AST_NODE_TYPES.TSSymbolKeyword:
        case utils_1.AST_NODE_TYPES.TSThisType:
        case utils_1.AST_NODE_TYPES.TSUnknownKeyword:
        case utils_1.AST_NODE_TYPES.TSIntrinsicKeyword:
            return Group.keyword;
        case utils_1.AST_NODE_TYPES.TSNullKeyword:
        case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
        case utils_1.AST_NODE_TYPES.TSVoidKeyword:
            return Group.nullish;
        case utils_1.AST_NODE_TYPES.TSLiteralType:
        case utils_1.AST_NODE_TYPES.TSTemplateLiteralType:
            return Group.literal;
        case utils_1.AST_NODE_TYPES.TSArrayType:
        case utils_1.AST_NODE_TYPES.TSIndexedAccessType:
        case utils_1.AST_NODE_TYPES.TSInferType:
        case utils_1.AST_NODE_TYPES.TSTypeReference:
        case utils_1.AST_NODE_TYPES.TSQualifiedName:
            return Group.named;
        case utils_1.AST_NODE_TYPES.TSMappedType:
        case utils_1.AST_NODE_TYPES.TSTypeLiteral:
            return Group.object;
        case utils_1.AST_NODE_TYPES.TSTypeOperator:
        case utils_1.AST_NODE_TYPES.TSTypeQuery:
            return Group.operator;
        case utils_1.AST_NODE_TYPES.TSTupleType:
            return Group.tuple;
        case utils_1.AST_NODE_TYPES.TSUnionType:
            return Group.union;
        // These types should never occur as part of a union/intersection
        case utils_1.AST_NODE_TYPES.TSAbstractKeyword:
        case utils_1.AST_NODE_TYPES.TSAsyncKeyword:
        case utils_1.AST_NODE_TYPES.TSDeclareKeyword:
        case utils_1.AST_NODE_TYPES.TSExportKeyword:
        case utils_1.AST_NODE_TYPES.TSNamedTupleMember:
        case utils_1.AST_NODE_TYPES.TSOptionalType:
        case utils_1.AST_NODE_TYPES.TSPrivateKeyword:
        case utils_1.AST_NODE_TYPES.TSProtectedKeyword:
        case utils_1.AST_NODE_TYPES.TSPublicKeyword:
        case utils_1.AST_NODE_TYPES.TSReadonlyKeyword:
        case utils_1.AST_NODE_TYPES.TSRestType:
        case utils_1.AST_NODE_TYPES.TSStaticKeyword:
        case utils_1.AST_NODE_TYPES.TSTypePredicate:
            /* istanbul ignore next */
            throw new Error(`Unexpected Type ${node.type}`);
    }
}
function caseSensitiveSort(a, b) {
    if (a < b) {
        return -1;
    }
    if (a > b) {
        return 1;
    }
    return 0;
}
exports.default = (0, util_1.createRule)({
    name: 'sort-type-constituents',
    meta: {
        type: 'suggestion',
        deprecated: {
            deprecatedSince: '7.13.0',
            replacedBy: [
                {
                    plugin: {
                        name: 'eslint-plugin-perfectionist',
                        url: 'https://perfectionist.dev',
                    },
                    rule: {
                        name: 'perfectionist/sort-intersection-types',
                        url: 'https://perfectionist.dev/rules/sort-intersection-types',
                    },
                },
                {
                    plugin: {
                        name: 'eslint-plugin-perfectionist',
                        url: 'https://perfectionist.dev',
                    },
                    rule: {
                        name: 'perfectionist/sort-union-types',
                        url: 'https://perfectionist.dev/rules/sort-union-types',
                    },
                },
            ],
            url: 'https://github.com/typescript-eslint/typescript-eslint/pull/9253',
        },
        docs: {
            description: 'Enforce constituents of a type union/intersection to be sorted alphabetically',
        },
        fixable: 'code',
        hasSuggestions: true,
        messages: {
            notSorted: '{{type}} type constituents must be sorted.',
            notSortedNamed: '{{type}} type {{name}} constituents must be sorted.',
            suggestFix: 'Sort constituents of type (removes all comments).',
        },
        replacedBy: [
            'perfectionist/sort-intersection-types',
            'perfectionist/sort-union-types',
        ],
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    caseSensitive: {
                        type: 'boolean',
                        description: 'Whether to sort using case sensitive string comparisons.',
                    },
                    checkIntersections: {
                        type: 'boolean',
                        description: 'Whether to check intersection types (`&`).',
                    },
                    checkUnions: {
                        type: 'boolean',
                        description: 'Whether to check union types (`|`).',
                    },
                    groupOrder: {
                        type: 'array',
                        description: 'Ordering of the groups.',
                        items: {
                            type: 'string',
                            enum: (0, util_1.getEnumNames)(Group),
                        },
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            caseSensitive: false,
            checkIntersections: true,
            checkUnions: true,
            groupOrder: [
                Group.named,
                Group.keyword,
                Group.operator,
                Group.literal,
                Group.function,
                Group.import,
                Group.conditional,
                Group.object,
                Group.tuple,
                Group.intersection,
                Group.union,
                Group.nullish,
            ],
        },
    ],
    create(context, [{ caseSensitive, checkIntersections, checkUnions, groupOrder }]) {
        const collator = new Intl.Collator('en', {
            numeric: true,
            sensitivity: 'base',
        });
        function checkSorting(node) {
            const sourceOrder = node.types.map(type => {
                const group = groupOrder?.indexOf(getGroup(type)) ?? -1;
                return {
                    node: type,
                    group: group === -1 ? Number.MAX_SAFE_INTEGER : group,
                    text: context.sourceCode.getText(type),
                };
            });
            const expectedOrder = [...sourceOrder].sort((a, b) => {
                if (a.group !== b.group) {
                    return a.group - b.group;
                }
                if (caseSensitive) {
                    return caseSensitiveSort(a.text, b.text);
                }
                return (collator.compare(a.text, b.text) ||
                    (a.text < b.text ? -1 : a.text > b.text ? 1 : 0));
            });
            const hasComments = node.types.some(type => {
                const count = context.sourceCode.getCommentsBefore(type).length +
                    context.sourceCode.getCommentsAfter(type).length;
                return count > 0;
            });
            for (let i = 0; i < expectedOrder.length; i += 1) {
                if (expectedOrder[i].node !== sourceOrder[i].node) {
                    let messageId = 'notSorted';
                    const data = {
                        name: '',
                        type: node.type === utils_1.AST_NODE_TYPES.TSIntersectionType
                            ? 'Intersection'
                            : 'Union',
                    };
                    if (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {
                        messageId = 'notSortedNamed';
                        data.name = node.parent.id.name;
                    }
                    const fix = fixer => {
                        const sorted = expectedOrder
                            .map(t => (0, util_1.typeNodeRequiresParentheses)(t.node, t.text) ||
                            (node.type === utils_1.AST_NODE_TYPES.TSIntersectionType &&
                                t.node.type === utils_1.AST_NODE_TYPES.TSUnionType)
                            ? `(${t.text})`
                            : t.text)
                            .join(node.type === utils_1.AST_NODE_TYPES.TSIntersectionType ? ' & ' : ' | ');
                        return fixer.replaceText(node, sorted);
                    };
                    return context.report({
                        node,
                        messageId,
                        data,
                        // don't autofix if any of the types have leading/trailing comments
                        // the logic for preserving them correctly is a pain - we may implement this later
                        ...(hasComments
                            ? {
                                suggest: [
                                    {
                                        messageId: 'suggestFix',
                                        fix,
                                    },
                                ],
                            }
                            : { fix }),
                    });
                }
            }
        }
        return {
            ...(checkIntersections && {
                TSIntersectionType(node) {
                    checkSorting(node);
                },
            }),
            ...(checkUnions && {
                TSUnionType(node) {
                    checkSorting(node);
                },
            }),
        };
    },
});


--------------------------------------------------------------------------------
FILE: strict-boolean-expressions.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        allowAny?: boolean;
        allowNullableBoolean?: boolean;
        allowNullableEnum?: boolean;
        allowNullableNumber?: boolean;
        allowNullableObject?: boolean;
        allowNullableString?: boolean;
        allowNumber?: boolean;
        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing?: boolean;
        allowString?: boolean;
    }
];
type ConditionErrorMessageId = 'conditionErrorAny' | 'conditionErrorNullableBoolean' | 'conditionErrorNullableEnum' | 'conditionErrorNullableNumber' | 'conditionErrorNullableObject' | 'conditionErrorNullableString' | 'conditionErrorNullish' | 'conditionErrorNumber' | 'conditionErrorObject' | 'conditionErrorOther' | 'conditionErrorString';
export type MessageId = 'conditionFixCastBoolean' | 'conditionFixCompareArrayLengthNonzero' | 'conditionFixCompareArrayLengthZero' | 'conditionFixCompareEmptyString' | 'conditionFixCompareFalse' | 'conditionFixCompareNaN' | 'conditionFixCompareNullish' | 'conditionFixCompareStringLength' | 'conditionFixCompareTrue' | 'conditionFixCompareZero' | 'conditionFixDefaultEmptyString' | 'conditionFixDefaultFalse' | 'conditionFixDefaultZero' | 'explicitBooleanReturnType' | 'noStrictNullCheck' | 'predicateCannotBeAsync' | ConditionErrorMessageId;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageId, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: strict-boolean-expressions.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const assertionFunctionUtils_1 = require("../util/assertionFunctionUtils");
exports.default = (0, util_1.createRule)({
    name: 'strict-boolean-expressions',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow certain types in boolean expressions',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            conditionErrorAny: 'Unexpected any value in {{context}}. ' +
                'An explicit comparison or type conversion is required.',
            conditionErrorNullableBoolean: 'Unexpected nullable boolean value in {{context}}. ' +
                'Please handle the nullish case explicitly.',
            conditionErrorNullableEnum: 'Unexpected nullable enum value in {{context}}. ' +
                'Please handle the nullish/zero/NaN cases explicitly.',
            conditionErrorNullableNumber: 'Unexpected nullable number value in {{context}}. ' +
                'Please handle the nullish/zero/NaN cases explicitly.',
            conditionErrorNullableObject: 'Unexpected nullable object value in {{context}}. ' +
                'An explicit null check is required.',
            conditionErrorNullableString: 'Unexpected nullable string value in {{context}}. ' +
                'Please handle the nullish/empty cases explicitly.',
            conditionErrorNullish: 'Unexpected nullish value in conditional. ' +
                'The condition is always false.',
            conditionErrorNumber: 'Unexpected number value in {{context}}. ' +
                'An explicit zero/NaN check is required.',
            conditionErrorObject: 'Unexpected object value in {{context}}. ' +
                'The condition is always true.',
            conditionErrorOther: 'Unexpected value in conditional. ' +
                'A boolean expression is required.',
            conditionErrorString: 'Unexpected string value in {{context}}. ' +
                'An explicit empty string check is required.',
            conditionFixCastBoolean: 'Explicitly convert value to a boolean (`Boolean(value)`)',
            conditionFixCompareArrayLengthNonzero: "Change condition to check array's length (`value.length > 0`)",
            conditionFixCompareArrayLengthZero: "Change condition to check array's length (`value.length === 0`)",
            conditionFixCompareEmptyString: 'Change condition to check for empty string (`value !== ""`)',
            conditionFixCompareFalse: 'Change condition to check if false (`value === false`)',
            conditionFixCompareNaN: 'Change condition to check for NaN (`!Number.isNaN(value)`)',
            conditionFixCompareNullish: 'Change condition to check for null/undefined (`value != null`)',
            conditionFixCompareStringLength: "Change condition to check string's length (`value.length !== 0`)",
            conditionFixCompareTrue: 'Change condition to check if true (`value === true`)',
            conditionFixCompareZero: 'Change condition to check for 0 (`value !== 0`)',
            conditionFixDefaultEmptyString: 'Explicitly treat nullish value the same as an empty string (`value ?? ""`)',
            conditionFixDefaultFalse: 'Explicitly treat nullish value the same as false (`value ?? false`)',
            conditionFixDefaultZero: 'Explicitly treat nullish value the same as 0 (`value ?? 0`)',
            explicitBooleanReturnType: 'Add an explicit `boolean` return type annotation.',
            noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',
            predicateCannotBeAsync: "Predicate function should not be 'async'; expected a boolean return type.",
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowAny: {
                        type: 'boolean',
                        description: 'Whether to allow `any`s in a boolean context.',
                    },
                    allowNullableBoolean: {
                        type: 'boolean',
                        description: 'Whether to allow nullable `boolean`s in a boolean context.',
                    },
                    allowNullableEnum: {
                        type: 'boolean',
                        description: 'Whether to allow nullable `enum`s in a boolean context.',
                    },
                    allowNullableNumber: {
                        type: 'boolean',
                        description: 'Whether to allow nullable `number`s in a boolean context.',
                    },
                    allowNullableObject: {
                        type: 'boolean',
                        description: 'Whether to allow nullable `object`s, `symbol`s, and functions in a boolean context.',
                    },
                    allowNullableString: {
                        type: 'boolean',
                        description: 'Whether to allow nullable `string`s in a boolean context.',
                    },
                    allowNumber: {
                        type: 'boolean',
                        description: 'Whether to allow `number`s in a boolean context.',
                    },
                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {
                        type: 'boolean',
                        description: 'Unless this is set to `true`, the rule will error on every file whose `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or `strict`) set to `true`.',
                    },
                    allowString: {
                        type: 'boolean',
                        description: 'Whether to allow `string`s in a boolean context.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowAny: false,
            allowNullableBoolean: false,
            allowNullableEnum: false,
            allowNullableNumber: false,
            allowNullableObject: true,
            allowNullableString: false,
            allowNumber: true,
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,
            allowString: true,
        },
    ],
    create(context, [options]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const compilerOptions = services.program.getCompilerOptions();
        const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');
        if (!isStrictNullChecks &&
            options.allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {
            context.report({
                loc: {
                    start: { column: 0, line: 0 },
                    end: { column: 0, line: 0 },
                },
                messageId: 'noStrictNullCheck',
            });
        }
        const traversedNodes = new Set();
        return {
            CallExpression: traverseCallExpression,
            ConditionalExpression: traverseTestExpression,
            DoWhileStatement: traverseTestExpression,
            ForStatement: traverseTestExpression,
            IfStatement: traverseTestExpression,
            'LogicalExpression[operator!="??"]': traverseLogicalExpression,
            'UnaryExpression[operator="!"]': traverseUnaryLogicalExpression,
            WhileStatement: traverseTestExpression,
        };
        /**
         * Inspects condition of a test expression. (`if`, `while`, `for`, etc.)
         */
        function traverseTestExpression(node) {
            if (node.test == null) {
                return;
            }
            traverseNode(node.test, true);
        }
        /**
         * Inspects the argument of a unary logical expression (`!`).
         */
        function traverseUnaryLogicalExpression(node) {
            traverseNode(node.argument, true);
        }
        /**
         * Inspects the arguments of a logical expression (`&&`, `||`).
         *
         * If the logical expression is a descendant of a test expression,
         * the `isCondition` flag should be set to true.
         * Otherwise, if the logical expression is there on it's own,
         * it's used for control flow and is not a condition itself.
         */
        function traverseLogicalExpression(node, isCondition = false) {
            // left argument is always treated as a condition
            traverseNode(node.left, true);
            // if the logical expression is used for control flow,
            // then its right argument is used for its side effects only
            traverseNode(node.right, isCondition);
        }
        function traverseCallExpression(node) {
            const assertedArgument = (0, assertionFunctionUtils_1.findTruthinessAssertedArgument)(services, node);
            if (assertedArgument != null) {
                traverseNode(assertedArgument, true);
            }
            if ((0, util_1.isArrayMethodCallWithPredicate)(context, services, node)) {
                const predicate = node.arguments.at(0);
                if (predicate) {
                    checkArrayMethodCallPredicate(predicate);
                }
            }
        }
        /**
         * Dedicated function to check array method predicate calls. Reports predicate
         * arguments that don't return a boolean value.
         */
        function checkArrayMethodCallPredicate(predicateNode) {
            const isFunctionExpression = utils_1.ASTUtils.isFunction(predicateNode);
            // custom message for accidental `async` function expressions
            if (isFunctionExpression && predicateNode.async) {
                return context.report({
                    node: predicateNode,
                    messageId: 'predicateCannotBeAsync',
                });
            }
            const returnTypes = services
                .getTypeAtLocation(predicateNode)
                .getCallSignatures()
                .map(signature => {
                const type = signature.getReturnType();
                if (tsutils.isTypeParameter(type)) {
                    return checker.getBaseConstraintOfType(type) ?? type;
                }
                return type;
            });
            const flattenTypes = [
                ...new Set(returnTypes.flatMap(type => tsutils.unionConstituents(type))),
            ];
            const types = inspectVariantTypes(flattenTypes);
            const reportType = determineReportType(types);
            if (reportType == null) {
                return;
            }
            const suggestions = [];
            if (isFunctionExpression &&
                predicateNode.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
                suggestions.push(...getSuggestionsForConditionError(predicateNode.body, reportType));
            }
            if (isFunctionExpression && !predicateNode.returnType) {
                suggestions.push({
                    messageId: 'explicitBooleanReturnType',
                    fix: fixer => {
                        if (predicateNode.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&
                            (0, util_1.isParenlessArrowFunction)(predicateNode, context.sourceCode)) {
                            return [
                                fixer.insertTextBefore(predicateNode.params[0], '('),
                                fixer.insertTextAfter(predicateNode.params[0], '): boolean'),
                            ];
                        }
                        if (predicateNode.params.length === 0) {
                            const closingBracket = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(predicateNode, token => token.value === ')'), 'function expression has to have a closing parenthesis.');
                            return fixer.insertTextAfter(closingBracket, ': boolean');
                        }
                        const lastClosingParenthesis = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(predicateNode.params[predicateNode.params.length - 1], token => token.value === ')'), 'function expression has to have a closing parenthesis.');
                        return fixer.insertTextAfter(lastClosingParenthesis, ': boolean');
                    },
                });
            }
            return context.report({
                node: predicateNode,
                messageId: reportType,
                data: {
                    context: 'array predicate return type',
                },
                suggest: suggestions,
            });
        }
        /**
         * Inspects any node.
         *
         * If it's a logical expression then it recursively traverses its arguments.
         * If it's any other kind of node then it's type is finally checked against the rule,
         * unless `isCondition` flag is set to false, in which case
         * it's assumed to be used for side effects only and is skipped.
         */
        function traverseNode(node, isCondition) {
            // prevent checking the same node multiple times
            if (traversedNodes.has(node)) {
                return;
            }
            traversedNodes.add(node);
            // for logical operator, we check its operands
            if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression &&
                node.operator !== '??') {
                traverseLogicalExpression(node, isCondition);
                return;
            }
            // skip if node is not a condition
            if (!isCondition) {
                return;
            }
            checkNode(node);
        }
        function determineReportType(types) {
            const is = (...wantedTypes) => types.size === wantedTypes.length &&
                wantedTypes.every(type => types.has(type));
            // boolean
            if (is('boolean') || is('truthy boolean')) {
                // boolean is always ok
                return undefined;
            }
            // never
            if (is('never')) {
                // never is always okay
                return undefined;
            }
            // nullish
            if (is('nullish')) {
                // condition is always false
                return 'conditionErrorNullish';
            }
            // Known edge case: boolean `true` and nullish values are always valid boolean expressions
            if (is('nullish', 'truthy boolean')) {
                return;
            }
            // nullable boolean
            if (is('nullish', 'boolean')) {
                return !options.allowNullableBoolean
                    ? 'conditionErrorNullableBoolean'
                    : undefined;
            }
            // Known edge case: truthy primitives and nullish values are always valid boolean expressions
            if ((options.allowNumber && is('nullish', 'truthy number')) ||
                (options.allowString && is('nullish', 'truthy string'))) {
                return;
            }
            // string
            if (is('string') || is('truthy string')) {
                return !options.allowString ? 'conditionErrorString' : undefined;
            }
            // nullable string
            if (is('nullish', 'string')) {
                return !options.allowNullableString
                    ? 'conditionErrorNullableString'
                    : undefined;
            }
            // number
            if (is('number') || is('truthy number')) {
                return !options.allowNumber ? 'conditionErrorNumber' : undefined;
            }
            // nullable number
            if (is('nullish', 'number')) {
                return !options.allowNullableNumber
                    ? 'conditionErrorNullableNumber'
                    : undefined;
            }
            // object
            if (is('object')) {
                return 'conditionErrorObject';
            }
            // nullable object
            if (is('nullish', 'object')) {
                return !options.allowNullableObject
                    ? 'conditionErrorNullableObject'
                    : undefined;
            }
            // nullable enum
            if (is('nullish', 'number', 'enum') ||
                is('nullish', 'string', 'enum') ||
                is('nullish', 'truthy number', 'enum') ||
                is('nullish', 'truthy string', 'enum') ||
                // mixed enums
                is('nullish', 'truthy number', 'truthy string', 'enum') ||
                is('nullish', 'truthy number', 'string', 'enum') ||
                is('nullish', 'truthy string', 'number', 'enum') ||
                is('nullish', 'number', 'string', 'enum')) {
                return !options.allowNullableEnum
                    ? 'conditionErrorNullableEnum'
                    : undefined;
            }
            // any
            if (is('any')) {
                return !options.allowAny ? 'conditionErrorAny' : undefined;
            }
            return 'conditionErrorOther';
        }
        function getSuggestionsForConditionError(node, conditionError) {
            switch (conditionError) {
                case 'conditionErrorAny':
                    return [
                        {
                            messageId: 'conditionFixCastBoolean',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `Boolean(${code})`,
                            }),
                        },
                    ];
                case 'conditionErrorNullableBoolean':
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!nullableBoolean)
                        return [
                            {
                                messageId: 'conditionFixDefaultFalse',
                                fix: (0, util_1.getWrappingFixer)({
                                    node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} ?? false`,
                                }),
                            },
                            {
                                messageId: 'conditionFixCompareFalse',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} === false`,
                                }),
                            },
                        ];
                    }
                    // if (nullableBoolean)
                    return [
                        {
                            messageId: 'conditionFixDefaultFalse',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} ?? false`,
                            }),
                        },
                        {
                            messageId: 'conditionFixCompareTrue',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} === true`,
                            }),
                        },
                    ];
                case 'conditionErrorNullableEnum':
                    if (isLogicalNegationExpression(node.parent)) {
                        return [
                            {
                                messageId: 'conditionFixCompareNullish',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} == null`,
                                }),
                            },
                        ];
                    }
                    return [
                        {
                            messageId: 'conditionFixCompareNullish',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} != null`,
                            }),
                        },
                    ];
                case 'conditionErrorNullableNumber':
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!nullableNumber)
                        return [
                            {
                                messageId: 'conditionFixCompareNullish',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} == null`,
                                }),
                            },
                            {
                                messageId: 'conditionFixDefaultZero',
                                fix: (0, util_1.getWrappingFixer)({
                                    node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} ?? 0`,
                                }),
                            },
                            {
                                messageId: 'conditionFixCastBoolean',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `!Boolean(${code})`,
                                }),
                            },
                        ];
                    }
                    // if (nullableNumber)
                    return [
                        {
                            messageId: 'conditionFixCompareNullish',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} != null`,
                            }),
                        },
                        {
                            messageId: 'conditionFixDefaultZero',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} ?? 0`,
                            }),
                        },
                        {
                            messageId: 'conditionFixCastBoolean',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `Boolean(${code})`,
                            }),
                        },
                    ];
                case 'conditionErrorNullableObject':
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!nullableObject)
                        return [
                            {
                                messageId: 'conditionFixCompareNullish',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} == null`,
                                }),
                            },
                        ];
                    }
                    // if (nullableObject)
                    return [
                        {
                            messageId: 'conditionFixCompareNullish',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} != null`,
                            }),
                        },
                    ];
                case 'conditionErrorNullableString':
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!nullableString)
                        return [
                            {
                                messageId: 'conditionFixCompareNullish',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} == null`,
                                }),
                            },
                            {
                                messageId: 'conditionFixDefaultEmptyString',
                                fix: (0, util_1.getWrappingFixer)({
                                    node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} ?? ""`,
                                }),
                            },
                            {
                                messageId: 'conditionFixCastBoolean',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `!Boolean(${code})`,
                                }),
                            },
                        ];
                    }
                    // if (nullableString)
                    return [
                        {
                            messageId: 'conditionFixCompareNullish',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} != null`,
                            }),
                        },
                        {
                            messageId: 'conditionFixDefaultEmptyString',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} ?? ""`,
                            }),
                        },
                        {
                            messageId: 'conditionFixCastBoolean',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `Boolean(${code})`,
                            }),
                        },
                    ];
                case 'conditionErrorNumber':
                    if (isArrayLengthExpression(node, checker, services)) {
                        if (isLogicalNegationExpression(node.parent)) {
                            // if (!array.length)
                            return [
                                {
                                    messageId: 'conditionFixCompareArrayLengthZero',
                                    fix: (0, util_1.getWrappingFixer)({
                                        node: node.parent,
                                        innerNode: node,
                                        sourceCode: context.sourceCode,
                                        wrap: code => `${code} === 0`,
                                    }),
                                },
                            ];
                        }
                        // if (array.length)
                        return [
                            {
                                messageId: 'conditionFixCompareArrayLengthNonzero',
                                fix: (0, util_1.getWrappingFixer)({
                                    node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} > 0`,
                                }),
                            },
                        ];
                    }
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!number)
                        return [
                            {
                                messageId: 'conditionFixCompareZero',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    // TODO: we have to compare to 0n if the type is bigint
                                    wrap: code => `${code} === 0`,
                                }),
                            },
                            {
                                // TODO: don't suggest this for bigint because it can't be NaN
                                messageId: 'conditionFixCompareNaN',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `Number.isNaN(${code})`,
                                }),
                            },
                            {
                                messageId: 'conditionFixCastBoolean',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `!Boolean(${code})`,
                                }),
                            },
                        ];
                    }
                    // if (number)
                    return [
                        {
                            messageId: 'conditionFixCompareZero',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} !== 0`,
                            }),
                        },
                        {
                            messageId: 'conditionFixCompareNaN',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `!Number.isNaN(${code})`,
                            }),
                        },
                        {
                            messageId: 'conditionFixCastBoolean',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `Boolean(${code})`,
                            }),
                        },
                    ];
                case 'conditionErrorString':
                    if (isLogicalNegationExpression(node.parent)) {
                        // if (!string)
                        return [
                            {
                                messageId: 'conditionFixCompareStringLength',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code}.length === 0`,
                                }),
                            },
                            {
                                messageId: 'conditionFixCompareEmptyString',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `${code} === ""`,
                                }),
                            },
                            {
                                messageId: 'conditionFixCastBoolean',
                                fix: (0, util_1.getWrappingFixer)({
                                    node: node.parent,
                                    innerNode: node,
                                    sourceCode: context.sourceCode,
                                    wrap: code => `!Boolean(${code})`,
                                }),
                            },
                        ];
                    }
                    // if (string)
                    return [
                        {
                            messageId: 'conditionFixCompareStringLength',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code}.length > 0`,
                            }),
                        },
                        {
                            messageId: 'conditionFixCompareEmptyString',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `${code} !== ""`,
                            }),
                        },
                        {
                            messageId: 'conditionFixCastBoolean',
                            fix: (0, util_1.getWrappingFixer)({
                                node,
                                sourceCode: context.sourceCode,
                                wrap: code => `Boolean(${code})`,
                            }),
                        },
                    ];
                case 'conditionErrorObject':
                case 'conditionErrorNullish':
                case 'conditionErrorOther':
                    return [];
                default:
                    conditionError;
                    throw new Error('Unreachable');
            }
        }
        /**
         * This function does the actual type check on a node.
         * It analyzes the type of a node and checks if it is allowed in a boolean context.
         */
        function checkNode(node) {
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            const types = inspectVariantTypes(tsutils.unionConstituents(type));
            const reportType = determineReportType(types);
            if (reportType != null) {
                context.report({
                    node,
                    messageId: reportType,
                    data: {
                        context: 'conditional',
                    },
                    suggest: getSuggestionsForConditionError(node, reportType),
                });
            }
        }
        /**
         * Check union variants for the types we care about
         */
        function inspectVariantTypes(types) {
            const variantTypes = new Set();
            if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike))) {
                variantTypes.add('nullish');
            }
            const booleans = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.BooleanLike));
            // If incoming type is either "true" or "false", there will be one type
            // object with intrinsicName set accordingly
            // If incoming type is boolean, there will be two type objects with
            // intrinsicName set "true" and "false" each because of ts-api-utils.unionConstituents()
            if (booleans.length === 1) {
                variantTypes.add(tsutils.isTrueLiteralType(booleans[0]) ? 'truthy boolean' : 'boolean');
            }
            else if (booleans.length === 2) {
                variantTypes.add('boolean');
            }
            const strings = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.StringLike));
            if (strings.length) {
                if (strings.every(type => type.isStringLiteral() && type.value !== '')) {
                    variantTypes.add('truthy string');
                }
                else {
                    variantTypes.add('string');
                }
            }
            const numbers = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike));
            if (numbers.length) {
                if (numbers.every(type => type.isNumberLiteral() && type.value !== 0)) {
                    variantTypes.add('truthy number');
                }
                else {
                    variantTypes.add('number');
                }
            }
            if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLike))) {
                variantTypes.add('enum');
            }
            if (types.some(type => !tsutils.isTypeFlagSet(type, ts.TypeFlags.Null |
                ts.TypeFlags.Undefined |
                ts.TypeFlags.VoidLike |
                ts.TypeFlags.BooleanLike |
                ts.TypeFlags.StringLike |
                ts.TypeFlags.NumberLike |
                ts.TypeFlags.BigIntLike |
                ts.TypeFlags.TypeParameter |
                ts.TypeFlags.Any |
                ts.TypeFlags.Unknown |
                ts.TypeFlags.Never))) {
                variantTypes.add(types.some(isBrandedBoolean) ? 'boolean' : 'object');
            }
            if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.TypeParameter |
                ts.TypeFlags.Any |
                ts.TypeFlags.Unknown))) {
                variantTypes.add('any');
            }
            if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Never))) {
                variantTypes.add('never');
            }
            return variantTypes;
        }
    },
});
function isLogicalNegationExpression(node) {
    return node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '!';
}
function isArrayLengthExpression(node, typeChecker, services) {
    if (node.type !== utils_1.AST_NODE_TYPES.MemberExpression) {
        return false;
    }
    if (node.computed) {
        return false;
    }
    if (node.property.name !== 'length') {
        return false;
    }
    const objectType = (0, util_1.getConstrainedTypeAtLocation)(services, node.object);
    return (0, util_1.isTypeArrayTypeOrUnionOfArrayTypes)(objectType, typeChecker);
}
/**
 * Verify is the type is a branded boolean (e.g. `type Foo = boolean & { __brand: 'Foo' }`)
 *
 * @param type The type checked
 */
function isBrandedBoolean(type) {
    return (type.isIntersection() &&
        type.types.some(childType => isBooleanType(childType)));
}
function isBooleanType(expressionType) {
    return tsutils.isTypeFlagSet(expressionType, ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLiteral);
}


--------------------------------------------------------------------------------
FILE: strict-void-return.d.ts
--------------------------------------------------------------------------------

type Options = [
    {
        allowReturnAny?: boolean;
    }
];
type MessageId = `asyncFunc` | `nonVoidFunc` | `nonVoidReturn`;
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageId, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: strict-void-return.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util = __importStar(require("../util"));
exports.default = util.createRule({
    name: 'strict-void-return',
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallow passing a value-returning function in a position accepting a void function',
            requiresTypeChecking: true,
        },
        messages: {
            asyncFunc: 'Async function used in a context where a void function is expected.',
            nonVoidFunc: 'Value-returning function used in a context where a void function is expected.',
            nonVoidReturn: 'Value returned in a context where a void return is expected.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowReturnAny: {
                        type: 'boolean',
                        description: 'Whether to allow functions returning `any` to be used in place expecting a `void` function.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowReturnAny: false,
        },
    ],
    create(context, [options]) {
        const sourceCode = context.sourceCode;
        const parserServices = util.getParserServices(context);
        const checker = parserServices.program.getTypeChecker();
        return {
            ArrayExpression: (node) => {
                for (const elemNode of node.elements) {
                    if (elemNode != null &&
                        elemNode.type !== utils_1.AST_NODE_TYPES.SpreadElement) {
                        checkExpressionNode(elemNode);
                    }
                }
            },
            ArrowFunctionExpression: (node) => {
                if (node.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
                    checkExpressionNode(node.body);
                }
            },
            AssignmentExpression: (node) => {
                checkExpressionNode(node.right); // should ignore operators like `+=` or `-=` automatically
            },
            'CallExpression, NewExpression': checkFunctionCallNode,
            JSXAttribute: (node) => {
                if (node.value?.type === utils_1.AST_NODE_TYPES.JSXExpressionContainer &&
                    node.value.expression.type !== utils_1.AST_NODE_TYPES.JSXEmptyExpression) {
                    checkExpressionNode(node.value.expression);
                }
            },
            MethodDefinition: checkClassMethodNode,
            ObjectExpression: (node) => {
                for (const propNode of node.properties) {
                    if (propNode.type !== utils_1.AST_NODE_TYPES.SpreadElement) {
                        checkObjectPropertyNode(propNode);
                    }
                }
            },
            PropertyDefinition: checkClassPropertyNode,
            ReturnStatement: (node) => {
                if (node.argument != null) {
                    checkExpressionNode(node.argument);
                }
            },
            VariableDeclarator: (node) => {
                if (node.init != null) {
                    checkExpressionNode(node.init);
                }
            },
        };
        function isVoidReturningFunctionType(type) {
            const returnTypes = tsutils
                .getCallSignaturesOfType(type)
                .flatMap(signature => tsutils.unionConstituents(signature.getReturnType()));
            return (returnTypes.length > 0 &&
                returnTypes.every(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Void)));
        }
        /**
         * Finds errors in any expression node.
         *
         * Compares the type of the node against the contextual (expected) type.
         *
         * @returns `true` if the expected type was void function.
         */
        function checkExpressionNode(node) {
            const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
            const expectedType = checker.getContextualType(tsNode);
            if (expectedType != null && isVoidReturningFunctionType(expectedType)) {
                reportIfNonVoidFunction(node);
                return true;
            }
            return false;
        }
        /**
         * Finds errors in function calls.
         *
         * When checking arguments, we also manually figure out the argument types
         * by iterating over all the function signatures.
         * Thanks to this, we can find arguments like `(() => void) | (() => any)`
         * and treat them as void too.
         * This is done to also support checking functions like `addEventListener`
         * which have overloads where one callback returns any.
         *
         * Implementation mostly based on no-misused-promises,
         * which does this to find `(() => void) | (() => NotThenable)`
         * and report them too.
         */
        function checkFunctionCallNode(callNode) {
            const callTsNode = parserServices.esTreeNodeToTSNodeMap.get(callNode);
            const funcType = checker.getTypeAtLocation(callTsNode.expression);
            const funcSignatures = tsutils
                .unionConstituents(funcType)
                .flatMap(type => ts.isCallExpression(callTsNode)
                ? type.getCallSignatures()
                : type.getConstructSignatures());
            for (const [argIdx, argNode] of callNode.arguments.entries()) {
                if (argNode.type === utils_1.AST_NODE_TYPES.SpreadElement) {
                    continue;
                }
                // Check against the contextual type first
                if (checkExpressionNode(argNode)) {
                    continue;
                }
                // Check against the types from all of the call signatures
                const argExpectedReturnTypes = funcSignatures
                    .map(s => s.parameters[argIdx])
                    .filter(Boolean)
                    .map(param => checker.getTypeOfSymbolAtLocation(param, callTsNode.expression))
                    .flatMap(paramType => tsutils.unionConstituents(paramType))
                    .flatMap(paramType => paramType.getCallSignatures())
                    .map(paramSignature => paramSignature.getReturnType());
                if (
                // At least one return type is void
                argExpectedReturnTypes.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Void)) &&
                    // The rest are nullish or any
                    argExpectedReturnTypes.every(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.VoidLike |
                        ts.TypeFlags.Undefined |
                        ts.TypeFlags.Null |
                        ts.TypeFlags.Any |
                        ts.TypeFlags.Never))) {
                    // We treat this argument as void even though it might be technically any.
                    reportIfNonVoidFunction(argNode);
                }
            }
        }
        /**
         * Finds errors in an object property.
         *
         * Object properties require different logic
         * when the property is a method shorthand.
         */
        function checkObjectPropertyNode(propNode) {
            const valueNode = propNode.value;
            const propTsNode = parserServices.esTreeNodeToTSNodeMap.get(propNode);
            if (propTsNode.kind === ts.SyntaxKind.MethodDeclaration) {
                // Object property is a method shorthand.
                if (propTsNode.name.kind === ts.SyntaxKind.ComputedPropertyName) {
                    // Don't check object methods with computed name.
                    return;
                }
                const objTsNode = propTsNode.parent;
                const objType = checker.getContextualType(objTsNode);
                if (objType == null) {
                    // Expected object type is unknown.
                    return;
                }
                const propSymbol = checker.getPropertyOfType(objType, propTsNode.name.text);
                if (propSymbol == null) {
                    // Expected object type is known, but it doesn't have this method.
                    return;
                }
                const propExpectedType = checker.getTypeOfSymbolAtLocation(propSymbol, propTsNode);
                if (isVoidReturningFunctionType(propExpectedType)) {
                    reportIfNonVoidFunction(valueNode);
                }
                return;
            }
            // Object property is a regular property.
            checkExpressionNode(valueNode);
        }
        /**
         * Finds errors in a class property.
         *
         * In addition to the regular check against the contextual type,
         * we also check against the base class property (when the class extends another class)
         * and the implemented interfaces (when the class implements an interface).
         */
        function checkClassPropertyNode(propNode) {
            if (propNode.value == null) {
                return;
            }
            // Check in comparison to the base types.
            for (const { baseMemberType } of util.getBaseTypesOfClassMember(parserServices, propNode)) {
                if (isVoidReturningFunctionType(baseMemberType)) {
                    reportIfNonVoidFunction(propNode.value);
                    return; // Report at most one error.
                }
            }
            // Check in comparison to the contextual type.
            checkExpressionNode(propNode.value);
        }
        /**
         * Finds errors in a class method.
         *
         * We check against the base class method (when the class extends another class)
         * and the implemented interfaces (when the class implements an interface).
         */
        function checkClassMethodNode(methodNode) {
            if (methodNode.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {
                return;
            }
            // Check in comparison to the base types.
            for (const { baseMemberType } of util.getBaseTypesOfClassMember(parserServices, methodNode)) {
                if (isVoidReturningFunctionType(baseMemberType)) {
                    reportIfNonVoidFunction(methodNode.value);
                    return; // Report at most one error.
                }
            }
        }
        /**
         * Reports an error if the provided node is not allowed in a void function context.
         */
        function reportIfNonVoidFunction(funcNode) {
            const allowedReturnType = ts.TypeFlags.Void |
                ts.TypeFlags.Never |
                ts.TypeFlags.Undefined |
                (options.allowReturnAny ? ts.TypeFlags.Any : 0);
            const tsNode = parserServices.esTreeNodeToTSNodeMap.get(funcNode);
            const actualType = checker.getApparentType(checker.getTypeAtLocation(tsNode));
            if (tsutils
                .getCallSignaturesOfType(actualType)
                .map(signature => signature.getReturnType())
                .flatMap(returnType => tsutils.unionConstituents(returnType))
                .every(type => tsutils.isTypeFlagSet(type, allowedReturnType))) {
                // The function is already void.
                return;
            }
            if (funcNode.type !== utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&
                funcNode.type !== utils_1.AST_NODE_TYPES.FunctionExpression) {
                // The provided function is not a function literal.
                // Report a generic error.
                return context.report({
                    node: funcNode,
                    messageId: `nonVoidFunc`,
                });
            }
            // The provided function is a function literal.
            if (funcNode.generator) {
                // The provided function is a generator function.
                // Generator functions are not allowed.
                return context.report({
                    loc: util.getFunctionHeadLoc(funcNode, sourceCode),
                    messageId: `nonVoidFunc`,
                });
            }
            if (funcNode.async) {
                // The provided function is an async function.
                // Async functions aren't allowed.
                return context.report({
                    loc: util.getFunctionHeadLoc(funcNode, sourceCode),
                    messageId: `asyncFunc`,
                });
            }
            if (funcNode.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
                // The provided function is an arrow function shorthand without braces.
                return context.report({
                    node: funcNode.body,
                    messageId: `nonVoidReturn`,
                });
            }
            // The function is a regular or arrow function with a block body.
            // Check return type annotation.
            if (funcNode.returnType != null) {
                // The provided function has an explicit return type annotation.
                const typeAnnotationNode = funcNode.returnType.typeAnnotation;
                if (typeAnnotationNode.type !== utils_1.AST_NODE_TYPES.TSVoidKeyword) {
                    // The explicit return type is not `void`.
                    return context.report({
                        node: typeAnnotationNode,
                        messageId: `nonVoidFunc`,
                    });
                }
            }
            // Iterate over all function's return statements.
            for (const statement of util.walkStatements(funcNode.body.body)) {
                if (statement.type !== utils_1.AST_NODE_TYPES.ReturnStatement ||
                    statement.argument == null) {
                    // We only care about return statements with a value.
                    continue;
                }
                const returnType = checker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(statement.argument));
                if (tsutils.isTypeFlagSet(returnType, allowedReturnType)) {
                    // Only visit return statements with invalid type.
                    continue;
                }
                // This return statement causes the non-void return type.
                const returnKeyword = util.nullThrows(sourceCode.getFirstToken(statement, {
                    filter: token => token.value === 'return',
                }), util.NullThrowsReasons.MissingToken('return keyword', statement.type));
                context.report({
                    node: returnKeyword,
                    messageId: `nonVoidReturn`,
                });
            }
            // No invalid returns found. The function is allowed.
        }
    },
});


--------------------------------------------------------------------------------
FILE: switch-exhaustiveness-check.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type Options = [
    {
        /**
         * If `true`, allow `default` cases on switch statements with exhaustive
         * cases.
         *
         * @default true
         */
        allowDefaultCaseForExhaustiveSwitch?: boolean;
        /**
         * If `true`, require a `default` clause for switches on non-union types.
         *
         * @default false
         */
        requireDefaultForNonUnion?: boolean;
        /**
         * Regular expression for a comment that can indicate an intentionally omitted default case.
         */
        defaultCaseCommentPattern?: string;
        /**
         * If `true`, the `default` clause is used to determine whether the switch statement is exhaustive for union types.
         *
         * @default false
         */
        considerDefaultExhaustiveForUnions?: boolean;
    }
];
export type MessageIds = 'addMissingCases' | 'dangerousDefaultCase' | 'switchIsNotExhaustive';
declare const _default: TSESLint.RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: switch-exhaustiveness-check.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const DEFAULT_COMMENT_PATTERN = /^no default$/iu;
exports.default = (0, util_1.createRule)({
    name: 'switch-exhaustiveness-check',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Require switch-case statements to be exhaustive',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            addMissingCases: 'Add branches for missing cases.',
            dangerousDefaultCase: 'The switch statement is exhaustive, so the default case is unnecessary.',
            switchIsNotExhaustive: 'Switch is not exhaustive. Cases not matched: {{missingBranches}}',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowDefaultCaseForExhaustiveSwitch: {
                        type: 'boolean',
                        description: `If 'true', allow 'default' cases on switch statements with exhaustive cases.`,
                    },
                    considerDefaultExhaustiveForUnions: {
                        type: 'boolean',
                        description: `If 'true', the 'default' clause is used to determine whether the switch statement is exhaustive for union type`,
                    },
                    defaultCaseCommentPattern: {
                        type: 'string',
                        description: `Regular expression for a comment that can indicate an intentionally omitted default case.`,
                    },
                    requireDefaultForNonUnion: {
                        type: 'boolean',
                        description: `If 'true', require a 'default' clause for switches on non-union types.`,
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            allowDefaultCaseForExhaustiveSwitch: true,
            considerDefaultExhaustiveForUnions: false,
            requireDefaultForNonUnion: false,
        },
    ],
    create(context, [{ allowDefaultCaseForExhaustiveSwitch, considerDefaultExhaustiveForUnions, defaultCaseCommentPattern, requireDefaultForNonUnion, },]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const compilerOptions = services.program.getCompilerOptions();
        const commentRegExp = defaultCaseCommentPattern != null
            ? new RegExp(defaultCaseCommentPattern, 'u')
            : DEFAULT_COMMENT_PATTERN;
        function getCommentDefaultCase(node) {
            const lastCase = node.cases.at(-1);
            const commentsAfterLastCase = lastCase
                ? context.sourceCode.getCommentsAfter(lastCase)
                : [];
            const defaultCaseComment = commentsAfterLastCase.at(-1);
            if (commentRegExp.test(defaultCaseComment?.value.trim() || '')) {
                return defaultCaseComment;
            }
            return;
        }
        function typeToString(type) {
            return checker.typeToString(type, undefined, ts.TypeFormatFlags.AllowUniqueESSymbolType |
                ts.TypeFormatFlags.UseAliasDefinedOutsideCurrentScope |
                ts.TypeFormatFlags.UseFullyQualifiedType);
        }
        function getSwitchMetadata(node) {
            const defaultCase = node.cases.find(switchCase => switchCase.test == null);
            const discriminantType = (0, util_1.getConstrainedTypeAtLocation)(services, node.discriminant);
            const symbolName = discriminantType.getSymbol()?.escapedName;
            const containsNonLiteralType = doesTypeContainNonLiteralType(discriminantType);
            const caseTypes = new Set();
            for (const switchCase of node.cases) {
                // If the `test` property of the switch case is `null`, then we are on a
                // `default` case.
                if (switchCase.test == null) {
                    continue;
                }
                const caseType = (0, util_1.getConstrainedTypeAtLocation)(services, switchCase.test);
                caseTypes.add(caseType);
            }
            const missingLiteralBranchTypes = [];
            for (const unionPart of tsutils.unionConstituents(discriminantType)) {
                for (const intersectionPart of tsutils.intersectionConstituents(unionPart)) {
                    if (caseTypes.has(intersectionPart) ||
                        !isTypeLiteralLikeType(intersectionPart)) {
                        continue;
                    }
                    // "missing", "optional" and "undefined" types are different runtime objects,
                    // but all of them have TypeFlags.Undefined type flag
                    if ([...caseTypes].some(tsutils.isIntrinsicUndefinedType) &&
                        tsutils.isIntrinsicUndefinedType(intersectionPart)) {
                        continue;
                    }
                    missingLiteralBranchTypes.push(intersectionPart);
                }
            }
            return {
                containsNonLiteralType,
                defaultCase: defaultCase ?? getCommentDefaultCase(node),
                missingLiteralBranchTypes,
                symbolName,
            };
        }
        function checkSwitchExhaustive(node, switchMetadata) {
            const { defaultCase, missingLiteralBranchTypes, symbolName } = switchMetadata;
            // If considerDefaultExhaustiveForUnions is enabled, the presence of a default case
            // always makes the switch exhaustive.
            if (considerDefaultExhaustiveForUnions && defaultCase != null) {
                return;
            }
            if (missingLiteralBranchTypes.length > 0) {
                context.report({
                    node: node.discriminant,
                    messageId: 'switchIsNotExhaustive',
                    data: {
                        missingBranches: missingLiteralBranchTypes
                            .map(missingType => tsutils.isTypeFlagSet(missingType, ts.TypeFlags.ESSymbolLike)
                            ? `typeof ${missingType.getSymbol()?.escapedName}`
                            : typeToString(missingType))
                            .join(' | '),
                    },
                    suggest: [
                        {
                            messageId: 'addMissingCases',
                            fix(fixer) {
                                return fixSwitch(fixer, node, missingLiteralBranchTypes, defaultCase, symbolName?.toString());
                            },
                        },
                    ],
                });
            }
        }
        function fixSwitch(fixer, node, missingBranchTypes, // null means default branch
        defaultCase, symbolName) {
            const lastCase = node.cases.length > 0 ? node.cases[node.cases.length - 1] : null;
            const caseIndent = lastCase
                ? ' '.repeat(lastCase.loc.start.column)
                : // If there are no cases, use indentation of the switch statement and
                    // leave it to the user to format it correctly.
                    ' '.repeat(node.loc.start.column);
            const missingCases = [];
            for (const missingBranchType of missingBranchTypes) {
                if (missingBranchType == null) {
                    missingCases.push(`default: { throw new Error('default case') }`);
                    continue;
                }
                const missingBranchName = missingBranchType.getSymbol()?.escapedName;
                let caseTest = tsutils.isTypeFlagSet(missingBranchType, ts.TypeFlags.ESSymbolLike)
                    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        missingBranchName
                    : typeToString(missingBranchType);
                if (symbolName &&
                    (missingBranchName || missingBranchName === '') &&
                    (0, util_1.requiresQuoting)(missingBranchName.toString(), compilerOptions.target)) {
                    const escapedBranchName = missingBranchName
                        .replaceAll("'", "\\'")
                        .replaceAll('\n', '\\n')
                        .replaceAll('\r', '\\r');
                    caseTest = `${symbolName}['${escapedBranchName}']`;
                }
                missingCases.push(`case ${caseTest}: { throw new Error('Not implemented yet: ${caseTest
                    .replaceAll('\\', '\\\\')
                    .replaceAll("'", "\\'")} case') }`);
            }
            const fixString = missingCases
                .map(code => `${caseIndent}${code}`)
                .join('\n');
            if (lastCase) {
                if (defaultCase) {
                    const beforeFixString = missingCases
                        .map(code => `${code}\n${caseIndent}`)
                        .join('');
                    return fixer.insertTextBefore(defaultCase, beforeFixString);
                }
                return fixer.insertTextAfter(lastCase, `\n${fixString}`);
            }
            // There were no existing cases.
            const openingBrace = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.discriminant, util_1.isOpeningBraceToken), util_1.NullThrowsReasons.MissingToken('{', 'discriminant'));
            const closingBrace = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.discriminant, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', 'discriminant'));
            return fixer.replaceTextRange([openingBrace.range[0], closingBrace.range[1]], ['{', fixString, `${caseIndent}}`].join('\n'));
        }
        function checkSwitchUnnecessaryDefaultCase(switchMetadata) {
            if (allowDefaultCaseForExhaustiveSwitch) {
                return;
            }
            const { containsNonLiteralType, defaultCase, missingLiteralBranchTypes } = switchMetadata;
            if (missingLiteralBranchTypes.length === 0 &&
                defaultCase != null &&
                !containsNonLiteralType) {
                context.report({
                    node: defaultCase,
                    messageId: 'dangerousDefaultCase',
                });
            }
        }
        function checkSwitchNoUnionDefaultCase(node, switchMetadata) {
            if (!requireDefaultForNonUnion) {
                return;
            }
            const { containsNonLiteralType, defaultCase } = switchMetadata;
            if (containsNonLiteralType && defaultCase == null) {
                context.report({
                    node: node.discriminant,
                    messageId: 'switchIsNotExhaustive',
                    data: { missingBranches: 'default' },
                    suggest: [
                        {
                            messageId: 'addMissingCases',
                            fix(fixer) {
                                return fixSwitch(fixer, node, [null], defaultCase);
                            },
                        },
                    ],
                });
            }
        }
        return {
            SwitchStatement(node) {
                const switchMetadata = getSwitchMetadata(node);
                checkSwitchExhaustive(node, switchMetadata);
                checkSwitchUnnecessaryDefaultCase(switchMetadata);
                checkSwitchNoUnionDefaultCase(node, switchMetadata);
            },
        };
    },
});
function isTypeLiteralLikeType(type) {
    return tsutils.isTypeFlagSet(type, ts.TypeFlags.Literal |
        ts.TypeFlags.Undefined |
        ts.TypeFlags.Null |
        ts.TypeFlags.UniqueESSymbol);
}
/**
 * For example:
 *
 * - `"foo" | "bar"` is a type with all literal types.
 * - `"foo" | number` is a type that contains non-literal types.
 * - `"foo" & { bar: 1 }` is a type that contains non-literal types.
 *
 * Default cases are never superfluous in switches with non-literal types.
 */
function doesTypeContainNonLiteralType(type) {
    return tsutils
        .unionConstituents(type)
        .some(type => tsutils
        .intersectionConstituents(type)
        .every(subType => !isTypeLiteralLikeType(subType)));
}


--------------------------------------------------------------------------------
FILE: triple-slash-reference.d.ts
--------------------------------------------------------------------------------

export type Options = [
    {
        lib?: 'always' | 'never';
        path?: 'always' | 'never';
        types?: 'always' | 'never' | 'prefer-import';
    }
];
export type MessageIds = 'tripleSlashReference';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<"tripleSlashReference", Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: triple-slash-reference.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'triple-slash-reference',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow certain triple slash directives in favor of ES6-style import declarations',
            recommended: 'recommended',
        },
        messages: {
            tripleSlashReference: 'Do not use a triple slash reference for {{module}}, use `import` style instead.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    lib: {
                        type: 'string',
                        description: 'What to enforce for `/// <reference lib="..." />` references.',
                        enum: ['always', 'never'],
                    },
                    path: {
                        type: 'string',
                        description: 'What to enforce for `/// <reference path="..." />` references.',
                        enum: ['always', 'never'],
                    },
                    types: {
                        type: 'string',
                        description: 'What to enforce for `/// <reference types="..." />` references.',
                        enum: ['always', 'never', 'prefer-import'],
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            lib: 'always',
            path: 'never',
            types: 'prefer-import',
        },
    ],
    create(context, [{ lib, path, types }]) {
        let programNode;
        const references = [];
        function hasMatchingReference(source) {
            references.forEach(reference => {
                if (reference.importName === source.value) {
                    context.report({
                        node: reference.comment,
                        messageId: 'tripleSlashReference',
                        data: {
                            module: reference.importName,
                        },
                    });
                }
            });
        }
        return {
            ImportDeclaration(node) {
                if (programNode) {
                    hasMatchingReference(node.source);
                }
            },
            Program(node) {
                if (lib === 'always' && path === 'always' && types === 'always') {
                    return;
                }
                programNode = node;
                const referenceRegExp = /^\/\s*<reference\s*(types|path|lib)\s*=\s*["|'](.*)["|']/;
                const commentsBefore = context.sourceCode.getCommentsBefore(programNode);
                commentsBefore.forEach(comment => {
                    if (comment.type !== utils_1.AST_TOKEN_TYPES.Line) {
                        return;
                    }
                    const referenceResult = referenceRegExp.exec(comment.value);
                    if (referenceResult) {
                        if ((referenceResult[1] === 'types' && types === 'never') ||
                            (referenceResult[1] === 'path' && path === 'never') ||
                            (referenceResult[1] === 'lib' && lib === 'never')) {
                            context.report({
                                node: comment,
                                messageId: 'tripleSlashReference',
                                data: {
                                    module: referenceResult[2],
                                },
                            });
                            return;
                        }
                        if (referenceResult[1] === 'types' && types === 'prefer-import') {
                            references.push({ comment, importName: referenceResult[2] });
                        }
                    }
                });
            },
            TSImportEqualsDeclaration(node) {
                if (programNode) {
                    const reference = node.moduleReference;
                    if (reference.type === utils_1.AST_NODE_TYPES.TSExternalModuleReference) {
                        hasMatchingReference(reference.expression);
                    }
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: typedef.d.ts
--------------------------------------------------------------------------------

export declare const enum OptionKeys {
    ArrayDestructuring = "arrayDestructuring",
    ArrowParameter = "arrowParameter",
    MemberVariableDeclaration = "memberVariableDeclaration",
    ObjectDestructuring = "objectDestructuring",
    Parameter = "parameter",
    PropertyDeclaration = "propertyDeclaration",
    VariableDeclaration = "variableDeclaration",
    VariableDeclarationIgnoreFunction = "variableDeclarationIgnoreFunction"
}
export type Options = [Partial<Record<OptionKeys, boolean>>];
export type MessageIds = 'expectedTypedef' | 'expectedTypedefNamed';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: typedef.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionKeys = void 0;
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
var OptionKeys;
(function (OptionKeys) {
    OptionKeys["ArrayDestructuring"] = "arrayDestructuring";
    OptionKeys["ArrowParameter"] = "arrowParameter";
    OptionKeys["MemberVariableDeclaration"] = "memberVariableDeclaration";
    OptionKeys["ObjectDestructuring"] = "objectDestructuring";
    OptionKeys["Parameter"] = "parameter";
    OptionKeys["PropertyDeclaration"] = "propertyDeclaration";
    OptionKeys["VariableDeclaration"] = "variableDeclaration";
    OptionKeys["VariableDeclarationIgnoreFunction"] = "variableDeclarationIgnoreFunction";
})(OptionKeys || (exports.OptionKeys = OptionKeys = {}));
exports.default = (0, util_1.createRule)({
    name: 'typedef',
    meta: {
        type: 'suggestion',
        deprecated: {
            deprecatedSince: '8.33.0',
            message: 'This is an old rule that is no longer recommended for use.',
        },
        docs: {
            description: 'Require type annotations in certain places',
        },
        messages: {
            expectedTypedef: 'Expected a type annotation.',
            expectedTypedefNamed: 'Expected {{name}} to have a type annotation.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    [OptionKeys.ArrayDestructuring]: {
                        type: 'boolean',
                        description: 'Whether to enforce type annotations on variables declared using array destructuring.',
                    },
                    [OptionKeys.ArrowParameter]: {
                        type: 'boolean',
                        description: 'Whether to enforce type annotations for parameters of arrow functions.',
                    },
                    [OptionKeys.MemberVariableDeclaration]: {
                        type: 'boolean',
                        description: 'Whether to enforce type annotations on member variables of classes.',
                    },
                    [OptionKeys.ObjectDestructuring]: {
                        type: 'boolean',
                        description: 'Whether to enforce type annotations on variables declared using object destructuring.',
                    },
                    [OptionKeys.Parameter]: {
                        type: 'boolean',
                        description: 'Whether to enforce type annotations for parameters of functions and methods.',
                    },
                    [OptionKeys.PropertyDeclaration]: {
                        type: 'boolean',
                        description: 'Whether to enforce type annotations for properties of interfaces and types.',
                    },
                    [OptionKeys.VariableDeclaration]: {
                        type: 'boolean',
                        description: 'Whether to enforce type annotations for variable declarations, excluding array and object destructuring.',
                    },
                    [OptionKeys.VariableDeclarationIgnoreFunction]: {
                        type: 'boolean',
                        description: 'Whether to ignore variable declarations for non-arrow and arrow functions.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            [OptionKeys.ArrayDestructuring]: false,
            [OptionKeys.ArrowParameter]: false,
            [OptionKeys.MemberVariableDeclaration]: false,
            [OptionKeys.ObjectDestructuring]: false,
            [OptionKeys.Parameter]: false,
            [OptionKeys.PropertyDeclaration]: false,
            [OptionKeys.VariableDeclaration]: false,
            [OptionKeys.VariableDeclarationIgnoreFunction]: false,
        },
    ],
    create(context, [{ arrayDestructuring, arrowParameter, memberVariableDeclaration, objectDestructuring, parameter, propertyDeclaration, variableDeclaration, variableDeclarationIgnoreFunction, },]) {
        function report(location, name) {
            context.report({
                node: location,
                messageId: name ? 'expectedTypedefNamed' : 'expectedTypedef',
                data: { name },
            });
        }
        function getNodeName(node) {
            return node.type === utils_1.AST_NODE_TYPES.Identifier ? node.name : undefined;
        }
        function isForOfStatementContext(node) {
            let current = node.parent;
            while (current) {
                switch (current.type) {
                    case utils_1.AST_NODE_TYPES.VariableDeclarator:
                    case utils_1.AST_NODE_TYPES.VariableDeclaration:
                    case utils_1.AST_NODE_TYPES.ObjectPattern:
                    case utils_1.AST_NODE_TYPES.ArrayPattern:
                    case utils_1.AST_NODE_TYPES.Property:
                        current = current.parent;
                        break;
                    case utils_1.AST_NODE_TYPES.ForOfStatement:
                        return true;
                    default:
                        current = undefined;
                }
            }
            return false;
        }
        function checkParameters(params) {
            for (const param of params) {
                let annotationNode;
                switch (param.type) {
                    case utils_1.AST_NODE_TYPES.AssignmentPattern:
                        annotationNode = param.left;
                        break;
                    case utils_1.AST_NODE_TYPES.TSParameterProperty:
                        annotationNode = param.parameter;
                        // Check TS parameter property with default value like `constructor(private param: string = 'something') {}`
                        if (annotationNode.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {
                            annotationNode = annotationNode.left;
                        }
                        break;
                    default:
                        annotationNode = param;
                        break;
                }
                if (!annotationNode.typeAnnotation) {
                    report(param, getNodeName(param));
                }
            }
        }
        function isVariableDeclarationIgnoreFunction(node) {
            return (variableDeclarationIgnoreFunction === true &&
                (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                    node.type === utils_1.AST_NODE_TYPES.FunctionExpression));
        }
        function isAncestorHasTypeAnnotation(node) {
            let ancestor = node.parent;
            while (ancestor) {
                if ((ancestor.type === utils_1.AST_NODE_TYPES.ObjectPattern ||
                    ancestor.type === utils_1.AST_NODE_TYPES.ArrayPattern) &&
                    ancestor.typeAnnotation) {
                    return true;
                }
                ancestor = ancestor.parent;
            }
            return false;
        }
        return {
            ...(arrayDestructuring && {
                ArrayPattern(node) {
                    if (node.parent.type === utils_1.AST_NODE_TYPES.RestElement &&
                        node.parent.typeAnnotation) {
                        return;
                    }
                    if (!node.typeAnnotation &&
                        !isForOfStatementContext(node) &&
                        !isAncestorHasTypeAnnotation(node) &&
                        node.parent.type !== utils_1.AST_NODE_TYPES.AssignmentExpression) {
                        report(node);
                    }
                },
            }),
            ...(arrowParameter && {
                ArrowFunctionExpression(node) {
                    checkParameters(node.params);
                },
            }),
            ...(memberVariableDeclaration && {
                PropertyDefinition(node) {
                    if (!(node.value && isVariableDeclarationIgnoreFunction(node.value)) &&
                        !node.typeAnnotation) {
                        report(node, node.key.type === utils_1.AST_NODE_TYPES.Identifier
                            ? node.key.name
                            : undefined);
                    }
                },
            }),
            ...(parameter && {
                'FunctionDeclaration, FunctionExpression'(node) {
                    checkParameters(node.params);
                },
            }),
            ...(objectDestructuring && {
                ObjectPattern(node) {
                    if (!node.typeAnnotation &&
                        !isForOfStatementContext(node) &&
                        !isAncestorHasTypeAnnotation(node)) {
                        report(node);
                    }
                },
            }),
            ...(propertyDeclaration && {
                'TSIndexSignature, TSPropertySignature'(node) {
                    if (!node.typeAnnotation) {
                        report(node, node.type === utils_1.AST_NODE_TYPES.TSPropertySignature
                            ? getNodeName(node.key)
                            : undefined);
                    }
                },
            }),
            VariableDeclarator(node) {
                if (!variableDeclaration ||
                    node.id.typeAnnotation ||
                    (node.id.type === utils_1.AST_NODE_TYPES.ArrayPattern &&
                        !arrayDestructuring) ||
                    (node.id.type === utils_1.AST_NODE_TYPES.ObjectPattern &&
                        !objectDestructuring) ||
                    (node.init && isVariableDeclarationIgnoreFunction(node.init))) {
                    return;
                }
                let current = node.parent;
                while (current) {
                    switch (current.type) {
                        case utils_1.AST_NODE_TYPES.VariableDeclaration:
                            // Keep looking upwards
                            current = current.parent;
                            break;
                        case utils_1.AST_NODE_TYPES.ForOfStatement:
                        case utils_1.AST_NODE_TYPES.ForInStatement:
                            // Stop traversing and don't report an error
                            return;
                        default:
                            // Stop traversing
                            current = undefined;
                            break;
                    }
                }
                report(node, getNodeName(node.id));
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: unbound-method.d.ts
--------------------------------------------------------------------------------

interface Config {
    ignoreStatic: boolean;
}
export type Options = [Config];
export type MessageIds = 'unbound' | 'unboundWithoutThisAnnotation';
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: unbound-method.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
/**
 * Static methods on these globals are either not `this`-aware or supported being
 * called without `this`.
 *
 * - `Promise` is not in the list because it supports subclassing by using `this`
 * - `Array` is in the list because although it supports subclassing, the `this`
 *   value defaults to `Array` when unbound
 *
 * This is now a language-design invariant: static methods are never `this`-aware
 * because TC39 wants to make `array.map(Class.method)` work!
 */
const SUPPORTED_GLOBALS = [
    'Number',
    'Object',
    'String', // eslint-disable-line @typescript-eslint/internal/prefer-ast-types-enum
    'RegExp',
    'Symbol',
    'Array',
    'Proxy',
    'Date',
    'Atomics',
    'Reflect',
    'console',
    'Math',
    'JSON',
    'Intl',
];
const nativelyBoundMembers = new Set(SUPPORTED_GLOBALS.flatMap(namespace => {
    if (!(namespace in global)) {
        // node.js might not have namespaces like Intl depending on compilation options
        // https://nodejs.org/api/intl.html#intl_options_for_building_node_js
        return [];
    }
    const object = global[namespace];
    return Object.getOwnPropertyNames(object)
        .filter(name => !name.startsWith('_') &&
        typeof object[name] === 'function')
        .map(name => `${namespace}.${name}`);
}));
const SUPPORTED_GLOBAL_TYPES = [
    'NumberConstructor',
    'ObjectConstructor',
    'StringConstructor',
    'SymbolConstructor',
    'ArrayConstructor',
    'Array',
    'ProxyConstructor',
    'Console',
    'DateConstructor',
    'Atomics',
    'Math',
    'JSON',
];
const isNotImported = (symbol, currentSourceFile) => {
    const { valueDeclaration } = symbol;
    if (!valueDeclaration) {
        // working around https://github.com/microsoft/TypeScript/issues/31294
        return false;
    }
    return (!!currentSourceFile &&
        currentSourceFile !== valueDeclaration.getSourceFile());
};
const BASE_MESSAGE = [
    `A method that is not declared with \`this: void\` may cause unintentional scoping of \`this\` when separated from its object.`,
    `Consider using an arrow function or explicitly \`.bind()\`ing the method to avoid calling the method with an unintended \`this\` value. `,
].join('\n');
exports.default = (0, util_1.createRule)({
    name: 'unbound-method',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce unbound methods are called with their expected scope',
            recommended: 'recommended',
            requiresTypeChecking: true,
        },
        messages: {
            unbound: BASE_MESSAGE,
            unboundWithoutThisAnnotation: `${BASE_MESSAGE}\nIf a function does not access \`this\`, it can be annotated with \`this: void\`.`,
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ignoreStatic: {
                        type: 'boolean',
                        description: 'Whether to skip checking whether `static` methods are correctly bound.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            ignoreStatic: false,
        },
    ],
    create(context, [{ ignoreStatic }]) {
        const services = (0, util_1.getParserServices)(context);
        const currentSourceFile = services.program.getSourceFile(context.filename);
        function checkIfMethodAndReport(node, symbol) {
            if (!symbol) {
                return false;
            }
            const { dangerous, firstParamIsThis } = checkIfMethod(symbol, ignoreStatic);
            if (dangerous) {
                context.report({
                    node,
                    messageId: firstParamIsThis === false
                        ? 'unboundWithoutThisAnnotation'
                        : 'unbound',
                });
                return true;
            }
            return false;
        }
        function isNativelyBound(object, property) {
            // We can't rely entirely on the type-level checks made at the end of this
            // function, because sometimes type declarations don't come from the
            // default library, but come from, for example, "@types/node". And we can't
            // tell if a method is unbound just by looking at its signature declared in
            // the interface.
            //
            // See related discussion https://github.com/typescript-eslint/typescript-eslint/pull/8952#discussion_r1576543310
            if (object.type === utils_1.AST_NODE_TYPES.Identifier &&
                property.type === utils_1.AST_NODE_TYPES.Identifier) {
                const objectSymbol = services.getSymbolAtLocation(object);
                const notImported = objectSymbol != null &&
                    isNotImported(objectSymbol, currentSourceFile);
                if (notImported &&
                    nativelyBoundMembers.has(`${object.name}.${property.name}`)) {
                    return true;
                }
            }
            // if `${object.name}.${property.name}` doesn't match any of
            // the nativelyBoundMembers, then we fallback to type-level checks
            return ((0, util_1.isBuiltinSymbolLike)(services.program, services.getTypeAtLocation(object), SUPPORTED_GLOBAL_TYPES) &&
                (0, util_1.isSymbolFromDefaultLibrary)(services.program, services.getTypeAtLocation(property).getSymbol()));
        }
        return {
            MemberExpression(node) {
                if (isSafeUse(node) || isNativelyBound(node.object, node.property)) {
                    return;
                }
                checkIfMethodAndReport(node, services.getSymbolAtLocation(node));
            },
            ObjectPattern(node) {
                if (isNodeInsideTypeDeclaration(node)) {
                    return;
                }
                let initNode = null;
                if (node.parent.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {
                    initNode = node.parent.init;
                }
                else if (node.parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern ||
                    node.parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {
                    initNode = node.parent.right;
                }
                for (const property of node.properties) {
                    if (property.type !== utils_1.AST_NODE_TYPES.Property ||
                        property.key.type !== utils_1.AST_NODE_TYPES.Identifier) {
                        continue;
                    }
                    if (initNode) {
                        if (!isNativelyBound(initNode, property.key)) {
                            const reported = checkIfMethodAndReport(property.key, services
                                .getTypeAtLocation(initNode)
                                .getProperty(property.key.name));
                            if (reported) {
                                continue;
                            }
                            // In assignment patterns, we should also check the type of
                            // Foo's nativelyBound method because initNode might be used as
                            // default value:
                            //   function ({ nativelyBound }: Foo = NativeObject) {}
                        }
                        else if (node.parent.type !== utils_1.AST_NODE_TYPES.AssignmentPattern) {
                            continue;
                        }
                    }
                    for (const intersectionPart of tsutils
                        .unionConstituents(services.getTypeAtLocation(node))
                        .flatMap(unionPart => tsutils.intersectionConstituents(unionPart))) {
                        const reported = checkIfMethodAndReport(property.key, intersectionPart.getProperty(property.key.name));
                        if (reported) {
                            break;
                        }
                    }
                }
            },
        };
    },
});
function isNodeInsideTypeDeclaration(node) {
    let parent = node;
    while ((parent = parent.parent)) {
        if ((parent.type === utils_1.AST_NODE_TYPES.ClassDeclaration && parent.declare) ||
            parent.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
            parent.type === utils_1.AST_NODE_TYPES.TSDeclareFunction ||
            parent.type === utils_1.AST_NODE_TYPES.TSFunctionType ||
            parent.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration ||
            parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration ||
            (parent.type === utils_1.AST_NODE_TYPES.VariableDeclaration && parent.declare)) {
            return true;
        }
    }
    return false;
}
function checkIfMethod(symbol, ignoreStatic) {
    const { valueDeclaration } = symbol;
    if (!valueDeclaration) {
        // working around https://github.com/microsoft/TypeScript/issues/31294
        return { dangerous: false };
    }
    switch (valueDeclaration.kind) {
        case ts.SyntaxKind.PropertyDeclaration:
            return {
                dangerous: valueDeclaration.initializer?.kind ===
                    ts.SyntaxKind.FunctionExpression,
            };
        case ts.SyntaxKind.PropertyAssignment: {
            const assignee = valueDeclaration.initializer;
            if (assignee.kind !== ts.SyntaxKind.FunctionExpression) {
                return {
                    dangerous: false,
                };
            }
            return checkMethod(assignee, ignoreStatic);
        }
        case ts.SyntaxKind.MethodDeclaration:
        case ts.SyntaxKind.MethodSignature: {
            return checkMethod(valueDeclaration, ignoreStatic);
        }
    }
    return { dangerous: false };
}
function checkMethod(valueDeclaration, ignoreStatic) {
    const firstParam = valueDeclaration.parameters.at(0);
    const firstParamIsThis = firstParam?.name.kind === ts.SyntaxKind.Identifier &&
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        firstParam.name.escapedText === 'this';
    const thisArgIsVoid = firstParamIsThis && firstParam.type?.kind === ts.SyntaxKind.VoidKeyword;
    return {
        dangerous: !thisArgIsVoid &&
            !(ignoreStatic &&
                tsutils.includesModifier((0, util_1.getModifiers)(valueDeclaration), ts.SyntaxKind.StaticKeyword)),
        firstParamIsThis,
    };
}
function isSafeUse(node) {
    const parent = node.parent;
    switch (parent?.type) {
        case utils_1.AST_NODE_TYPES.IfStatement:
        case utils_1.AST_NODE_TYPES.ForStatement:
        case utils_1.AST_NODE_TYPES.MemberExpression:
        case utils_1.AST_NODE_TYPES.SwitchStatement:
        case utils_1.AST_NODE_TYPES.UpdateExpression:
        case utils_1.AST_NODE_TYPES.WhileStatement:
            return true;
        case utils_1.AST_NODE_TYPES.CallExpression:
            return parent.callee === node;
        case utils_1.AST_NODE_TYPES.ConditionalExpression:
            return parent.test === node;
        case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:
            return parent.tag === node;
        case utils_1.AST_NODE_TYPES.UnaryExpression:
            // the first case is safe for obvious
            // reasons. The second one is also fine
            // since we're returning something falsy
            return ['!', 'delete', 'typeof', 'void'].includes(parent.operator);
        case utils_1.AST_NODE_TYPES.BinaryExpression:
            return ['!=', '!==', '==', '===', 'instanceof'].includes(parent.operator);
        case utils_1.AST_NODE_TYPES.AssignmentExpression:
            return (parent.operator === '=' &&
                (node === parent.left ||
                    (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                        node.object.type === utils_1.AST_NODE_TYPES.Super &&
                        parent.left.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                        parent.left.object.type === utils_1.AST_NODE_TYPES.ThisExpression)));
        case utils_1.AST_NODE_TYPES.ChainExpression:
        case utils_1.AST_NODE_TYPES.TSNonNullExpression:
        case utils_1.AST_NODE_TYPES.TSAsExpression:
        case utils_1.AST_NODE_TYPES.TSTypeAssertion:
            return isSafeUse(parent);
        case utils_1.AST_NODE_TYPES.LogicalExpression:
            if (parent.operator === '&&' && parent.left === node) {
                // this is safe, as && will return the left if and only if it's falsy
                return true;
            }
            // in all other cases, it's likely the logical expression will return the method ref
            // so make sure the parent is a safe usage
            return isSafeUse(parent);
    }
    return false;
}


--------------------------------------------------------------------------------
FILE: unified-signatures.d.ts
--------------------------------------------------------------------------------

export type MessageIds = 'omittingRestParameter' | 'omittingSingleParameter' | 'singleParameterDifference';
export type Options = [
    {
        ignoreDifferentlyNamedParameters?: boolean;
        ignoreOverloadsWithDifferentJSDoc?: boolean;
    }
];
declare const _default: import("@typescript-eslint/utils/ts-eslint").RuleModule<MessageIds, Options, import("../../rules").ESLintPluginDocs, import("@typescript-eslint/utils/ts-eslint").RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: unified-signatures.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
exports.default = (0, util_1.createRule)({
    name: 'unified-signatures',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow two overloads that could be unified into one with a union or an optional/rest parameter',
            // too opinionated to be recommended
            recommended: 'strict',
        },
        messages: {
            omittingRestParameter: '{{failureStringStart}} with a rest parameter.',
            omittingSingleParameter: '{{failureStringStart}} with an optional parameter.',
            singleParameterDifference: '{{failureStringStart}} taking `{{type1}} | {{type2}}`.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    ignoreDifferentlyNamedParameters: {
                        type: 'boolean',
                        description: 'Whether two parameters with different names at the same index should be considered different even if their types are the same.',
                    },
                    ignoreOverloadsWithDifferentJSDoc: {
                        type: 'boolean',
                        description: 'Whether two overloads with different JSDoc comments should be considered different even if their parameter and return types are the same.',
                    },
                },
            },
        ],
    },
    defaultOptions: [
        {
            ignoreDifferentlyNamedParameters: false,
            ignoreOverloadsWithDifferentJSDoc: false,
        },
    ],
    create(context, [{ ignoreDifferentlyNamedParameters, ignoreOverloadsWithDifferentJSDoc }]) {
        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------
        function failureStringStart(otherLine) {
            // For only 2 overloads we don't need to specify which is the other one.
            const overloads = otherLine == null
                ? 'These overloads'
                : `This overload and the one on line ${otherLine}`;
            return `${overloads} can be combined into one signature`;
        }
        function addFailures(failures) {
            for (const failure of failures) {
                const { only2, unify } = failure;
                switch (unify.kind) {
                    case 'single-parameter-difference': {
                        const { p0, p1 } = unify;
                        const lineOfOtherOverload = only2 ? undefined : p0.loc.start.line;
                        const typeAnnotation0 = isTSParameterProperty(p0)
                            ? p0.parameter.typeAnnotation
                            : p0.typeAnnotation;
                        const typeAnnotation1 = isTSParameterProperty(p1)
                            ? p1.parameter.typeAnnotation
                            : p1.typeAnnotation;
                        context.report({
                            loc: p1.loc,
                            node: p1,
                            messageId: 'singleParameterDifference',
                            data: {
                                failureStringStart: failureStringStart(lineOfOtherOverload),
                                type1: context.sourceCode.getText(typeAnnotation0?.typeAnnotation),
                                type2: context.sourceCode.getText(typeAnnotation1?.typeAnnotation),
                            },
                        });
                        break;
                    }
                    case 'extra-parameter': {
                        const { extraParameter, otherSignature } = unify;
                        const lineOfOtherOverload = only2
                            ? undefined
                            : otherSignature.loc.start.line;
                        context.report({
                            loc: extraParameter.loc,
                            node: extraParameter,
                            messageId: extraParameter.type === utils_1.AST_NODE_TYPES.RestElement
                                ? 'omittingRestParameter'
                                : 'omittingSingleParameter',
                            data: {
                                failureStringStart: failureStringStart(lineOfOtherOverload),
                            },
                        });
                    }
                }
            }
        }
        function checkOverloads(signatures, typeParameters) {
            const result = [];
            const isTypeParameter = getIsTypeParameter(typeParameters);
            for (const overloads of signatures) {
                forEachPair(overloads, (a, b) => {
                    const signature0 = a.value ?? a;
                    const signature1 = b.value ?? b;
                    const unify = compareSignatures(signature0, signature1, isTypeParameter);
                    if (unify != null) {
                        result.push({ only2: overloads.length === 2, unify });
                    }
                });
            }
            return result;
        }
        function compareSignatures(a, b, isTypeParameter) {
            if (!signaturesCanBeUnified(a, b, isTypeParameter)) {
                return undefined;
            }
            return a.params.length === b.params.length
                ? signaturesDifferBySingleParameter(a.params, b.params)
                : signaturesDifferByOptionalOrRestParameter(a, b);
        }
        function signaturesCanBeUnified(a, b, isTypeParameter) {
            // Must return the same type.
            const aTypeParams = a.typeParameters != null ? a.typeParameters.params : undefined;
            const bTypeParams = b.typeParameters != null ? b.typeParameters.params : undefined;
            if (ignoreDifferentlyNamedParameters) {
                const commonParamsLength = Math.min(a.params.length, b.params.length);
                for (let i = 0; i < commonParamsLength; i += 1) {
                    if (a.params[i].type === b.params[i].type &&
                        getStaticParameterName(a.params[i]) !==
                            getStaticParameterName(b.params[i])) {
                        return false;
                    }
                }
            }
            if (ignoreOverloadsWithDifferentJSDoc) {
                const aComment = getBlockCommentForNode(getCommentTargetNode(a));
                const bComment = getBlockCommentForNode(getCommentTargetNode(b));
                if (aComment?.value !== bComment?.value) {
                    return false;
                }
            }
            return (typesAreEqual(a.returnType, b.returnType) &&
                // Must take the same type parameters.
                // If one uses a type parameter (from outside) and the other doesn't, they shouldn't be joined.
                (0, util_1.arraysAreEqual)(aTypeParams, bTypeParams, typeParametersAreEqual) &&
                signatureUsesTypeParameter(a, isTypeParameter) ===
                    signatureUsesTypeParameter(b, isTypeParameter));
        }
        /** Detect `a(x: number, y: number, z: number)` and `a(x: number, y: string, z: number)`. */
        function signaturesDifferBySingleParameter(types1, types2) {
            const firstParam1 = types1[0];
            const firstParam2 = types2[0];
            // exempt signatures with `this: void` from the rule
            if (isThisVoidParam(firstParam1) || isThisVoidParam(firstParam2)) {
                return undefined;
            }
            const index = getIndexOfFirstDifference(types1, types2, parametersAreEqual);
            if (index == null) {
                return undefined;
            }
            // If remaining arrays are equal, the signatures differ by just one parameter type
            if (!(0, util_1.arraysAreEqual)(types1.slice(index + 1), types2.slice(index + 1), parametersAreEqual)) {
                return undefined;
            }
            const a = types1[index];
            const b = types2[index];
            // Can unify `a?: string` and `b?: number`. Can't unify `...args: string[]` and `...args: number[]`.
            // See https://github.com/Microsoft/TypeScript/issues/5077
            return parametersHaveEqualSigils(a, b) &&
                a.type !== utils_1.AST_NODE_TYPES.RestElement
                ? { kind: 'single-parameter-difference', p0: a, p1: b }
                : undefined;
        }
        function isThisParam(param) {
            return param?.type === utils_1.AST_NODE_TYPES.Identifier && param.name === 'this';
        }
        function isThisVoidParam(param) {
            return (isThisParam(param) &&
                param.typeAnnotation?.typeAnnotation.type ===
                    utils_1.AST_NODE_TYPES.TSVoidKeyword);
        }
        /**
         * Detect `a(): void` and `a(x: number): void`.
         * Returns the parameter declaration (`x: number` in this example) that should be optional/rest, and overload it's a part of.
         */
        function signaturesDifferByOptionalOrRestParameter(a, b) {
            const sig1 = a.params;
            const sig2 = b.params;
            const minLength = Math.min(sig1.length, sig2.length);
            const longer = sig1.length < sig2.length ? sig2 : sig1;
            const shorter = sig1.length < sig2.length ? sig1 : sig2;
            const shorterSig = sig1.length < sig2.length ? a : b;
            const firstParam1 = sig1.at(0);
            const firstParam2 = sig2.at(0);
            // If one signature has explicit this type and another doesn't, they can't
            // be unified.
            if (isThisParam(firstParam1) !== isThisParam(firstParam2)) {
                return undefined;
            }
            // exempt signatures with `this: void` from the rule
            if (isThisVoidParam(firstParam1) || isThisVoidParam(firstParam2)) {
                return undefined;
            }
            // If one is has 2+ parameters more than the other, they must all be optional/rest.
            // Differ by optional parameters: f() and f(x), f() and f(x, ?y, ...z)
            // Not allowed: f() and f(x, y)
            for (let i = minLength + 1; i < longer.length; i++) {
                if (!parameterMayBeMissing(longer[i])) {
                    return undefined;
                }
            }
            for (let i = 0; i < minLength; i++) {
                const sig1i = sig1[i];
                const sig2i = sig2[i];
                const typeAnnotation1 = isTSParameterProperty(sig1i)
                    ? sig1i.parameter.typeAnnotation
                    : sig1i.typeAnnotation;
                const typeAnnotation2 = isTSParameterProperty(sig2i)
                    ? sig2i.parameter.typeAnnotation
                    : sig2i.typeAnnotation;
                if (!typesAreEqual(typeAnnotation1, typeAnnotation2)) {
                    return undefined;
                }
            }
            if (minLength > 0 &&
                shorter[minLength - 1].type === utils_1.AST_NODE_TYPES.RestElement) {
                return undefined;
            }
            return {
                extraParameter: longer[longer.length - 1],
                kind: 'extra-parameter',
                otherSignature: shorterSig,
            };
        }
        /** Given type parameters, returns a function to test whether a type is one of those parameters. */
        function getIsTypeParameter(typeParameters) {
            if (typeParameters == null) {
                return (() => false);
            }
            const set = new Set();
            for (const t of typeParameters.params) {
                set.add(t.name.name);
            }
            return (typeName => set.has(typeName));
        }
        /** True if any of the outer type parameters are used in a signature. */
        function signatureUsesTypeParameter(sig, isTypeParameter) {
            return sig.params.some((p) => typeContainsTypeParameter(isTSParameterProperty(p)
                ? p.parameter.typeAnnotation
                : p.typeAnnotation));
            function typeContainsTypeParameter(type) {
                if (!type) {
                    return false;
                }
                if (type.type === utils_1.AST_NODE_TYPES.TSTypeReference) {
                    const typeName = type.typeName;
                    if (isIdentifier(typeName) && isTypeParameter(typeName.name)) {
                        return true;
                    }
                }
                return typeContainsTypeParameter(type.typeAnnotation ??
                    type.elementType);
            }
        }
        function isTSParameterProperty(node) {
            return node.type === utils_1.AST_NODE_TYPES.TSParameterProperty;
        }
        function parametersAreEqual(a, b) {
            const typeAnnotationA = isTSParameterProperty(a)
                ? a.parameter.typeAnnotation
                : a.typeAnnotation;
            const typeAnnotationB = isTSParameterProperty(b)
                ? b.parameter.typeAnnotation
                : b.typeAnnotation;
            return (parametersHaveEqualSigils(a, b) &&
                typesAreEqual(typeAnnotationA, typeAnnotationB));
        }
        /** True for optional/rest parameters. */
        function parameterMayBeMissing(p) {
            const optional = isTSParameterProperty(p)
                ? p.parameter.optional
                : p.optional;
            return p.type === utils_1.AST_NODE_TYPES.RestElement || optional;
        }
        /** False if one is optional and the other isn't, or one is a rest parameter and the other isn't. */
        function parametersHaveEqualSigils(a, b) {
            const optionalA = isTSParameterProperty(a)
                ? a.parameter.optional
                : a.optional;
            const optionalB = isTSParameterProperty(b)
                ? b.parameter.optional
                : b.optional;
            return ((a.type === utils_1.AST_NODE_TYPES.RestElement) ===
                (b.type === utils_1.AST_NODE_TYPES.RestElement) && optionalA === optionalB);
        }
        function typeParametersAreEqual(a, b) {
            return (a.name.name === b.name.name &&
                constraintsAreEqual(a.constraint, b.constraint));
        }
        function typesAreEqual(a, b) {
            return (a === b ||
                (a != null &&
                    b != null &&
                    context.sourceCode.getText(a.typeAnnotation) ===
                        context.sourceCode.getText(b.typeAnnotation)));
        }
        function constraintsAreEqual(a, b) {
            return a === b || (a != null && a.type === b?.type);
        }
        /* Returns the first index where `a` and `b` differ. */
        function getIndexOfFirstDifference(a, b, equal) {
            for (let i = 0; i < a.length && i < b.length; i++) {
                if (!equal(a[i], b[i])) {
                    return i;
                }
            }
            return undefined;
        }
        /** Calls `action` for every pair of values in `values`. */
        function forEachPair(values, action) {
            for (let i = 0; i < values.length; i++) {
                for (let j = i + 1; j < values.length; j++) {
                    action(values[i], values[j]);
                }
            }
        }
        const scopes = [];
        let currentScope = {
            overloads: new Map(),
        };
        function createScope(parent, typeParameters) {
            if (currentScope) {
                scopes.push(currentScope);
            }
            currentScope = {
                overloads: new Map(),
                parent,
                typeParameters,
            };
        }
        function checkScope() {
            const scope = (0, util_1.nullThrows)(currentScope, 'checkScope() called without a current scope');
            const failures = checkOverloads([...scope.overloads.values()], scope.typeParameters);
            addFailures(failures);
            currentScope = scopes.pop();
        }
        /**
         * @returns the first valid JSDoc comment annotating `node`
         */
        function getBlockCommentForNode(node) {
            return context.sourceCode
                .getCommentsBefore(node)
                .reverse()
                .find(comment => comment.type === utils_1.AST_TOKEN_TYPES.Block);
        }
        function addOverload(signature, key, containingNode) {
            key ??= getOverloadKey(signature);
            if ((containingNode ?? signature).parent === currentScope?.parent) {
                const overloads = currentScope.overloads.get(key);
                if (overloads != null) {
                    overloads.push(signature);
                }
                else {
                    currentScope.overloads.set(key, [signature]);
                }
            }
        }
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        return {
            ClassDeclaration(node) {
                createScope(node.body, node.typeParameters);
            },
            Program: createScope,
            TSInterfaceDeclaration(node) {
                createScope(node.body, node.typeParameters);
            },
            TSModuleBlock: createScope,
            TSTypeLiteral: createScope,
            // collect overloads
            MethodDefinition(node) {
                if (!node.value.body && !isGetterOrSetter(node)) {
                    addOverload(node);
                }
            },
            TSAbstractMethodDefinition(node) {
                if (!node.value.body && !isGetterOrSetter(node)) {
                    addOverload(node);
                }
            },
            TSCallSignatureDeclaration: addOverload,
            TSConstructSignatureDeclaration: addOverload,
            TSDeclareFunction(node) {
                const exportingNode = getExportingNode(node);
                addOverload(node, node.id?.name ?? exportingNode?.type, exportingNode);
            },
            TSMethodSignature(node) {
                if (!isGetterOrSetter(node)) {
                    addOverload(node);
                }
            },
            // validate scopes
            'ClassDeclaration:exit': checkScope,
            'Program:exit': checkScope,
            'TSInterfaceDeclaration:exit': checkScope,
            'TSModuleBlock:exit': checkScope,
            'TSTypeLiteral:exit': checkScope,
        };
    },
});
function getCommentTargetNode(node) {
    if (node.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {
        return node.parent;
    }
    return getExportingNode(node) ?? node;
}
function getExportingNode(node) {
    return node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration ||
        node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration
        ? node.parent
        : undefined;
}
function getOverloadKey(node) {
    const info = getOverloadInfo(node);
    return ((node.computed ? '0' : '1') +
        (node.static ? '0' : '1') +
        info);
}
function getOverloadInfo(node) {
    switch (node.type) {
        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:
            return 'constructor';
        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:
            return '()';
        default: {
            const { key } = node;
            if (isPrivateIdentifier(key)) {
                return `private_identifier_${key.name}`;
            }
            if (isIdentifier(key)) {
                return `identifier_${key.name}`;
            }
            return key.raw;
        }
    }
}
function getStaticParameterName(param) {
    switch (param.type) {
        case utils_1.AST_NODE_TYPES.Identifier:
            return param.name;
        case utils_1.AST_NODE_TYPES.RestElement:
            return getStaticParameterName(param.argument);
        default:
            return undefined;
    }
}
function isIdentifier(node) {
    return node.type === utils_1.AST_NODE_TYPES.Identifier;
}
function isPrivateIdentifier(node) {
    return node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier;
}
function isGetterOrSetter(node) {
    return node.kind === 'get' || node.kind === 'set';
}


--------------------------------------------------------------------------------
FILE: use-unknown-in-catch-callback-variable.d.ts
--------------------------------------------------------------------------------

import type { TSESLint } from '@typescript-eslint/utils';
export type MessageIds = 'addUnknownRestTypeAnnotationSuggestion' | 'addUnknownTypeAnnotationSuggestion' | 'useUnknown' | 'useUnknownArrayDestructuringPattern' | 'useUnknownObjectDestructuringPattern' | 'wrongRestTypeAnnotationSuggestion' | 'wrongTypeAnnotationSuggestion';
declare const _default: TSESLint.RuleModule<MessageIds, [], import("../../rules").ESLintPluginDocs, TSESLint.RuleListener> & {
    name: string;
};
export default _default;


--------------------------------------------------------------------------------
FILE: use-unknown-in-catch-callback-variable.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const util_1 = require("../util");
const useUnknownMessageBase = 'Prefer the safe `: unknown` for a `{{method}}`{{append}} callback variable.';
exports.default = (0, util_1.createRule)({
    name: 'use-unknown-in-catch-callback-variable',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Enforce typing arguments in Promise rejection callbacks as `unknown`',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        hasSuggestions: true,
        messages: {
            addUnknownRestTypeAnnotationSuggestion: 'Add an explicit `: [unknown]` type annotation to the rejection callback rest variable.',
            addUnknownTypeAnnotationSuggestion: 'Add an explicit `: unknown` type annotation to the rejection callback variable.',
            useUnknown: useUnknownMessageBase,
            useUnknownArrayDestructuringPattern: `${useUnknownMessageBase} The thrown error may not be iterable.`,
            useUnknownObjectDestructuringPattern: `${useUnknownMessageBase} The thrown error may be nullable, or may not have the expected shape.`,
            wrongRestTypeAnnotationSuggestion: 'Change existing type annotation to `: [unknown]`.',
            wrongTypeAnnotationSuggestion: 'Change existing type annotation to `: unknown`.',
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const { esTreeNodeToTSNodeMap, program } = (0, util_1.getParserServices)(context);
        const checker = program.getTypeChecker();
        function isFlaggableHandlerType(type) {
            for (const unionPart of tsutils.unionConstituents(type)) {
                const callSignatures = tsutils.getCallSignaturesOfType(unionPart);
                if (callSignatures.length === 0) {
                    // Ignore any non-function components to the type. Those are not this rule's problem.
                    continue;
                }
                for (const callSignature of callSignatures) {
                    const firstParam = callSignature.parameters.at(0);
                    if (!firstParam) {
                        // it's not an issue if there's no catch variable at all.
                        continue;
                    }
                    let firstParamType = checker.getTypeOfSymbol(firstParam);
                    const decl = firstParam.valueDeclaration;
                    if (decl != null && (0, util_1.isRestParameterDeclaration)(decl)) {
                        if (checker.isArrayType(firstParamType)) {
                            firstParamType = checker.getTypeArguments(firstParamType)[0];
                        }
                        else if (checker.isTupleType(firstParamType)) {
                            firstParamType = checker.getTypeArguments(firstParamType)[0];
                        }
                        else {
                            // a rest arg that's not an array or tuple should definitely be flagged.
                            return true;
                        }
                    }
                    if (!tsutils.isIntrinsicUnknownType(firstParamType)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function collectFlaggedNodes(node) {
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.LogicalExpression:
                    return [
                        ...collectFlaggedNodes(node.left),
                        ...collectFlaggedNodes(node.right),
                    ];
                case utils_1.AST_NODE_TYPES.SequenceExpression:
                    return collectFlaggedNodes((0, util_1.nullThrows)(node.expressions.at(-1), 'sequence expression must have multiple expressions'));
                case utils_1.AST_NODE_TYPES.ConditionalExpression:
                    return [
                        ...collectFlaggedNodes(node.consequent),
                        ...collectFlaggedNodes(node.alternate),
                    ];
                case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                case utils_1.AST_NODE_TYPES.FunctionExpression:
                    {
                        const argument = esTreeNodeToTSNodeMap.get(node);
                        const typeOfArgument = checker.getTypeAtLocation(argument);
                        if (isFlaggableHandlerType(typeOfArgument)) {
                            return [node];
                        }
                    }
                    break;
                default:
                    break;
            }
            return [];
        }
        /**
         * Analyzes the syntax of the catch argument and makes a best effort to pinpoint
         * why it's reporting, and to come up with a suggested fix if possible.
         *
         * This function is explicitly operating under the assumption that the
         * rule _is reporting_, so it is not guaranteed to be sound to call otherwise.
         */
        function refineReportIfPossible(argument) {
            const catchVariableOuterWithIncorrectTypes = (0, util_1.nullThrows)(argument.params.at(0), 'There should have been at least one parameter for the rule to have flagged.');
            // Function expressions can't have parameter properties; those only exist in constructors.
            const catchVariableOuter = catchVariableOuterWithIncorrectTypes;
            const catchVariableInner = catchVariableOuter.type === utils_1.AST_NODE_TYPES.AssignmentPattern
                ? catchVariableOuter.left
                : catchVariableOuter;
            switch (catchVariableInner.type) {
                case utils_1.AST_NODE_TYPES.Identifier: {
                    const catchVariableTypeAnnotation = catchVariableInner.typeAnnotation;
                    if (catchVariableTypeAnnotation == null) {
                        return {
                            node: catchVariableOuter,
                            suggest: [
                                {
                                    messageId: 'addUnknownTypeAnnotationSuggestion',
                                    fix: (fixer) => {
                                        if (argument.type ===
                                            utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&
                                            (0, util_1.isParenlessArrowFunction)(argument, context.sourceCode)) {
                                            return [
                                                fixer.insertTextBefore(catchVariableInner, '('),
                                                fixer.insertTextAfter(catchVariableInner, ': unknown)'),
                                            ];
                                        }
                                        return [
                                            fixer.insertTextAfter(catchVariableInner, ': unknown'),
                                        ];
                                    },
                                },
                            ],
                        };
                    }
                    return {
                        node: catchVariableOuter,
                        suggest: [
                            {
                                messageId: 'wrongTypeAnnotationSuggestion',
                                fix: (fixer) => fixer.replaceText(catchVariableTypeAnnotation, ': unknown'),
                            },
                        ],
                    };
                }
                case utils_1.AST_NODE_TYPES.ArrayPattern: {
                    return {
                        node: catchVariableOuter,
                        messageId: 'useUnknownArrayDestructuringPattern',
                    };
                }
                case utils_1.AST_NODE_TYPES.ObjectPattern: {
                    return {
                        node: catchVariableOuter,
                        messageId: 'useUnknownObjectDestructuringPattern',
                    };
                }
                case utils_1.AST_NODE_TYPES.RestElement: {
                    const catchVariableTypeAnnotation = catchVariableInner.typeAnnotation;
                    if (catchVariableTypeAnnotation == null) {
                        return {
                            node: catchVariableOuter,
                            suggest: [
                                {
                                    messageId: 'addUnknownRestTypeAnnotationSuggestion',
                                    fix: (fixer) => fixer.insertTextAfter(catchVariableInner, ': [unknown]'),
                                },
                            ],
                        };
                    }
                    return {
                        node: catchVariableOuter,
                        suggest: [
                            {
                                messageId: 'wrongRestTypeAnnotationSuggestion',
                                fix: (fixer) => fixer.replaceText(catchVariableTypeAnnotation, ': [unknown]'),
                            },
                        ],
                    };
                }
            }
        }
        return {
            CallExpression({ arguments: args, callee }) {
                if (callee.type !== utils_1.AST_NODE_TYPES.MemberExpression) {
                    return;
                }
                const staticMemberAccessKey = (0, util_1.getStaticMemberAccessValue)(callee, context);
                if (!staticMemberAccessKey) {
                    return;
                }
                const promiseMethodInfo = [
                    { append: '', argIndexToCheck: 0, method: 'catch' },
                    { append: ' rejection', argIndexToCheck: 1, method: 'then' },
                ].find(({ method }) => staticMemberAccessKey === method);
                if (!promiseMethodInfo) {
                    return;
                }
                // Need to be enough args to check
                const { argIndexToCheck, ...data } = promiseMethodInfo;
                if (args.length < argIndexToCheck + 1) {
                    return;
                }
                // Argument to check, and all arguments before it, must be "ordinary" arguments (i.e. no spread arguments)
                // promise.catch(f), promise.catch(() => {}), promise.catch(<expression>, <<other-args>>)
                const argsToCheck = args.slice(0, argIndexToCheck + 1);
                if (argsToCheck.some(({ type }) => type === utils_1.AST_NODE_TYPES.SpreadElement)) {
                    return;
                }
                if (!tsutils.isThenableType(checker, esTreeNodeToTSNodeMap.get(callee), checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(callee.object)))) {
                    return;
                }
                // the `some` check above has already excluded `SpreadElement`, so we are safe to assert the same
                const argToCheck = argsToCheck[argIndexToCheck];
                for (const node of collectFlaggedNodes(argToCheck)) {
                    // We are now guaranteed to report, but we have a bit of work to do
                    // to determine exactly where, and whether we can fix it.
                    const overrides = refineReportIfPossible(node);
                    context.report({
                        node,
                        messageId: 'useUnknown',
                        data,
                        ...overrides,
                    });
                }
            },
        };
    },
});


--------------------------------------------------------------------------------
FILE: enum-utils\shared.d.ts
--------------------------------------------------------------------------------

import * as ts from 'typescript';
/**
 * Retrieve only the Enum literals from a type. for example:
 * - 123 --> []
 * - {} --> []
 * - Fruit.Apple --> [Fruit.Apple]
 * - Fruit.Apple | Vegetable.Lettuce --> [Fruit.Apple, Vegetable.Lettuce]
 * - Fruit.Apple | Vegetable.Lettuce | 123 --> [Fruit.Apple, Vegetable.Lettuce]
 * - T extends Fruit --> [Fruit]
 */
export declare function getEnumLiterals(type: ts.Type): ts.LiteralType[];
/**
 * A type can have 0 or more enum types. For example:
 * - 123 --> []
 * - {} --> []
 * - Fruit.Apple --> [Fruit]
 * - Fruit.Apple | Vegetable.Lettuce --> [Fruit, Vegetable]
 * - Fruit.Apple | Vegetable.Lettuce | 123 --> [Fruit, Vegetable]
 * - T extends Fruit --> [Fruit]
 */
export declare function getEnumTypes(typeChecker: ts.TypeChecker, type: ts.Type): ts.Type[];
/**
 * Returns the enum key that matches the given literal node, or null if none
 * match. For example:
 * ```ts
 * enum Fruit {
 *   Apple = 'apple',
 *   Banana = 'banana',
 * }
 *
 * getEnumKeyForLiteral([Fruit.Apple, Fruit.Banana], 'apple') --> 'Fruit.Apple'
 * getEnumKeyForLiteral([Fruit.Apple, Fruit.Banana], 'banana') --> 'Fruit.Banana'
 * getEnumKeyForLiteral([Fruit.Apple, Fruit.Banana], 'cherry') --> null
 * ```
 */
export declare function getEnumKeyForLiteral(enumLiterals: ts.LiteralType[], literal: unknown): string | null;


--------------------------------------------------------------------------------
FILE: enum-utils\shared.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnumLiterals = getEnumLiterals;
exports.getEnumTypes = getEnumTypes;
exports.getEnumKeyForLiteral = getEnumKeyForLiteral;
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../../util");
/*
 * If passed an enum member, returns the type of the parent. Otherwise,
 * returns itself.
 *
 * For example:
 * - `Fruit` --> `Fruit`
 * - `Fruit.Apple` --> `Fruit`
 */
function getBaseEnumType(typeChecker, type) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const symbol = type.getSymbol();
    if (!tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.EnumMember)) {
        return type;
    }
    return typeChecker.getTypeAtLocation(symbol.valueDeclaration.parent);
}
/**
 * Retrieve only the Enum literals from a type. for example:
 * - 123 --> []
 * - {} --> []
 * - Fruit.Apple --> [Fruit.Apple]
 * - Fruit.Apple | Vegetable.Lettuce --> [Fruit.Apple, Vegetable.Lettuce]
 * - Fruit.Apple | Vegetable.Lettuce | 123 --> [Fruit.Apple, Vegetable.Lettuce]
 * - T extends Fruit --> [Fruit]
 */
function getEnumLiterals(type) {
    return tsutils
        .unionConstituents(type)
        .filter((subType) => (0, util_1.isTypeFlagSet)(subType, ts.TypeFlags.EnumLiteral));
}
/**
 * A type can have 0 or more enum types. For example:
 * - 123 --> []
 * - {} --> []
 * - Fruit.Apple --> [Fruit]
 * - Fruit.Apple | Vegetable.Lettuce --> [Fruit, Vegetable]
 * - Fruit.Apple | Vegetable.Lettuce | 123 --> [Fruit, Vegetable]
 * - T extends Fruit --> [Fruit]
 */
function getEnumTypes(typeChecker, type) {
    return getEnumLiterals(type).map(type => getBaseEnumType(typeChecker, type));
}
/**
 * Returns the enum key that matches the given literal node, or null if none
 * match. For example:
 * ```ts
 * enum Fruit {
 *   Apple = 'apple',
 *   Banana = 'banana',
 * }
 *
 * getEnumKeyForLiteral([Fruit.Apple, Fruit.Banana], 'apple') --> 'Fruit.Apple'
 * getEnumKeyForLiteral([Fruit.Apple, Fruit.Banana], 'banana') --> 'Fruit.Banana'
 * getEnumKeyForLiteral([Fruit.Apple, Fruit.Banana], 'cherry') --> null
 * ```
 */
function getEnumKeyForLiteral(enumLiterals, literal) {
    for (const enumLiteral of enumLiterals) {
        if (enumLiteral.value === literal) {
            const { symbol } = enumLiteral;
            const memberDeclaration = symbol.valueDeclaration;
            const enumDeclaration = memberDeclaration.parent;
            const memberNameIdentifier = memberDeclaration.name;
            const enumName = enumDeclaration.name.text;
            switch (memberNameIdentifier.kind) {
                case ts.SyntaxKind.Identifier:
                    return `${enumName}.${memberNameIdentifier.text}`;
                case ts.SyntaxKind.StringLiteral: {
                    const memberName = memberNameIdentifier.text.replaceAll("'", "\\'");
                    return `${enumName}['${memberName}']`;
                }
                case ts.SyntaxKind.ComputedPropertyName:
                    return `${enumName}[${memberNameIdentifier.expression.getText()}]`;
                default:
                    break;
            }
        }
    }
    return null;
}


--------------------------------------------------------------------------------
FILE: naming-convention-utils\enums.d.ts
--------------------------------------------------------------------------------

export declare enum PredefinedFormats {
    camelCase = 1,
    strictCamelCase = 2,
    PascalCase = 3,
    StrictPascalCase = 4,
    snake_case = 5,
    UPPER_CASE = 6
}
export type PredefinedFormatsString = keyof typeof PredefinedFormats;
export declare enum UnderscoreOptions {
    forbid = 1,
    allow = 2,
    require = 3,
    requireDouble = 4,
    allowDouble = 5,
    allowSingleOrDouble = 6
}
export type UnderscoreOptionsString = keyof typeof UnderscoreOptions;
export declare enum Selectors {
    variable = 1,
    function = 2,
    parameter = 4,
    parameterProperty = 8,
    classicAccessor = 16,
    enumMember = 32,
    classMethod = 64,
    objectLiteralMethod = 128,
    typeMethod = 256,
    classProperty = 512,
    objectLiteralProperty = 1024,
    typeProperty = 2048,
    autoAccessor = 4096,
    class = 8192,
    interface = 16384,
    typeAlias = 32768,
    enum = 65536,
    typeParameter = 131072,
    import = 262144
}
export type SelectorsString = keyof typeof Selectors;
export declare enum MetaSelectors {
    default = -1,
    variableLike = 7,
    memberLike = 8184,
    typeLike = 253952,
    method = 448,
    property = 3584,
    accessor = 4112
}
export type MetaSelectorsString = keyof typeof MetaSelectors;
export type IndividualAndMetaSelectorsString = MetaSelectorsString | SelectorsString;
export declare enum Modifiers {
    const = 1,
    readonly = 2,
    static = 4,
    public = 8,
    protected = 16,
    private = 32,
    '#private' = 64,
    abstract = 128,
    destructured = 256,
    global = 512,
    exported = 1024,
    unused = 2048,
    requiresQuotes = 4096,
    override = 8192,
    async = 16384,
    default = 32768,
    namespace = 65536
}
export type ModifiersString = keyof typeof Modifiers;
export declare enum TypeModifiers {
    boolean = 131072,
    string = 262144,
    number = 524288,
    function = 1048576,
    array = 2097152
}
export type TypeModifiersString = keyof typeof TypeModifiers;


--------------------------------------------------------------------------------
FILE: naming-convention-utils\enums.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeModifiers = exports.Modifiers = exports.MetaSelectors = exports.Selectors = exports.UnderscoreOptions = exports.PredefinedFormats = void 0;
var PredefinedFormats;
(function (PredefinedFormats) {
    PredefinedFormats[PredefinedFormats["camelCase"] = 1] = "camelCase";
    PredefinedFormats[PredefinedFormats["strictCamelCase"] = 2] = "strictCamelCase";
    PredefinedFormats[PredefinedFormats["PascalCase"] = 3] = "PascalCase";
    PredefinedFormats[PredefinedFormats["StrictPascalCase"] = 4] = "StrictPascalCase";
    PredefinedFormats[PredefinedFormats["snake_case"] = 5] = "snake_case";
    PredefinedFormats[PredefinedFormats["UPPER_CASE"] = 6] = "UPPER_CASE";
})(PredefinedFormats || (exports.PredefinedFormats = PredefinedFormats = {}));
var UnderscoreOptions;
(function (UnderscoreOptions) {
    UnderscoreOptions[UnderscoreOptions["forbid"] = 1] = "forbid";
    UnderscoreOptions[UnderscoreOptions["allow"] = 2] = "allow";
    UnderscoreOptions[UnderscoreOptions["require"] = 3] = "require";
    // special cases as it's common practice to use double underscore
    UnderscoreOptions[UnderscoreOptions["requireDouble"] = 4] = "requireDouble";
    UnderscoreOptions[UnderscoreOptions["allowDouble"] = 5] = "allowDouble";
    UnderscoreOptions[UnderscoreOptions["allowSingleOrDouble"] = 6] = "allowSingleOrDouble";
})(UnderscoreOptions || (exports.UnderscoreOptions = UnderscoreOptions = {}));
var Selectors;
(function (Selectors) {
    // variableLike
    Selectors[Selectors["variable"] = 1] = "variable";
    Selectors[Selectors["function"] = 2] = "function";
    Selectors[Selectors["parameter"] = 4] = "parameter";
    // memberLike
    Selectors[Selectors["parameterProperty"] = 8] = "parameterProperty";
    Selectors[Selectors["classicAccessor"] = 16] = "classicAccessor";
    Selectors[Selectors["enumMember"] = 32] = "enumMember";
    Selectors[Selectors["classMethod"] = 64] = "classMethod";
    Selectors[Selectors["objectLiteralMethod"] = 128] = "objectLiteralMethod";
    Selectors[Selectors["typeMethod"] = 256] = "typeMethod";
    Selectors[Selectors["classProperty"] = 512] = "classProperty";
    Selectors[Selectors["objectLiteralProperty"] = 1024] = "objectLiteralProperty";
    Selectors[Selectors["typeProperty"] = 2048] = "typeProperty";
    Selectors[Selectors["autoAccessor"] = 4096] = "autoAccessor";
    // typeLike
    Selectors[Selectors["class"] = 8192] = "class";
    Selectors[Selectors["interface"] = 16384] = "interface";
    Selectors[Selectors["typeAlias"] = 32768] = "typeAlias";
    Selectors[Selectors["enum"] = 65536] = "enum";
    Selectors[Selectors["typeParameter"] = 131072] = "typeParameter";
    // other
    Selectors[Selectors["import"] = 262144] = "import";
})(Selectors || (exports.Selectors = Selectors = {}));
var MetaSelectors;
(function (MetaSelectors) {
    /* eslint-disable @typescript-eslint/prefer-literal-enum-member */
    MetaSelectors[MetaSelectors["default"] = -1] = "default";
    MetaSelectors[MetaSelectors["variableLike"] = 7] = "variableLike";
    MetaSelectors[MetaSelectors["memberLike"] = 8184] = "memberLike";
    MetaSelectors[MetaSelectors["typeLike"] = 253952] = "typeLike";
    MetaSelectors[MetaSelectors["method"] = 448] = "method";
    MetaSelectors[MetaSelectors["property"] = 3584] = "property";
    MetaSelectors[MetaSelectors["accessor"] = 4112] = "accessor";
    /* eslint-enable @typescript-eslint/prefer-literal-enum-member */
})(MetaSelectors || (exports.MetaSelectors = MetaSelectors = {}));
var Modifiers;
(function (Modifiers) {
    // const variable
    Modifiers[Modifiers["const"] = 1] = "const";
    // readonly members
    Modifiers[Modifiers["readonly"] = 2] = "readonly";
    // static members
    Modifiers[Modifiers["static"] = 4] = "static";
    // member accessibility
    Modifiers[Modifiers["public"] = 8] = "public";
    Modifiers[Modifiers["protected"] = 16] = "protected";
    Modifiers[Modifiers["private"] = 32] = "private";
    Modifiers[Modifiers["#private"] = 64] = "#private";
    Modifiers[Modifiers["abstract"] = 128] = "abstract";
    // destructured variable
    Modifiers[Modifiers["destructured"] = 256] = "destructured";
    // variables declared in the top-level scope
    Modifiers[Modifiers["global"] = 512] = "global";
    // things that are exported
    Modifiers[Modifiers["exported"] = 1024] = "exported";
    // things that are unused
    Modifiers[Modifiers["unused"] = 2048] = "unused";
    // properties that require quoting
    Modifiers[Modifiers["requiresQuotes"] = 4096] = "requiresQuotes";
    // class members that are overridden
    Modifiers[Modifiers["override"] = 8192] = "override";
    // class methods, object function properties, or functions that are async via the `async` keyword
    Modifiers[Modifiers["async"] = 16384] = "async";
    // default imports
    Modifiers[Modifiers["default"] = 32768] = "default";
    // namespace imports
    Modifiers[Modifiers["namespace"] = 65536] = "namespace";
    // make sure TypeModifiers starts at Modifiers + 1 or else sorting won't work
})(Modifiers || (exports.Modifiers = Modifiers = {}));
var TypeModifiers;
(function (TypeModifiers) {
    TypeModifiers[TypeModifiers["boolean"] = 131072] = "boolean";
    TypeModifiers[TypeModifiers["string"] = 262144] = "string";
    TypeModifiers[TypeModifiers["number"] = 524288] = "number";
    TypeModifiers[TypeModifiers["function"] = 1048576] = "function";
    TypeModifiers[TypeModifiers["array"] = 2097152] = "array";
})(TypeModifiers || (exports.TypeModifiers = TypeModifiers = {}));


--------------------------------------------------------------------------------
FILE: naming-convention-utils\format.d.ts
--------------------------------------------------------------------------------

import { PredefinedFormats } from './enums';
export declare const PredefinedFormatToCheckFunction: Readonly<Record<PredefinedFormats, (name: string) => boolean>>;


--------------------------------------------------------------------------------
FILE: naming-convention-utils\format.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PredefinedFormatToCheckFunction = void 0;
const enums_1 = require("./enums");
/*
These format functions are taken from `tslint-consistent-codestyle/naming-convention`:
https://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/rules/namingConventionRule.ts#L603-L645

The license for the code can be viewed here:
https://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/LICENSE
*/
/*
Why not regex here? Because it's actually really, really difficult to create a regex to handle
all of the unicode cases, and we have many non-english users that use non-english characters.
https://gist.github.com/mathiasbynens/6334847
*/
function isPascalCase(name) {
    return (name.length === 0 ||
        (name[0] === name[0].toUpperCase() && !name.includes('_')));
}
function isStrictPascalCase(name) {
    return (name.length === 0 ||
        (name[0] === name[0].toUpperCase() && hasStrictCamelHumps(name, true)));
}
function isCamelCase(name) {
    return (name.length === 0 ||
        (name[0] === name[0].toLowerCase() && !name.includes('_')));
}
function isStrictCamelCase(name) {
    return (name.length === 0 ||
        (name[0] === name[0].toLowerCase() && hasStrictCamelHumps(name, false)));
}
function hasStrictCamelHumps(name, isUpper) {
    function isUppercaseChar(char) {
        return char === char.toUpperCase() && char !== char.toLowerCase();
    }
    if (name.startsWith('_')) {
        return false;
    }
    for (let i = 1; i < name.length; ++i) {
        if (name[i] === '_') {
            return false;
        }
        if (isUpper === isUppercaseChar(name[i])) {
            if (isUpper) {
                return false;
            }
        }
        else {
            isUpper = !isUpper;
        }
    }
    return true;
}
function isSnakeCase(name) {
    return (name.length === 0 ||
        (name === name.toLowerCase() && validateUnderscores(name)));
}
function isUpperCase(name) {
    return (name.length === 0 ||
        (name === name.toUpperCase() && validateUnderscores(name)));
}
/** Check for leading trailing and adjacent underscores */
function validateUnderscores(name) {
    if (name.startsWith('_')) {
        return false;
    }
    let wasUnderscore = false;
    for (let i = 1; i < name.length; ++i) {
        if (name[i] === '_') {
            if (wasUnderscore) {
                return false;
            }
            wasUnderscore = true;
        }
        else {
            wasUnderscore = false;
        }
    }
    return !wasUnderscore;
}
exports.PredefinedFormatToCheckFunction = {
    [enums_1.PredefinedFormats.camelCase]: isCamelCase,
    [enums_1.PredefinedFormats.PascalCase]: isPascalCase,
    [enums_1.PredefinedFormats.snake_case]: isSnakeCase,
    [enums_1.PredefinedFormats.strictCamelCase]: isStrictCamelCase,
    [enums_1.PredefinedFormats.StrictPascalCase]: isStrictPascalCase,
    [enums_1.PredefinedFormats.UPPER_CASE]: isUpperCase,
};


--------------------------------------------------------------------------------
FILE: naming-convention-utils\index.d.ts
--------------------------------------------------------------------------------

export { Modifiers } from './enums';
export type { PredefinedFormatsString } from './enums';
export { parseOptions } from './parse-options';
export { SCHEMA } from './schema';
export { selectorTypeToMessageString } from './shared';
export type { Context, Selector, ValidatorFunction } from './types';


--------------------------------------------------------------------------------
FILE: naming-convention-utils\index.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectorTypeToMessageString = exports.SCHEMA = exports.parseOptions = exports.Modifiers = void 0;
var enums_1 = require("./enums");
Object.defineProperty(exports, "Modifiers", { enumerable: true, get: function () { return enums_1.Modifiers; } });
var parse_options_1 = require("./parse-options");
Object.defineProperty(exports, "parseOptions", { enumerable: true, get: function () { return parse_options_1.parseOptions; } });
var schema_1 = require("./schema");
Object.defineProperty(exports, "SCHEMA", { enumerable: true, get: function () { return schema_1.SCHEMA; } });
var shared_1 = require("./shared");
Object.defineProperty(exports, "selectorTypeToMessageString", { enumerable: true, get: function () { return shared_1.selectorTypeToMessageString; } });


--------------------------------------------------------------------------------
FILE: naming-convention-utils\parse-options.d.ts
--------------------------------------------------------------------------------

import type { Context, ParsedOptions } from './types';
export declare function parseOptions(context: Context): ParsedOptions;


--------------------------------------------------------------------------------
FILE: naming-convention-utils\parse-options.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOptions = parseOptions;
const util_1 = require("../../util");
const enums_1 = require("./enums");
const shared_1 = require("./shared");
const validator_1 = require("./validator");
function normalizeOption(option) {
    let weight = 0;
    option.modifiers?.forEach(mod => {
        weight |= enums_1.Modifiers[mod];
    });
    option.types?.forEach(mod => {
        weight |= enums_1.TypeModifiers[mod];
    });
    // give selectors with a filter the _highest_ priority
    if (option.filter) {
        weight |= 1 << 30;
    }
    const normalizedOption = {
        // format options
        custom: option.custom
            ? {
                match: option.custom.match,
                regex: new RegExp(option.custom.regex, 'u'),
            }
            : null,
        filter: option.filter != null
            ? typeof option.filter === 'string'
                ? {
                    match: true,
                    regex: new RegExp(option.filter, 'u'),
                }
                : {
                    match: option.filter.match,
                    regex: new RegExp(option.filter.regex, 'u'),
                }
            : null,
        format: option.format ? option.format.map(f => enums_1.PredefinedFormats[f]) : null,
        leadingUnderscore: option.leadingUnderscore != null
            ? enums_1.UnderscoreOptions[option.leadingUnderscore]
            : null,
        modifiers: option.modifiers?.map(m => enums_1.Modifiers[m]) ?? null,
        prefix: option.prefix && option.prefix.length > 0 ? option.prefix : null,
        suffix: option.suffix && option.suffix.length > 0 ? option.suffix : null,
        trailingUnderscore: option.trailingUnderscore != null
            ? enums_1.UnderscoreOptions[option.trailingUnderscore]
            : null,
        types: option.types?.map(m => enums_1.TypeModifiers[m]) ?? null,
        // calculated ordering weight based on modifiers
        modifierWeight: weight,
    };
    const selectors = Array.isArray(option.selector)
        ? option.selector
        : [option.selector];
    return selectors.map(selector => ({
        selector: (0, shared_1.isMetaSelector)(selector)
            ? enums_1.MetaSelectors[selector]
            : enums_1.Selectors[selector],
        ...normalizedOption,
    }));
}
function parseOptions(context) {
    const normalizedOptions = context.options.flatMap(normalizeOption);
    return Object.fromEntries((0, util_1.getEnumNames)(enums_1.Selectors).map(k => [
        k,
        (0, validator_1.createValidator)(k, context, normalizedOptions),
    ]));
}


--------------------------------------------------------------------------------
FILE: naming-convention-utils\schema.d.ts
--------------------------------------------------------------------------------

import type { JSONSchema } from '@typescript-eslint/utils';
export declare const SCHEMA: JSONSchema.JSONSchema4;


--------------------------------------------------------------------------------
FILE: naming-convention-utils\schema.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SCHEMA = void 0;
const util_1 = require("../../util");
const enums_1 = require("./enums");
const $DEFS = {
    // enums
    predefinedFormats: {
        enum: (0, util_1.getEnumNames)(enums_1.PredefinedFormats),
        type: 'string',
    },
    typeModifiers: {
        enum: (0, util_1.getEnumNames)(enums_1.TypeModifiers),
        type: 'string',
    },
    underscoreOptions: {
        enum: (0, util_1.getEnumNames)(enums_1.UnderscoreOptions),
        type: 'string',
    },
    // repeated types
    formatOptionsConfig: {
        oneOf: [
            {
                additionalItems: false,
                items: {
                    $ref: '#/$defs/predefinedFormats',
                },
                type: 'array',
            },
            {
                type: 'null',
            },
        ],
    },
    matchRegexConfig: {
        additionalProperties: false,
        properties: {
            match: { type: 'boolean' },
            regex: { type: 'string' },
        },
        required: ['match', 'regex'],
        type: 'object',
    },
    prefixSuffixConfig: {
        additionalItems: false,
        items: {
            minLength: 1,
            type: 'string',
        },
        type: 'array',
    },
};
const UNDERSCORE_SCHEMA = {
    $ref: '#/$defs/underscoreOptions',
};
const PREFIX_SUFFIX_SCHEMA = {
    $ref: '#/$defs/prefixSuffixConfig',
};
const MATCH_REGEX_SCHEMA = {
    $ref: '#/$defs/matchRegexConfig',
};
const FORMAT_OPTIONS_PROPERTIES = {
    custom: MATCH_REGEX_SCHEMA,
    failureMessage: {
        type: 'string',
    },
    format: {
        $ref: '#/$defs/formatOptionsConfig',
    },
    leadingUnderscore: UNDERSCORE_SCHEMA,
    prefix: PREFIX_SUFFIX_SCHEMA,
    suffix: PREFIX_SUFFIX_SCHEMA,
    trailingUnderscore: UNDERSCORE_SCHEMA,
};
function selectorSchema(selectorString, allowType, modifiers) {
    const selector = {
        filter: {
            oneOf: [
                {
                    minLength: 1,
                    type: 'string',
                },
                MATCH_REGEX_SCHEMA,
            ],
        },
        selector: {
            enum: [selectorString],
            type: 'string',
        },
    };
    if (modifiers && modifiers.length > 0) {
        selector.modifiers = {
            additionalItems: false,
            items: {
                enum: modifiers,
                type: 'string',
            },
            type: 'array',
        };
    }
    if (allowType) {
        selector.types = {
            additionalItems: false,
            items: {
                $ref: '#/$defs/typeModifiers',
            },
            type: 'array',
        };
    }
    return [
        {
            additionalProperties: false,
            description: `Selector '${selectorString}'`,
            properties: {
                ...FORMAT_OPTIONS_PROPERTIES,
                ...selector,
            },
            required: ['selector', 'format'],
            type: 'object',
        },
    ];
}
function selectorsSchema() {
    return {
        additionalProperties: false,
        description: 'Multiple selectors in one config',
        properties: {
            ...FORMAT_OPTIONS_PROPERTIES,
            filter: {
                oneOf: [
                    {
                        minLength: 1,
                        type: 'string',
                    },
                    MATCH_REGEX_SCHEMA,
                ],
            },
            modifiers: {
                additionalItems: false,
                items: {
                    enum: (0, util_1.getEnumNames)(enums_1.Modifiers),
                    type: 'string',
                },
                type: 'array',
            },
            selector: {
                additionalItems: false,
                items: {
                    enum: [...(0, util_1.getEnumNames)(enums_1.MetaSelectors), ...(0, util_1.getEnumNames)(enums_1.Selectors)],
                    type: 'string',
                },
                type: 'array',
            },
            types: {
                additionalItems: false,
                items: {
                    $ref: '#/$defs/typeModifiers',
                },
                type: 'array',
            },
        },
        required: ['selector', 'format'],
        type: 'object',
    };
}
exports.SCHEMA = {
    $defs: $DEFS,
    additionalItems: false,
    items: {
        oneOf: [
            selectorsSchema(),
            ...selectorSchema('default', false, (0, util_1.getEnumNames)(enums_1.Modifiers)),
            ...selectorSchema('variableLike', false, ['unused', 'async']),
            ...selectorSchema('variable', true, [
                'const',
                'destructured',
                'exported',
                'global',
                'unused',
                'async',
            ]),
            ...selectorSchema('function', false, [
                'exported',
                'global',
                'unused',
                'async',
            ]),
            ...selectorSchema('parameter', true, ['destructured', 'unused']),
            ...selectorSchema('memberLike', false, [
                'abstract',
                'private',
                '#private',
                'protected',
                'public',
                'readonly',
                'requiresQuotes',
                'static',
                'override',
                'async',
            ]),
            ...selectorSchema('classProperty', true, [
                'abstract',
                'private',
                '#private',
                'protected',
                'public',
                'readonly',
                'requiresQuotes',
                'static',
                'override',
            ]),
            ...selectorSchema('objectLiteralProperty', true, [
                'public',
                'requiresQuotes',
            ]),
            ...selectorSchema('typeProperty', true, [
                'public',
                'readonly',
                'requiresQuotes',
            ]),
            ...selectorSchema('parameterProperty', true, [
                'private',
                'protected',
                'public',
                'readonly',
            ]),
            ...selectorSchema('property', true, [
                'abstract',
                'private',
                '#private',
                'protected',
                'public',
                'readonly',
                'requiresQuotes',
                'static',
                'override',
                'async',
            ]),
            ...selectorSchema('classMethod', false, [
                'abstract',
                'private',
                '#private',
                'protected',
                'public',
                'requiresQuotes',
                'static',
                'override',
                'async',
            ]),
            ...selectorSchema('objectLiteralMethod', false, [
                'public',
                'requiresQuotes',
                'async',
            ]),
            ...selectorSchema('typeMethod', false, ['public', 'requiresQuotes']),
            ...selectorSchema('method', false, [
                'abstract',
                'private',
                '#private',
                'protected',
                'public',
                'requiresQuotes',
                'static',
                'override',
                'async',
            ]),
            ...selectorSchema('classicAccessor', true, [
                'abstract',
                'private',
                'protected',
                'public',
                'requiresQuotes',
                'static',
                'override',
            ]),
            ...selectorSchema('autoAccessor', true, [
                'abstract',
                'private',
                'protected',
                'public',
                'requiresQuotes',
                'static',
                'override',
            ]),
            ...selectorSchema('accessor', true, [
                'abstract',
                'private',
                'protected',
                'public',
                'requiresQuotes',
                'static',
                'override',
            ]),
            ...selectorSchema('enumMember', false, ['requiresQuotes']),
            ...selectorSchema('typeLike', false, ['abstract', 'exported', 'unused']),
            ...selectorSchema('class', false, ['abstract', 'exported', 'unused']),
            ...selectorSchema('interface', false, ['exported', 'unused']),
            ...selectorSchema('typeAlias', false, ['exported', 'unused']),
            ...selectorSchema('enum', false, ['exported', 'unused']),
            ...selectorSchema('typeParameter', false, ['unused']),
            ...selectorSchema('import', false, ['default', 'namespace']),
        ],
    },
    type: 'array',
};


--------------------------------------------------------------------------------
FILE: naming-convention-utils\shared.d.ts
--------------------------------------------------------------------------------

import type { IndividualAndMetaSelectorsString, MetaSelectorsString, Selectors, SelectorsString } from './enums';
import { MetaSelectors } from './enums';
export declare function selectorTypeToMessageString(selectorType: SelectorsString): string;
export declare function isMetaSelector(selector: IndividualAndMetaSelectorsString | MetaSelectors | Selectors): selector is MetaSelectorsString;
export declare function isMethodOrPropertySelector(selector: IndividualAndMetaSelectorsString | MetaSelectors | Selectors): boolean;


--------------------------------------------------------------------------------
FILE: naming-convention-utils\shared.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectorTypeToMessageString = selectorTypeToMessageString;
exports.isMetaSelector = isMetaSelector;
exports.isMethodOrPropertySelector = isMethodOrPropertySelector;
const enums_1 = require("./enums");
function selectorTypeToMessageString(selectorType) {
    const notCamelCase = selectorType.replaceAll(/([A-Z])/g, ' $1');
    return notCamelCase.charAt(0).toUpperCase() + notCamelCase.slice(1);
}
function isMetaSelector(selector) {
    return selector in enums_1.MetaSelectors;
}
function isMethodOrPropertySelector(selector) {
    return (selector === enums_1.MetaSelectors.method || selector === enums_1.MetaSelectors.property);
}


--------------------------------------------------------------------------------
FILE: naming-convention-utils\types.d.ts
--------------------------------------------------------------------------------

import type { TSESLint, TSESTree } from '@typescript-eslint/utils';
import type { MessageIds, Options } from '../naming-convention';
import type { IndividualAndMetaSelectorsString, MetaSelectors, Modifiers, ModifiersString, PredefinedFormats, PredefinedFormatsString, Selectors, SelectorsString, TypeModifiers, TypeModifiersString, UnderscoreOptions, UnderscoreOptionsString } from './enums';
export interface MatchRegex {
    match: boolean;
    regex: string;
}
export interface Selector {
    custom?: MatchRegex;
    filter?: string | MatchRegex;
    format: PredefinedFormatsString[] | null;
    leadingUnderscore?: UnderscoreOptionsString;
    modifiers?: ModifiersString[];
    prefix?: string[];
    selector: IndividualAndMetaSelectorsString | IndividualAndMetaSelectorsString[];
    suffix?: string[];
    trailingUnderscore?: UnderscoreOptionsString;
    types?: TypeModifiersString[];
}
export interface NormalizedMatchRegex {
    match: boolean;
    regex: RegExp;
}
export interface NormalizedSelector {
    custom: NormalizedMatchRegex | null;
    filter: NormalizedMatchRegex | null;
    format: PredefinedFormats[] | null;
    leadingUnderscore: UnderscoreOptions | null;
    modifiers: Modifiers[] | null;
    modifierWeight: number;
    prefix: string[] | null;
    selector: MetaSelectors | Selectors;
    suffix: string[] | null;
    trailingUnderscore: UnderscoreOptions | null;
    types: TypeModifiers[] | null;
}
export type ValidatorFunction = (node: TSESTree.Identifier | TSESTree.Literal | TSESTree.PrivateIdentifier, modifiers?: Set<Modifiers>) => void;
export type ParsedOptions = Record<SelectorsString, ValidatorFunction>;
export type Context = Readonly<TSESLint.RuleContext<MessageIds, Options>>;


--------------------------------------------------------------------------------
FILE: naming-convention-utils\types.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


--------------------------------------------------------------------------------
FILE: naming-convention-utils\validator.d.ts
--------------------------------------------------------------------------------

import type { SelectorsString } from './enums';
import type { Context, NormalizedSelector, ValidatorFunction } from './types';
export declare function createValidator(type: SelectorsString, context: Context, allConfigs: NormalizedSelector[]): ValidatorFunction;


--------------------------------------------------------------------------------
FILE: naming-convention-utils\validator.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createValidator = createValidator;
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../../util");
const enums_1 = require("./enums");
const format_1 = require("./format");
const shared_1 = require("./shared");
function createValidator(type, context, allConfigs) {
    // make sure the "highest priority" configs are checked first
    const selectorType = enums_1.Selectors[type];
    const configs = allConfigs
        // gather all of the applicable selectors
        .filter(c => (c.selector & selectorType) !== 0 ||
        c.selector === enums_1.MetaSelectors.default)
        .sort((a, b) => {
        if (a.selector === b.selector) {
            // in the event of the same selector, order by modifier weight
            // sort descending - the type modifiers are "more important"
            return b.modifierWeight - a.modifierWeight;
        }
        const aIsMeta = (0, shared_1.isMetaSelector)(a.selector);
        const bIsMeta = (0, shared_1.isMetaSelector)(b.selector);
        // non-meta selectors should go ahead of meta selectors
        if (aIsMeta && !bIsMeta) {
            return 1;
        }
        if (!aIsMeta && bIsMeta) {
            return -1;
        }
        const aIsMethodOrProperty = (0, shared_1.isMethodOrPropertySelector)(a.selector);
        const bIsMethodOrProperty = (0, shared_1.isMethodOrPropertySelector)(b.selector);
        // for backward compatibility, method and property have higher precedence than other meta selectors
        if (aIsMethodOrProperty && !bIsMethodOrProperty) {
            return -1;
        }
        if (!aIsMethodOrProperty && bIsMethodOrProperty) {
            return 1;
        }
        // both aren't meta selectors
        // sort descending - the meta selectors are "least important"
        return b.selector - a.selector;
    });
    return (node, modifiers = new Set()) => {
        const originalName = node.type === utils_1.AST_NODE_TYPES.Identifier ||
            node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier
            ? node.name
            : `${node.value}`;
        // return will break the loop and stop checking configs
        // it is only used when the name is known to have failed or succeeded a config.
        for (const config of configs) {
            if (config.filter?.regex.test(originalName) !== config.filter?.match) {
                // name does not match the filter
                continue;
            }
            if (config.modifiers?.some(modifier => !modifiers.has(modifier))) {
                // does not have the required modifiers
                continue;
            }
            if (!isCorrectType(node, config, context, selectorType)) {
                // is not the correct type
                continue;
            }
            let name = originalName;
            name = validateUnderscore('leading', config, name, node, originalName);
            if (name == null) {
                // fail
                return;
            }
            name = validateUnderscore('trailing', config, name, node, originalName);
            if (name == null) {
                // fail
                return;
            }
            name = validateAffix('prefix', config, name, node, originalName);
            if (name == null) {
                // fail
                return;
            }
            name = validateAffix('suffix', config, name, node, originalName);
            if (name == null) {
                // fail
                return;
            }
            if (!validateCustom(config, name, node, originalName)) {
                // fail
                return;
            }
            if (!validatePredefinedFormat(config, name, node, originalName, modifiers)) {
                // fail
                return;
            }
            // it's valid for this config, so we don't need to check any more configs
            return;
        }
    };
    // centralizes the logic for formatting the report data
    function formatReportData({ affixes, count, custom, formats, originalName, position, processedName, }) {
        return {
            affixes: affixes?.join(', '),
            count,
            formats: formats?.map(f => enums_1.PredefinedFormats[f]).join(', '),
            name: originalName,
            position,
            processedName,
            regex: custom?.regex.toString(),
            regexMatch: custom?.match === true
                ? 'match'
                : custom?.match === false
                    ? 'not match'
                    : null,
            type: (0, shared_1.selectorTypeToMessageString)(type),
        };
    }
    /**
     * @returns the name with the underscore removed, if it is valid according to the specified underscore option, null otherwise
     */
    function validateUnderscore(position, config, name, node, originalName) {
        const option = position === 'leading'
            ? config.leadingUnderscore
            : config.trailingUnderscore;
        if (!option) {
            return name;
        }
        const hasSingleUnderscore = position === 'leading'
            ? () => name.startsWith('_')
            : () => name.endsWith('_');
        const trimSingleUnderscore = position === 'leading'
            ? () => name.slice(1)
            : () => name.slice(0, -1);
        const hasDoubleUnderscore = position === 'leading'
            ? () => name.startsWith('__')
            : () => name.endsWith('__');
        const trimDoubleUnderscore = position === 'leading'
            ? () => name.slice(2)
            : () => name.slice(0, -2);
        switch (option) {
            // ALLOW - no conditions as the user doesn't care if it's there or not
            case enums_1.UnderscoreOptions.allow: {
                if (hasSingleUnderscore()) {
                    return trimSingleUnderscore();
                }
                return name;
            }
            case enums_1.UnderscoreOptions.allowDouble: {
                if (hasDoubleUnderscore()) {
                    return trimDoubleUnderscore();
                }
                return name;
            }
            case enums_1.UnderscoreOptions.allowSingleOrDouble: {
                if (hasDoubleUnderscore()) {
                    return trimDoubleUnderscore();
                }
                if (hasSingleUnderscore()) {
                    return trimSingleUnderscore();
                }
                return name;
            }
            // FORBID
            case enums_1.UnderscoreOptions.forbid: {
                if (hasSingleUnderscore()) {
                    context.report({
                        data: formatReportData({
                            count: 'one',
                            originalName,
                            position,
                        }),
                        messageId: 'unexpectedUnderscore',
                        node,
                    });
                    return null;
                }
                return name;
            }
            // REQUIRE
            case enums_1.UnderscoreOptions.require: {
                if (!hasSingleUnderscore()) {
                    context.report({
                        data: formatReportData({
                            count: 'one',
                            originalName,
                            position,
                        }),
                        messageId: 'missingUnderscore',
                        node,
                    });
                    return null;
                }
                return trimSingleUnderscore();
            }
            case enums_1.UnderscoreOptions.requireDouble: {
                if (!hasDoubleUnderscore()) {
                    context.report({
                        data: formatReportData({
                            count: 'two',
                            originalName,
                            position,
                        }),
                        messageId: 'missingUnderscore',
                        node,
                    });
                    return null;
                }
                return trimDoubleUnderscore();
            }
        }
    }
    /**
     * @returns the name with the affix removed, if it is valid according to the specified affix option, null otherwise
     */
    function validateAffix(position, config, name, node, originalName) {
        const affixes = config[position];
        if (!affixes || affixes.length === 0) {
            return name;
        }
        for (const affix of affixes) {
            const hasAffix = position === 'prefix' ? name.startsWith(affix) : name.endsWith(affix);
            const trimAffix = position === 'prefix'
                ? () => name.slice(affix.length)
                : () => name.slice(0, -affix.length);
            if (hasAffix) {
                // matches, so trim it and return
                return trimAffix();
            }
        }
        context.report({
            data: formatReportData({
                affixes,
                originalName,
                position,
            }),
            messageId: 'missingAffix',
            node,
        });
        return null;
    }
    /**
     * @returns true if the name is valid according to the `regex` option, false otherwise
     */
    function validateCustom(config, name, node, originalName) {
        const custom = config.custom;
        if (!custom) {
            return true;
        }
        const result = custom.regex.test(name);
        if (custom.match && result) {
            return true;
        }
        if (!custom.match && !result) {
            return true;
        }
        context.report({
            data: formatReportData({
                custom,
                originalName,
            }),
            messageId: 'satisfyCustom',
            node,
        });
        return false;
    }
    /**
     * @returns true if the name is valid according to the `format` option, false otherwise
     */
    function validatePredefinedFormat(config, name, node, originalName, modifiers) {
        const formats = config.format;
        if (!formats?.length) {
            return true;
        }
        if (!modifiers.has(enums_1.Modifiers.requiresQuotes)) {
            for (const format of formats) {
                const checker = format_1.PredefinedFormatToCheckFunction[format];
                if (checker(name)) {
                    return true;
                }
            }
        }
        context.report({
            data: formatReportData({
                formats,
                originalName,
                processedName: name,
            }),
            messageId: originalName === name
                ? 'doesNotMatchFormat'
                : 'doesNotMatchFormatTrimmed',
            node,
        });
        return false;
    }
}
const SelectorsAllowedToHaveTypes = enums_1.Selectors.variable |
    enums_1.Selectors.parameter |
    enums_1.Selectors.classProperty |
    enums_1.Selectors.objectLiteralProperty |
    enums_1.Selectors.typeProperty |
    enums_1.Selectors.parameterProperty |
    enums_1.Selectors.classicAccessor;
function isCorrectType(node, config, context, selector) {
    if (config.types == null) {
        return true;
    }
    if ((SelectorsAllowedToHaveTypes & selector) === 0) {
        return true;
    }
    const services = (0, util_1.getParserServices)(context);
    const checker = services.program.getTypeChecker();
    const type = services
        .getTypeAtLocation(node)
        // remove null and undefined from the type, as we don't care about it here
        .getNonNullableType();
    for (const allowedType of config.types) {
        switch (allowedType) {
            case enums_1.TypeModifiers.array:
                if (isAllTypesMatch(type, t => checker.isArrayType(t) || checker.isTupleType(t))) {
                    return true;
                }
                break;
            case enums_1.TypeModifiers.function:
                if (isAllTypesMatch(type, t => t.getCallSignatures().length > 0)) {
                    return true;
                }
                break;
            case enums_1.TypeModifiers.boolean:
            case enums_1.TypeModifiers.number:
            case enums_1.TypeModifiers.string: {
                const typeString = checker.typeToString(
                // this will resolve things like true => boolean, 'a' => string and 1 => number
                checker.getWidenedType(checker.getBaseTypeOfLiteralType(type)));
                const allowedTypeString = enums_1.TypeModifiers[allowedType];
                if (typeString === allowedTypeString) {
                    return true;
                }
                break;
            }
        }
    }
    return false;
}
/**
 * @returns `true` if the type (or all union types) in the given type return true for the callback
 */
function isAllTypesMatch(type, cb) {
    if (type.isUnion()) {
        return type.types.every(t => cb(t));
    }
    return cb(type);
}


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\analyzeChain.d.ts
--------------------------------------------------------------------------------

import type { ParserServicesWithTypeInformation, TSESTree } from '@typescript-eslint/utils';
import type { RuleContext } from '@typescript-eslint/utils/ts-eslint';
import type { LastChainOperand, ValidOperand } from './gatherLogicalOperands';
import type { PreferOptionalChainMessageIds, PreferOptionalChainOptions } from './PreferOptionalChainOptions';
export declare function analyzeChain(context: RuleContext<PreferOptionalChainMessageIds, [
    PreferOptionalChainOptions
]>, parserServices: ParserServicesWithTypeInformation, options: PreferOptionalChainOptions, node: TSESTree.Node, operator: TSESTree.LogicalExpression['operator'], chain: ValidOperand[], lastChainOperand?: LastChainOperand): void;


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\analyzeChain.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeChain = analyzeChain;
const utils_1 = require("@typescript-eslint/utils");
const ts_api_utils_1 = require("ts-api-utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../../util");
const checkNullishAndReport_1 = require("./checkNullishAndReport");
const compareNodes_1 = require("./compareNodes");
const gatherLogicalOperands_1 = require("./gatherLogicalOperands");
function includesType(parserServices, node, typeFlagIn) {
    const typeFlag = typeFlagIn | ts.TypeFlags.Any | ts.TypeFlags.Unknown;
    const types = (0, ts_api_utils_1.unionConstituents)(parserServices.getTypeAtLocation(node));
    for (const type of types) {
        if ((0, util_1.isTypeFlagSet)(type, typeFlag)) {
            return true;
        }
    }
    return false;
}
function isValidAndLastChainOperand(ComparisonValueType, comparisonType, parserServices) {
    const type = parserServices.getTypeAtLocation(ComparisonValueType);
    const ANY_UNKNOWN_FLAGS = ts.TypeFlags.Any | ts.TypeFlags.Unknown;
    const types = (0, ts_api_utils_1.unionConstituents)(type);
    switch (comparisonType) {
        case gatherLogicalOperands_1.ComparisonType.Equal: {
            const isNullish = types.some(t => (0, util_1.isTypeFlagSet)(t, ANY_UNKNOWN_FLAGS | ts.TypeFlags.Null | ts.TypeFlags.Undefined));
            return !isNullish;
        }
        case gatherLogicalOperands_1.ComparisonType.StrictEqual: {
            const isUndefined = types.some(t => (0, util_1.isTypeFlagSet)(t, ANY_UNKNOWN_FLAGS | ts.TypeFlags.Undefined));
            return !isUndefined;
        }
        case gatherLogicalOperands_1.ComparisonType.NotStrictEqual: {
            return types.every(t => (0, util_1.isTypeFlagSet)(t, ts.TypeFlags.Undefined));
        }
        case gatherLogicalOperands_1.ComparisonType.NotEqual: {
            return types.every(t => (0, util_1.isTypeFlagSet)(t, ts.TypeFlags.Undefined | ts.TypeFlags.Null));
        }
    }
}
function isValidOrLastChainOperand(ComparisonValueType, comparisonType, parserServices) {
    const type = parserServices.getTypeAtLocation(ComparisonValueType);
    const ANY_UNKNOWN_FLAGS = ts.TypeFlags.Any | ts.TypeFlags.Unknown;
    const types = (0, ts_api_utils_1.unionConstituents)(type);
    switch (comparisonType) {
        case gatherLogicalOperands_1.ComparisonType.NotEqual: {
            const isNullish = types.some(t => (0, util_1.isTypeFlagSet)(t, ANY_UNKNOWN_FLAGS | ts.TypeFlags.Null | ts.TypeFlags.Undefined));
            return !isNullish;
        }
        case gatherLogicalOperands_1.ComparisonType.NotStrictEqual: {
            const isUndefined = types.some(t => (0, util_1.isTypeFlagSet)(t, ANY_UNKNOWN_FLAGS | ts.TypeFlags.Undefined));
            return !isUndefined;
        }
        case gatherLogicalOperands_1.ComparisonType.Equal:
            return types.every(t => (0, util_1.isTypeFlagSet)(t, ts.TypeFlags.Undefined | ts.TypeFlags.Null));
        case gatherLogicalOperands_1.ComparisonType.StrictEqual:
            return types.every(t => (0, util_1.isTypeFlagSet)(t, ts.TypeFlags.Undefined));
    }
}
const analyzeAndChainOperand = (parserServices, operand, index, chain) => {
    switch (operand.comparisonType) {
        case gatherLogicalOperands_1.NullishComparisonType.Boolean:
        case gatherLogicalOperands_1.NullishComparisonType.NotEqualNullOrUndefined:
            return [operand];
        case gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualNull: {
            // handle `x !== null && x !== undefined`
            const nextOperand = chain.at(index + 1);
            if (nextOperand?.comparisonType ===
                gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined &&
                (0, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===
                    compareNodes_1.NodeComparisonResult.Equal) {
                return [operand, nextOperand];
            }
            if (nextOperand &&
                !includesType(parserServices, operand.comparedName, ts.TypeFlags.Undefined)) {
                // we know the next operand is not an `undefined` check and that this
                // operand includes `undefined` - which means that making this an
                // optional chain would change the runtime behavior of the expression
                return [operand];
            }
            return null;
        }
        case gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined: {
            // handle `x !== undefined && x !== null`
            const nextOperand = chain.at(index + 1);
            if (nextOperand?.comparisonType ===
                gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualNull &&
                (0, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===
                    compareNodes_1.NodeComparisonResult.Equal) {
                return [operand, nextOperand];
            }
            if (includesType(parserServices, operand.comparedName, ts.TypeFlags.Null)) {
                // we know the next operand is not a `null` check and that this
                // operand includes `null` - which means that making this an
                // optional chain would change the runtime behavior of the expression
                return null;
            }
            return [operand];
        }
        default:
            return null;
    }
};
const analyzeOrChainOperand = (parserServices, operand, index, chain) => {
    switch (operand.comparisonType) {
        case gatherLogicalOperands_1.NullishComparisonType.NotBoolean:
        case gatherLogicalOperands_1.NullishComparisonType.EqualNullOrUndefined:
            return [operand];
        case gatherLogicalOperands_1.NullishComparisonType.StrictEqualNull: {
            // handle `x === null || x === undefined`
            const nextOperand = chain.at(index + 1);
            if (nextOperand?.comparisonType ===
                gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined &&
                (0, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===
                    compareNodes_1.NodeComparisonResult.Equal) {
                return [operand, nextOperand];
            }
            if (includesType(parserServices, operand.comparedName, ts.TypeFlags.Undefined)) {
                // we know the next operand is not an `undefined` check and that this
                // operand includes `undefined` - which means that making this an
                // optional chain would change the runtime behavior of the expression
                return null;
            }
            return [operand];
        }
        case gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined: {
            // handle `x === undefined || x === null`
            const nextOperand = chain.at(index + 1);
            if (nextOperand?.comparisonType === gatherLogicalOperands_1.NullishComparisonType.StrictEqualNull &&
                (0, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===
                    compareNodes_1.NodeComparisonResult.Equal) {
                return [operand, nextOperand];
            }
            if (includesType(parserServices, operand.comparedName, ts.TypeFlags.Null)) {
                // we know the next operand is not a `null` check and that this
                // operand includes `null` - which means that making this an
                // optional chain would change the runtime behavior of the expression
                return null;
            }
            return [operand];
        }
        default:
            return null;
    }
};
const resolveOperandSubset = (previousOperand, lastChainOperand) => {
    const isNameSubset = (0, compareNodes_1.compareNodes)(previousOperand.comparedName, lastChainOperand.comparedName) === compareNodes_1.NodeComparisonResult.Subset;
    if (lastChainOperand.yoda !== gatherLogicalOperands_1.Yoda.Unknown) {
        return {
            comparedName: lastChainOperand.comparedName,
            comparisonValue: lastChainOperand.comparisonValue,
            isSubset: isNameSubset,
            isYoda: lastChainOperand.yoda === gatherLogicalOperands_1.Yoda.Yes,
        };
    }
    const isValueSubset = (0, compareNodes_1.compareNodes)(previousOperand.comparedName, lastChainOperand.comparisonValue) === compareNodes_1.NodeComparisonResult.Subset;
    if (isNameSubset && !isValueSubset) {
        return {
            comparedName: lastChainOperand.comparedName,
            comparisonValue: lastChainOperand.comparisonValue,
            isSubset: true,
            isYoda: false,
        };
    }
    if (!isNameSubset && isValueSubset) {
        return {
            comparedName: lastChainOperand.comparisonValue,
            comparisonValue: lastChainOperand.comparedName,
            isSubset: true,
            isYoda: true,
        };
    }
    return {
        comparedName: lastChainOperand.comparisonValue,
        comparisonValue: lastChainOperand.comparisonValue,
        isSubset: false,
        isYoda: true,
    };
};
/**
 * Returns the range that needs to be reported from the chain.
 * @param chain The chain of logical expressions.
 * @param boundary The boundary range that the range to report cannot fall outside.
 * @param sourceCode The source code to get tokens.
 * @returns The range to report.
 */
function getReportRange(chain, boundary, sourceCode) {
    const leftNode = chain[0].node;
    const rightNode = chain[chain.length - 1].node;
    let leftMost = (0, util_1.nullThrows)(sourceCode.getFirstToken(leftNode), util_1.NullThrowsReasons.MissingToken('any token', leftNode.type));
    let rightMost = (0, util_1.nullThrows)(sourceCode.getLastToken(rightNode), util_1.NullThrowsReasons.MissingToken('any token', rightNode.type));
    while (leftMost.range[0] > boundary[0]) {
        const token = sourceCode.getTokenBefore(leftMost);
        if (!token || !(0, util_1.isOpeningParenToken)(token) || token.range[0] < boundary[0]) {
            break;
        }
        leftMost = token;
    }
    while (rightMost.range[1] < boundary[1]) {
        const token = sourceCode.getTokenAfter(rightMost);
        if (!token || !(0, util_1.isClosingParenToken)(token) || token.range[1] > boundary[1]) {
            break;
        }
        rightMost = token;
    }
    return [leftMost.range[0], rightMost.range[1]];
}
function getReportDescriptor(sourceCode, parserServices, node, operator, options, subChain, lastChain) {
    const chain = lastChain ? [...subChain, lastChain] : subChain;
    const lastOperand = chain[chain.length - 1];
    let useSuggestionFixer;
    if (options.allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing ===
        true) {
        // user has opted-in to the unsafe behavior
        useSuggestionFixer = false;
    }
    // optional chain specifically will union `undefined` into the final type
    // so we need to make sure that there is at least one operand that includes
    // `undefined`, or else we're going to change the final type - which is
    // unsafe and might cause downstream type errors.
    else if (lastChain ||
        lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.EqualNullOrUndefined ||
        lastOperand.comparisonType ===
            gatherLogicalOperands_1.NullishComparisonType.NotEqualNullOrUndefined ||
        lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined ||
        lastOperand.comparisonType ===
            gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined ||
        (operator === '||' &&
            lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.NotBoolean)) {
        // we know the last operand is an equality check - so the change in types
        // DOES NOT matter and will not change the runtime result or cause a type
        // check error
        useSuggestionFixer = false;
    }
    else {
        useSuggestionFixer = true;
        for (const operand of chain) {
            if (includesType(parserServices, operand.node, ts.TypeFlags.Undefined)) {
                useSuggestionFixer = false;
                break;
            }
        }
        // TODO - we could further reduce the false-positive rate of this check by
        //        checking for cases where the change in types don't matter like
        //        the test location of an if/while/etc statement.
        //        but it's quite complex to do this without false-negatives, so
        //        for now we'll just be over-eager with our matching.
        //
        //        it's MUCH better to false-positive here and only provide a
        //        suggestion fixer, rather than false-negative and autofix to
        //        broken code.
    }
    // In its most naive form we could just slap `?.` for every single part of the
    // chain. However this would be undesirable because it'd create unnecessary
    // conditions in the user's code where there were none before - and it would
    // cause errors with rules like our `no-unnecessary-condition`.
    //
    // Instead we want to include the minimum number of `?.` required to correctly
    // unify the code into a single chain. Naively you might think that we can
    // just take the final operand add `?.` after the locations from the previous
    // operands - however this won't be correct either because earlier operands
    // can include a necessary `?.` that's not needed or included in a later
    // operand.
    //
    // So instead what we need to do is to start at the first operand and
    // iteratively diff it against the next operand, and add the difference to the
    // first operand.
    //
    // eg
    // `foo && foo.bar && foo.bar.baz?.bam && foo.bar.baz.bam()`
    // 1) `foo`
    // 2) diff(`foo`, `foo.bar`) = `.bar`
    // 3) result = `foo?.bar`
    // 4) diff(`foo.bar`, `foo.bar.baz?.bam`) = `.baz?.bam`
    // 5) result = `foo?.bar?.baz?.bam`
    // 6) diff(`foo.bar.baz?.bam`, `foo.bar.baz.bam()`) = `()`
    // 7) result = `foo?.bar?.baz?.bam?.()`
    const parts = [];
    for (const current of chain) {
        const nextOperand = flattenChainExpression(sourceCode, current.comparedName);
        const diff = nextOperand.slice(parts.length);
        if (diff.length > 0) {
            if (parts.length > 0) {
                // we need to make the first operand of the diff optional so it matches the
                // logic before merging
                // foo.bar && foo.bar.baz
                // diff = .baz
                // result = foo.bar?.baz
                diff[0].optional = true;
            }
            parts.push(...diff);
        }
    }
    let newCode = parts
        .map(part => {
        let str = '';
        if (part.optional) {
            str += '?.';
        }
        else {
            if (part.nonNull) {
                str += '!';
            }
            if (part.requiresDot) {
                str += '.';
            }
        }
        if (part.precedence !== util_1.OperatorPrecedence.Invalid &&
            part.precedence < util_1.OperatorPrecedence.Member) {
            str += `(${part.text})`;
        }
        else {
            str += part.text;
        }
        return str;
    })
        .join('');
    if (lastOperand.node.type === utils_1.AST_NODE_TYPES.BinaryExpression) {
        // retain the ending comparison for cases like
        // x && x.a != null
        // x && typeof x.a !== 'undefined'
        const operator = lastOperand.node.operator;
        const { left, right } = (() => {
            if (lastOperand.isYoda) {
                const unaryOperator = lastOperand.node.right.type === utils_1.AST_NODE_TYPES.UnaryExpression
                    ? `${lastOperand.node.right.operator} `
                    : '';
                return {
                    left: sourceCode.getText(lastOperand.node.left),
                    right: unaryOperator + newCode,
                };
            }
            const unaryOperator = lastOperand.node.left.type === utils_1.AST_NODE_TYPES.UnaryExpression
                ? `${lastOperand.node.left.operator} `
                : '';
            return {
                left: unaryOperator + newCode,
                right: sourceCode.getText(lastOperand.node.right),
            };
        })();
        newCode = `${left} ${operator} ${right}`;
    }
    else if (lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.NotBoolean) {
        newCode = `!${newCode}`;
    }
    const reportRange = getReportRange(chain, node.range, sourceCode);
    const fix = fixer => fixer.replaceTextRange(reportRange, newCode);
    return {
        loc: {
            end: sourceCode.getLocFromIndex(reportRange[1]),
            start: sourceCode.getLocFromIndex(reportRange[0]),
        },
        messageId: 'preferOptionalChain',
        ...(0, util_1.getFixOrSuggest)({
            fixOrSuggest: useSuggestionFixer ? 'suggest' : 'fix',
            suggestion: {
                fix,
                messageId: 'optionalChainSuggest',
            },
        }),
    };
    function flattenChainExpression(sourceCode, node) {
        switch (node.type) {
            case utils_1.AST_NODE_TYPES.ChainExpression:
                return flattenChainExpression(sourceCode, node.expression);
            case utils_1.AST_NODE_TYPES.CallExpression: {
                const argumentsText = (() => {
                    const closingParenToken = (0, util_1.nullThrows)(sourceCode.getLastToken(node), util_1.NullThrowsReasons.MissingToken('closing parenthesis', node.type));
                    const openingParenToken = (0, util_1.nullThrows)(sourceCode.getFirstTokenBetween(node.typeArguments ?? node.callee, closingParenToken, util_1.isOpeningParenToken), util_1.NullThrowsReasons.MissingToken('opening parenthesis', node.type));
                    return sourceCode.text.substring(openingParenToken.range[0], closingParenToken.range[1]);
                })();
                const typeArgumentsText = (() => {
                    if (node.typeArguments == null) {
                        return '';
                    }
                    return sourceCode.getText(node.typeArguments);
                })();
                return [
                    ...flattenChainExpression(sourceCode, node.callee),
                    {
                        nonNull: false,
                        optional: node.optional,
                        // no precedence for this
                        precedence: util_1.OperatorPrecedence.Invalid,
                        requiresDot: false,
                        text: typeArgumentsText + argumentsText,
                    },
                ];
            }
            case utils_1.AST_NODE_TYPES.MemberExpression: {
                const propertyText = sourceCode.getText(node.property);
                return [
                    ...flattenChainExpression(sourceCode, node.object),
                    {
                        nonNull: node.object.type === utils_1.AST_NODE_TYPES.TSNonNullExpression,
                        optional: node.optional,
                        precedence: node.computed
                            ? // computed is already wrapped in [] so no need to wrap in () as well
                                util_1.OperatorPrecedence.Invalid
                            : (0, util_1.getOperatorPrecedenceForNode)(node.property),
                        requiresDot: !node.computed,
                        text: node.computed ? `[${propertyText}]` : propertyText,
                    },
                ];
            }
            case utils_1.AST_NODE_TYPES.TSNonNullExpression:
                return flattenChainExpression(sourceCode, node.expression);
            default:
                return [
                    {
                        nonNull: false,
                        optional: false,
                        precedence: (0, util_1.getOperatorPrecedenceForNode)(node),
                        requiresDot: false,
                        text: sourceCode.getText(node),
                    },
                ];
        }
    }
}
function analyzeChain(context, parserServices, options, node, operator, chain, lastChainOperand) {
    // need at least 2 operands in a chain for it to be a chain
    if (chain.length + (lastChainOperand ? 1 : 0) <= 1 ||
        /* istanbul ignore next -- previous checks make this unreachable, but keep it for exhaustiveness check */
        operator === '??') {
        return;
    }
    const analyzeOperand = (() => {
        switch (operator) {
            case '&&':
                return analyzeAndChainOperand;
            case '||':
                return analyzeOrChainOperand;
        }
    })();
    // Things like x !== null && x !== undefined have two nodes, but they are
    // one logical unit here, so we'll allow them to be grouped.
    let subChain = [];
    let lastChain = undefined;
    const maybeReportThenReset = (newChainSeed) => {
        if (subChain.length + (lastChain ? 1 : 0) > 1) {
            const subChainFlat = subChain.flat();
            const maybeNullishNodes = lastChain
                ? subChainFlat.map(({ node }) => node)
                : subChainFlat.slice(0, -1).map(({ node }) => node);
            (0, checkNullishAndReport_1.checkNullishAndReport)(context, parserServices, options, maybeNullishNodes, getReportDescriptor(context.sourceCode, parserServices, node, operator, options, subChainFlat, lastChain));
        }
        // we've reached the end of a chain of logical expressions
        // i.e. the current operand doesn't belong to the previous chain.
        //
        // we don't want to throw away the current operand otherwise we will skip it
        // and that can cause us to miss chains. So instead we seed the new chain
        // with the current operand
        //
        // eg this means we can catch cases like:
        //     unrelated != null && foo != null && foo.bar != null;
        //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ first "chain"
        //                          ^^^^^^^^^^^ newChainSeed
        //                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ second chain
        subChain = newChainSeed ? [newChainSeed] : [];
        lastChain = undefined;
    };
    for (let i = 0; i < chain.length; i += 1) {
        const lastOperand = subChain.flat().at(-1);
        const operand = chain[i];
        const validatedOperands = analyzeOperand(parserServices, operand, i, chain);
        if (!validatedOperands) {
            // TODO - #7170
            // check if the name is a superset/equal - if it is, then it likely
            // intended to be part of the chain and something we should include in the
            // report, eg
            //     foo == null || foo.bar;
            //     ^^^^^^^^^^^ valid OR chain
            //                    ^^^^^^^ invalid OR chain logical, but still part of
            //                            the chain for combination purposes
            if (lastOperand) {
                const comparisonResult = (0, compareNodes_1.compareNodes)(lastOperand.comparedName, operand.comparedName);
                switch (operand.comparisonType) {
                    case gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined:
                    case gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined: {
                        if (comparisonResult === compareNodes_1.NodeComparisonResult.Subset) {
                            lastChain = operand;
                        }
                        break;
                    }
                }
            }
            maybeReportThenReset();
            continue;
        }
        // in case multiple operands were consumed - make sure to correctly increment the index
        i += validatedOperands.length - 1;
        const currentOperand = validatedOperands[0];
        if (lastOperand) {
            const comparisonResult = (0, compareNodes_1.compareNodes)(lastOperand.comparedName, 
            // purposely inspect and push the last operand because the prior operands don't matter
            // this also means we won't false-positive in cases like
            // foo !== null && foo !== undefined
            validatedOperands[validatedOperands.length - 1].comparedName);
            if (comparisonResult === compareNodes_1.NodeComparisonResult.Subset) {
                // the operands are comparable, so we can continue searching
                subChain.push(currentOperand);
            }
            else if (comparisonResult === compareNodes_1.NodeComparisonResult.Invalid) {
                maybeReportThenReset(validatedOperands);
            }
            else {
                // purposely don't push this case because the node is a no-op and if
                // we consider it then we might report on things like
                // foo && foo
            }
        }
        else {
            subChain.push(currentOperand);
        }
    }
    const lastOperand = subChain.flat().at(-1);
    if (lastOperand && lastChainOperand) {
        const isValidLastChainOperand = operator === '&&'
            ? isValidAndLastChainOperand
            : isValidOrLastChainOperand;
        const { comparedName, comparisonValue, isSubset, isYoda } = resolveOperandSubset(lastOperand, lastChainOperand);
        if (isSubset &&
            isValidLastChainOperand(comparisonValue, lastChainOperand.comparisonType, parserServices)) {
            lastChain = {
                ...lastChainOperand,
                comparedName,
                comparisonValue,
                isYoda,
            };
        }
    }
    // check the leftovers
    maybeReportThenReset();
}


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\checkNullishAndReport.d.ts
--------------------------------------------------------------------------------

import type { ParserServicesWithTypeInformation, TSESTree } from '@typescript-eslint/utils';
import type { ReportDescriptor, RuleContext } from '@typescript-eslint/utils/ts-eslint';
import type { PreferOptionalChainMessageIds, PreferOptionalChainOptions } from './PreferOptionalChainOptions';
export declare function checkNullishAndReport(context: RuleContext<PreferOptionalChainMessageIds, [
    PreferOptionalChainOptions
]>, parserServices: ParserServicesWithTypeInformation, { requireNullish }: PreferOptionalChainOptions, maybeNullishNodes: TSESTree.Expression[], descriptor: ReportDescriptor<PreferOptionalChainMessageIds>): void;


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\checkNullishAndReport.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkNullishAndReport = checkNullishAndReport;
const type_utils_1 = require("@typescript-eslint/type-utils");
const ts_api_utils_1 = require("ts-api-utils");
const ts = __importStar(require("typescript"));
function checkNullishAndReport(context, parserServices, { requireNullish }, maybeNullishNodes, descriptor) {
    if (!requireNullish ||
        maybeNullishNodes.some(node => (0, ts_api_utils_1.unionConstituents)(parserServices.getTypeAtLocation(node)).some(t => (0, type_utils_1.isTypeFlagSet)(t, ts.TypeFlags.Null | ts.TypeFlags.Undefined)))) {
        context.report(descriptor);
    }
}


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\compareNodes.d.ts
--------------------------------------------------------------------------------

import type { TSESTree } from '@typescript-eslint/utils';
export declare const enum NodeComparisonResult {
    /** the two nodes are comparably the same */
    Equal = "Equal",
    /** the left node is a subset of the right node */
    Subset = "Subset",
    /** the left node is not the same or is a superset of the right node */
    Invalid = "Invalid"
}
type CompareNodesArgument = TSESTree.Node | null | undefined;
/**
 * Compares two nodes' ASTs to determine if the A is equal to or a subset of B
 */
export declare function compareNodes(nodeA: CompareNodesArgument, nodeB: CompareNodesArgument): NodeComparisonResult;
export {};


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\compareNodes.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeComparisonResult = void 0;
exports.compareNodes = compareNodes;
const utils_1 = require("@typescript-eslint/utils");
const visitor_keys_1 = require("@typescript-eslint/visitor-keys");
var NodeComparisonResult;
(function (NodeComparisonResult) {
    /** the two nodes are comparably the same */
    NodeComparisonResult["Equal"] = "Equal";
    /** the left node is a subset of the right node */
    NodeComparisonResult["Subset"] = "Subset";
    /** the left node is not the same or is a superset of the right node */
    NodeComparisonResult["Invalid"] = "Invalid";
})(NodeComparisonResult || (exports.NodeComparisonResult = NodeComparisonResult = {}));
function compareArrays(arrayA, arrayB) {
    if (arrayA.length !== arrayB.length) {
        return NodeComparisonResult.Invalid;
    }
    const result = arrayA.every((elA, idx) => {
        const elB = arrayB[idx];
        if (elA == null || elB == null) {
            return elA === elB;
        }
        return compareUnknownValues(elA, elB) === NodeComparisonResult.Equal;
    });
    if (result) {
        return NodeComparisonResult.Equal;
    }
    return NodeComparisonResult.Invalid;
}
function isValidNode(x) {
    return (typeof x === 'object' &&
        x != null &&
        'type' in x &&
        typeof x.type === 'string');
}
function isValidChainExpressionToLookThrough(node) {
    return (!(node.parent?.type === utils_1.AST_NODE_TYPES.MemberExpression &&
        node.parent.object === node) &&
        !(node.parent?.type === utils_1.AST_NODE_TYPES.CallExpression &&
            node.parent.callee === node) &&
        node.type === utils_1.AST_NODE_TYPES.ChainExpression);
}
function compareUnknownValues(valueA, valueB) {
    /* istanbul ignore if -- not possible for us to test this - it's just a sanity safeguard */
    if (valueA == null || valueB == null) {
        if (valueA !== valueB) {
            return NodeComparisonResult.Invalid;
        }
        return NodeComparisonResult.Equal;
    }
    /* istanbul ignore if -- not possible for us to test this - it's just a sanity safeguard */
    if (!isValidNode(valueA) || !isValidNode(valueB)) {
        return NodeComparisonResult.Invalid;
    }
    return compareNodes(valueA, valueB);
}
function compareByVisiting(nodeA, nodeB) {
    const currentVisitorKeys = visitor_keys_1.visitorKeys[nodeA.type];
    /* istanbul ignore if -- not possible for us to test this - it's just a sanity safeguard */
    if (currentVisitorKeys == null) {
        // we don't know how to visit this node, so assume it's invalid to avoid false-positives / broken fixers
        return NodeComparisonResult.Invalid;
    }
    if (currentVisitorKeys.length === 0) {
        // assume nodes with no keys are constant things like keywords
        return NodeComparisonResult.Equal;
    }
    for (const key of currentVisitorKeys) {
        // @ts-expect-error - dynamic access but it's safe
        const nodeAChildOrChildren = nodeA[key];
        // @ts-expect-error - dynamic access but it's safe
        const nodeBChildOrChildren = nodeB[key];
        if (Array.isArray(nodeAChildOrChildren)) {
            const arrayA = nodeAChildOrChildren;
            const arrayB = nodeBChildOrChildren;
            const result = compareArrays(arrayA, arrayB);
            if (result !== NodeComparisonResult.Equal) {
                return NodeComparisonResult.Invalid;
            }
            // fallthrough to the next key as the key was "equal"
        }
        else {
            const result = compareUnknownValues(nodeAChildOrChildren, nodeBChildOrChildren);
            if (result !== NodeComparisonResult.Equal) {
                return NodeComparisonResult.Invalid;
            }
            // fallthrough to the next key as the key was "equal"
        }
    }
    return NodeComparisonResult.Equal;
}
function compareNodesUncached(nodeA, nodeB) {
    if (nodeA.type !== nodeB.type) {
        // special cases where nodes are allowed to be non-equal
        // look through a chain expression node at the top-level because it only
        // exists to delimit the end of an optional chain
        //
        // a?.b && a.b.c
        // ^^^^ ChainExpression, MemberExpression
        //         ^^^^^ MemberExpression
        //
        // except for in this class of cases
        // (a?.b).c && a.b.c
        // because the parentheses have runtime meaning (sad face)
        if (isValidChainExpressionToLookThrough(nodeA)) {
            return compareNodes(nodeA.expression, nodeB);
        }
        if (isValidChainExpressionToLookThrough(nodeB)) {
            return compareNodes(nodeA, nodeB.expression);
        }
        // look through the type-only non-null assertion because its existence could
        // possibly be replaced by an optional chain instead
        //
        // a.b! && a.b.c
        // ^^^^ TSNonNullExpression
        if (nodeA.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {
            return compareNodes(nodeA.expression, nodeB);
        }
        if (nodeB.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {
            return compareNodes(nodeA, nodeB.expression);
        }
        // special case for subset optional chains where the node types don't match,
        // but we want to try comparing by discarding the "extra" code
        //
        // a && a.b
        //      ^ compare this
        // a && a()
        //      ^ compare this
        // a.b && a.b()
        //        ^^^ compare this
        // a() && a().b
        //        ^^^ compare this
        // import.meta && import.meta.b
        //                ^^^^^^^^^^^ compare this
        if (nodeA.type === utils_1.AST_NODE_TYPES.CallExpression ||
            nodeA.type === utils_1.AST_NODE_TYPES.Identifier ||
            nodeA.type === utils_1.AST_NODE_TYPES.MemberExpression ||
            nodeA.type === utils_1.AST_NODE_TYPES.MetaProperty) {
            switch (nodeB.type) {
                case utils_1.AST_NODE_TYPES.MemberExpression:
                    if (nodeB.property.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                        // Private identifiers in optional chaining is not currently allowed
                        // TODO - handle this once TS supports it (https://github.com/microsoft/TypeScript/issues/42734)
                        return NodeComparisonResult.Invalid;
                    }
                    if (compareNodes(nodeA, nodeB.object) !== NodeComparisonResult.Invalid) {
                        return NodeComparisonResult.Subset;
                    }
                    return NodeComparisonResult.Invalid;
                case utils_1.AST_NODE_TYPES.CallExpression:
                    if (compareNodes(nodeA, nodeB.callee) !== NodeComparisonResult.Invalid) {
                        return NodeComparisonResult.Subset;
                    }
                    return NodeComparisonResult.Invalid;
                default:
                    return NodeComparisonResult.Invalid;
            }
        }
        return NodeComparisonResult.Invalid;
    }
    switch (nodeA.type) {
        // these expressions create a new instance each time - so it makes no sense to compare the chain
        case utils_1.AST_NODE_TYPES.ArrayExpression:
        case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
        case utils_1.AST_NODE_TYPES.ClassExpression:
        case utils_1.AST_NODE_TYPES.FunctionExpression:
        case utils_1.AST_NODE_TYPES.JSXElement:
        case utils_1.AST_NODE_TYPES.JSXFragment:
        case utils_1.AST_NODE_TYPES.NewExpression:
        case utils_1.AST_NODE_TYPES.ObjectExpression:
            return NodeComparisonResult.Invalid;
        // chaining from assignments could change the value irrevocably - so it makes no sense to compare the chain
        case utils_1.AST_NODE_TYPES.AssignmentExpression:
            return NodeComparisonResult.Invalid;
        case utils_1.AST_NODE_TYPES.CallExpression: {
            const nodeBCall = nodeB;
            // check for cases like
            // foo() && foo()(bar)
            // ^^^^^ nodeA
            //          ^^^^^^^^^^ nodeB
            // we don't want to check the arguments in this case
            const aSubsetOfB = compareNodes(nodeA, nodeBCall.callee);
            if (aSubsetOfB !== NodeComparisonResult.Invalid) {
                return NodeComparisonResult.Subset;
            }
            const calleeCompare = compareNodes(nodeA.callee, nodeBCall.callee);
            if (calleeCompare !== NodeComparisonResult.Equal) {
                return NodeComparisonResult.Invalid;
            }
            // NOTE - we purposely ignore optional flag because for our purposes
            // foo?.bar() && foo.bar?.()?.baz
            // or
            // foo.bar() && foo?.bar?.()?.baz
            // are going to be exactly the same
            const argumentCompare = compareArrays(nodeA.arguments, nodeBCall.arguments);
            if (argumentCompare !== NodeComparisonResult.Equal) {
                return NodeComparisonResult.Invalid;
            }
            const typeParamCompare = compareNodes(nodeA.typeArguments, nodeBCall.typeArguments);
            if (typeParamCompare === NodeComparisonResult.Equal) {
                return NodeComparisonResult.Equal;
            }
            return NodeComparisonResult.Invalid;
        }
        case utils_1.AST_NODE_TYPES.ChainExpression:
            // special case handling for ChainExpression because it's allowed to be a subset
            return compareNodes(nodeA, nodeB.expression);
        case utils_1.AST_NODE_TYPES.Identifier:
        case utils_1.AST_NODE_TYPES.PrivateIdentifier:
            if (nodeA.name === nodeB.name) {
                return NodeComparisonResult.Equal;
            }
            return NodeComparisonResult.Invalid;
        case utils_1.AST_NODE_TYPES.Literal: {
            const nodeBLiteral = nodeB;
            if (nodeA.raw === nodeBLiteral.raw &&
                nodeA.value === nodeBLiteral.value) {
                return NodeComparisonResult.Equal;
            }
            return NodeComparisonResult.Invalid;
        }
        case utils_1.AST_NODE_TYPES.MemberExpression: {
            const nodeBMember = nodeB;
            if (nodeBMember.property.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                // Private identifiers in optional chaining is not currently allowed
                // TODO - handle this once TS supports it (https://github.com/microsoft/TypeScript/issues/42734)
                return NodeComparisonResult.Invalid;
            }
            // check for cases like
            // foo.bar && foo.bar.baz
            // ^^^^^^^ nodeA
            //            ^^^^^^^^^^^ nodeB
            // result === Equal
            //
            // foo.bar && foo.bar.baz.bam
            // ^^^^^^^ nodeA
            //            ^^^^^^^^^^^^^^^ nodeB
            // result === Subset
            //
            // we don't want to check the property in this case
            const aSubsetOfB = compareNodes(nodeA, nodeBMember.object);
            if (aSubsetOfB !== NodeComparisonResult.Invalid) {
                return NodeComparisonResult.Subset;
            }
            if (nodeA.computed !== nodeBMember.computed) {
                return NodeComparisonResult.Invalid;
            }
            // NOTE - we purposely ignore optional flag because for our purposes
            // foo?.bar && foo.bar?.baz
            // or
            // foo.bar && foo?.bar?.baz
            // are going to be exactly the same
            const objectCompare = compareNodes(nodeA.object, nodeBMember.object);
            if (objectCompare !== NodeComparisonResult.Equal) {
                return NodeComparisonResult.Invalid;
            }
            return compareNodes(nodeA.property, nodeBMember.property);
        }
        case utils_1.AST_NODE_TYPES.TSTemplateLiteralType:
        case utils_1.AST_NODE_TYPES.TemplateLiteral: {
            const nodeBTemplate = nodeB;
            const areQuasisEqual = nodeA.quasis.length === nodeBTemplate.quasis.length &&
                nodeA.quasis.every((elA, idx) => {
                    const elB = nodeBTemplate.quasis[idx];
                    return elA.value.cooked === elB.value.cooked;
                });
            if (!areQuasisEqual) {
                return NodeComparisonResult.Invalid;
            }
            return NodeComparisonResult.Equal;
        }
        case utils_1.AST_NODE_TYPES.TemplateElement: {
            const nodeBElement = nodeB;
            if (nodeA.value.cooked === nodeBElement.value.cooked) {
                return NodeComparisonResult.Equal;
            }
            return NodeComparisonResult.Invalid;
        }
        // these aren't actually valid expressions.
        // https://github.com/typescript-eslint/typescript-eslint/blob/20d7caee35ab84ae6381fdf04338c9e2b9e2bc48/packages/ast-spec/src/unions/Expression.ts#L37-L43
        case utils_1.AST_NODE_TYPES.ArrayPattern:
        case utils_1.AST_NODE_TYPES.ObjectPattern:
            /* istanbul ignore next */
            return NodeComparisonResult.Invalid;
        // update expression returns a number and also changes the value each time - so it makes no sense to compare the chain
        case utils_1.AST_NODE_TYPES.UpdateExpression:
            return NodeComparisonResult.Invalid;
        // yield returns the value passed to the `next` function, so it may not be the same each time - so it makes no sense to compare the chain
        case utils_1.AST_NODE_TYPES.YieldExpression:
            return NodeComparisonResult.Invalid;
        // general-case automatic handling of nodes to save us implementing every
        // single case by hand. This just iterates the visitor keys to recursively
        // check the children.
        //
        // Any specific logic cases or short-circuits should be listed as separate
        // cases so that they don't fall into this generic handling
        default:
            return compareByVisiting(nodeA, nodeB);
    }
}
const COMPARE_NODES_CACHE = new WeakMap();
/**
 * Compares two nodes' ASTs to determine if the A is equal to or a subset of B
 */
function compareNodes(nodeA, nodeB) {
    if (nodeA == null || nodeB == null) {
        if (nodeA !== nodeB) {
            return NodeComparisonResult.Invalid;
        }
        return NodeComparisonResult.Equal;
    }
    const cached = COMPARE_NODES_CACHE.get(nodeA)?.get(nodeB);
    if (cached) {
        return cached;
    }
    const result = compareNodesUncached(nodeA, nodeB);
    let mapA = COMPARE_NODES_CACHE.get(nodeA);
    if (mapA == null) {
        mapA = new WeakMap();
        COMPARE_NODES_CACHE.set(nodeA, mapA);
    }
    mapA.set(nodeB, result);
    return result;
}


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\gatherLogicalOperands.d.ts
--------------------------------------------------------------------------------

import type { ParserServicesWithTypeInformation, TSESTree } from '@typescript-eslint/utils';
import type { SourceCode } from '@typescript-eslint/utils/ts-eslint';
import type { PreferOptionalChainOptions } from './PreferOptionalChainOptions';
export declare const enum Yoda {
    Yes = 0,
    No = 1,
    Unknown = 2
}
export declare const enum OperandValidity {
    Valid = "Valid",
    Last = "Last",
    Invalid = "Invalid"
}
export declare const enum NullishComparisonType {
    /** `x != null`, `x != undefined` */
    NotEqualNullOrUndefined = "NotEqualNullOrUndefined",
    /** `x == null`, `x == undefined` */
    EqualNullOrUndefined = "EqualNullOrUndefined",
    /** `x !== null` */
    NotStrictEqualNull = "NotStrictEqualNull",
    /** `x === null` */
    StrictEqualNull = "StrictEqualNull",
    /** `x !== undefined`, `typeof x !== 'undefined'` */
    NotStrictEqualUndefined = "NotStrictEqualUndefined",
    /** `x === undefined`, `typeof x === 'undefined'` */
    StrictEqualUndefined = "StrictEqualUndefined",
    /** `!x` */
    NotBoolean = "NotBoolean",
    /** `x` */
    Boolean = "Boolean"
}
export declare const enum ComparisonType {
    NotEqual = "NotEqual",
    Equal = "Equal",
    NotStrictEqual = "NotStrictEqual",
    StrictEqual = "StrictEqual"
}
export interface ValidOperand {
    comparedName: TSESTree.Node;
    comparisonType: NullishComparisonType;
    isYoda: boolean;
    node: TSESTree.Expression;
    type: OperandValidity.Valid;
}
export interface LastChainOperand {
    comparedName: TSESTree.Node;
    comparisonType: ComparisonType;
    comparisonValue: TSESTree.Node;
    yoda: Yoda;
    node: TSESTree.BinaryExpression;
    type: OperandValidity.Last;
}
export interface InvalidOperand {
    type: OperandValidity.Invalid;
}
type Operand = InvalidOperand | LastChainOperand | ValidOperand;
export declare function gatherLogicalOperands(node: TSESTree.LogicalExpression, parserServices: ParserServicesWithTypeInformation, sourceCode: Readonly<SourceCode>, options: PreferOptionalChainOptions): {
    newlySeenLogicals: Set<TSESTree.LogicalExpression>;
    operands: Operand[];
};
export {};


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\gatherLogicalOperands.js
--------------------------------------------------------------------------------

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComparisonType = exports.NullishComparisonType = exports.OperandValidity = exports.Yoda = void 0;
exports.gatherLogicalOperands = gatherLogicalOperands;
const utils_1 = require("@typescript-eslint/utils");
const ts_api_utils_1 = require("ts-api-utils");
const ts = __importStar(require("typescript"));
const util_1 = require("../../util");
var Yoda;
(function (Yoda) {
    Yoda[Yoda["Yes"] = 0] = "Yes";
    Yoda[Yoda["No"] = 1] = "No";
    Yoda[Yoda["Unknown"] = 2] = "Unknown";
})(Yoda || (exports.Yoda = Yoda = {}));
var ComparisonValueType;
(function (ComparisonValueType) {
    ComparisonValueType["Null"] = "Null";
    ComparisonValueType["Undefined"] = "Undefined";
    ComparisonValueType["UndefinedStringLiteral"] = "UndefinedStringLiteral";
})(ComparisonValueType || (ComparisonValueType = {}));
var OperandValidity;
(function (OperandValidity) {
    OperandValidity["Valid"] = "Valid";
    OperandValidity["Last"] = "Last";
    OperandValidity["Invalid"] = "Invalid";
})(OperandValidity || (exports.OperandValidity = OperandValidity = {}));
var NullishComparisonType;
(function (NullishComparisonType) {
    /** `x != null`, `x != undefined` */
    NullishComparisonType["NotEqualNullOrUndefined"] = "NotEqualNullOrUndefined";
    /** `x == null`, `x == undefined` */
    NullishComparisonType["EqualNullOrUndefined"] = "EqualNullOrUndefined";
    /** `x !== null` */
    NullishComparisonType["NotStrictEqualNull"] = "NotStrictEqualNull";
    /** `x === null` */
    NullishComparisonType["StrictEqualNull"] = "StrictEqualNull";
    /** `x !== undefined`, `typeof x !== 'undefined'` */
    NullishComparisonType["NotStrictEqualUndefined"] = "NotStrictEqualUndefined";
    /** `x === undefined`, `typeof x === 'undefined'` */
    NullishComparisonType["StrictEqualUndefined"] = "StrictEqualUndefined";
    /** `!x` */
    NullishComparisonType["NotBoolean"] = "NotBoolean";
    /** `x` */
    NullishComparisonType["Boolean"] = "Boolean";
})(NullishComparisonType || (exports.NullishComparisonType = NullishComparisonType = {}));
var ComparisonType;
(function (ComparisonType) {
    ComparisonType["NotEqual"] = "NotEqual";
    ComparisonType["Equal"] = "Equal";
    ComparisonType["NotStrictEqual"] = "NotStrictEqual";
    ComparisonType["StrictEqual"] = "StrictEqual";
})(ComparisonType || (exports.ComparisonType = ComparisonType = {}));
const NULLISH_FLAGS = ts.TypeFlags.Null | ts.TypeFlags.Undefined;
function isValidFalseBooleanCheckType(node, disallowFalseyLiteral, parserServices, options) {
    const type = parserServices.getTypeAtLocation(node);
    const types = (0, ts_api_utils_1.unionConstituents)(type);
    if (disallowFalseyLiteral &&
        /*
        ```
        declare const x: false | {a: string};
        x && x.a;
        !x || x.a;
        ```
    
        We don't want to consider these two cases because the boolean expression
        narrows out the non-nullish falsy cases - so converting the chain to `x?.a`
        would introduce a build error
        */ (types.some(t => (0, ts_api_utils_1.isBooleanLiteralType)(t) && t.intrinsicName === 'false') ||
            types.some(t => (0, ts_api_utils_1.isStringLiteralType)(t) && t.value === '') ||
            types.some(t => (0, ts_api_utils_1.isNumberLiteralType)(t) && t.value === 0) ||
            types.some(t => (0, ts_api_utils_1.isBigIntLiteralType)(t) && t.value.base10Value === '0'))) {
        return false;
    }
    let allowedFlags = NULLISH_FLAGS | ts.TypeFlags.Object;
    if (options.checkAny === true) {
        allowedFlags |= ts.TypeFlags.Any;
    }
    if (options.checkUnknown === true) {
        allowedFlags |= ts.TypeFlags.Unknown;
    }
    if (options.checkString === true) {
        allowedFlags |= ts.TypeFlags.StringLike;
    }
    if (options.checkNumber === true) {
        allowedFlags |= ts.TypeFlags.NumberLike;
    }
    if (options.checkBoolean === true) {
        allowedFlags |= ts.TypeFlags.BooleanLike;
    }
    if (options.checkBigInt === true) {
        allowedFlags |= ts.TypeFlags.BigIntLike;
    }
    return types.every(t => (0, util_1.isTypeFlagSet)(t, allowedFlags));
}
function gatherLogicalOperands(node, parserServices, sourceCode, options) {
    const result = [];
    const { newlySeenLogicals, operands } = flattenLogicalOperands(node);
    for (const operand of operands) {
        const areMoreOperands = operand !== operands.at(-1);
        switch (operand.type) {
            case utils_1.AST_NODE_TYPES.BinaryExpression: {
                // check for "yoda" style logical: null != x
                const { comparedExpression, comparedValue, isYoda } = (() => {
                    // non-yoda checks are by far the most common, so check for them first
                    const comparedValueRight = getComparisonValueType(operand.right);
                    if (comparedValueRight) {
                        return {
                            comparedExpression: operand.left,
                            comparedValue: comparedValueRight,
                            isYoda: false,
                        };
                    }
                    return {
                        comparedExpression: operand.right,
                        comparedValue: getComparisonValueType(operand.left),
                        isYoda: true,
                    };
                })();
                if (comparedValue === ComparisonValueType.UndefinedStringLiteral) {
                    if (comparedExpression.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                        comparedExpression.operator === 'typeof') {
                        const argument = comparedExpression.argument;
                        if (argument.type === utils_1.AST_NODE_TYPES.Identifier &&
                            // typeof window === 'undefined'
                            (0, util_1.isReferenceToGlobalFunction)(argument.name, argument, sourceCode)) {
                            result.push({ type: OperandValidity.Invalid });
                            continue;
                        }
                        // typeof x.y === 'undefined'
                        result.push({
                            comparedName: comparedExpression.argument,
                            comparisonType: operand.operator.startsWith('!')
                                ? NullishComparisonType.NotStrictEqualUndefined
                                : NullishComparisonType.StrictEqualUndefined,
                            isYoda,
                            node: operand,
                            type: OperandValidity.Valid,
                        });
                        continue;
                    }
                    // y === 'undefined'
                    result.push({ type: OperandValidity.Invalid });
                    continue;
                }
                if (operand.operator.startsWith('!') !== (node.operator === '||')) {
                    switch (operand.operator) {
                        case '!=':
                        case '==':
                            if (comparedValue === ComparisonValueType.Null ||
                                comparedValue === ComparisonValueType.Undefined) {
                                // x == null, x == undefined
                                result.push({
                                    comparedName: comparedExpression,
                                    comparisonType: operand.operator.startsWith('!')
                                        ? NullishComparisonType.NotEqualNullOrUndefined
                                        : NullishComparisonType.EqualNullOrUndefined,
                                    isYoda,
                                    node: operand,
                                    type: OperandValidity.Valid,
                                });
                                continue;
                            }
                            break;
                        case '!==':
                        case '===': {
                            const comparedName = comparedExpression;
                            switch (comparedValue) {
                                case ComparisonValueType.Null:
                                    result.push({
                                        comparedName,
                                        comparisonType: operand.operator.startsWith('!')
                                            ? NullishComparisonType.NotStrictEqualNull
                                            : NullishComparisonType.StrictEqualNull,
                                        isYoda,
                                        node: operand,
                                        type: OperandValidity.Valid,
                                    });
                                    continue;
                                case ComparisonValueType.Undefined:
                                    result.push({
                                        comparedName,
                                        comparisonType: operand.operator.startsWith('!')
                                            ? NullishComparisonType.NotStrictEqualUndefined
                                            : NullishComparisonType.StrictEqualUndefined,
                                        isYoda,
                                        node: operand,
                                        type: OperandValidity.Valid,
                                    });
                                    continue;
                            }
                        }
                    }
                }
                // x == something :(
                // x === something :(
                // x != something :(
                // x !== something :(
                const binaryComparisonChain = getBinaryComparisonChain(operand);
                if (binaryComparisonChain) {
                    const { comparedName, comparedValue, yoda } = binaryComparisonChain;
                    switch (operand.operator) {
                        case '==':
                        case '===': {
                            const comparisonType = operand.operator === '=='
                                ? ComparisonType.Equal
                                : ComparisonType.StrictEqual;
                            result.push({
                                comparedName,
                                comparisonType,
                                comparisonValue: comparedValue,
                                node: operand,
                                type: OperandValidity.Last,
                                yoda,
                            });
                            continue;
                        }
                        case '!=':
                        case '!==': {
                            const comparisonType = operand.operator === '!='
                                ? ComparisonType.NotEqual
                                : ComparisonType.NotStrictEqual;
                            result.push({
                                comparedName,
                                comparisonType,
                                comparisonValue: comparedValue,
                                node: operand,
                                type: OperandValidity.Last,
                                yoda,
                            });
                            continue;
                        }
                    }
                }
                result.push({ type: OperandValidity.Invalid });
                continue;
            }
            case utils_1.AST_NODE_TYPES.UnaryExpression:
                if (operand.operator === '!' &&
                    (!areMoreOperands ||
                        isValidFalseBooleanCheckType(operand.argument, node.operator === '||', parserServices, options))) {
                    result.push({
                        comparedName: operand.argument,
                        comparisonType: NullishComparisonType.NotBoolean,
                        isYoda: false,
                        node: operand,
                        type: OperandValidity.Valid,
                    });
                    continue;
                }
                result.push({ type: OperandValidity.Invalid });
                continue;
            case utils_1.AST_NODE_TYPES.LogicalExpression:
                // explicitly ignore the mixed logical expression cases
                result.push({ type: OperandValidity.Invalid });
                continue;
            default:
                if (!areMoreOperands ||
                    isValidFalseBooleanCheckType(operand, node.operator === '&&', parserServices, options)) {
                    result.push({
                        comparedName: operand,
                        comparisonType: NullishComparisonType.Boolean,
                        isYoda: false,
                        node: operand,
                        type: OperandValidity.Valid,
                    });
                }
                else {
                    result.push({ type: OperandValidity.Invalid });
                }
                continue;
        }
    }
    return {
        newlySeenLogicals,
        operands: result,
    };
    /*
    The AST is always constructed such the first element is always the deepest element.
    I.e. for this code: `foo && foo.bar && foo.bar.baz && foo.bar.baz.buzz`
    The AST will look like this:
    {
      left: {
        left: {
          left: foo
          right: foo.bar
        }
        right: foo.bar.baz
      }
      right: foo.bar.baz.buzz
    }
  
    So given any logical expression, we can perform a depth-first traversal to get
    the operands in order.
  
    Note that this function purposely does not inspect mixed logical expressions
    like `foo || foo.bar && foo.bar.baz` - separate selector
    */
    function flattenLogicalOperands(node) {
        const operands = [];
        const newlySeenLogicals = new Set([node]);
        const stack = [node.right, node.left];
        let current;
        while ((current = stack.pop())) {
            if (current.type === utils_1.AST_NODE_TYPES.LogicalExpression &&
                current.operator === node.operator) {
                newlySeenLogicals.add(current);
                stack.push(current.right);
                stack.push(current.left);
            }
            else {
                operands.push(current);
            }
        }
        return {
            newlySeenLogicals,
            operands,
        };
    }
    function getComparisonValueType(node) {
        switch (node.type) {
            case utils_1.AST_NODE_TYPES.Literal:
                // eslint-disable-next-line eqeqeq, @typescript-eslint/internal/eqeq-nullish -- intentional exact comparison against null
                if (node.value === null && node.raw === 'null') {
                    return ComparisonValueType.Null;
                }
                if (node.value === 'undefined') {
                    return ComparisonValueType.UndefinedStringLiteral;
                }
                return null;
            case utils_1.AST_NODE_TYPES.Identifier:
                if (node.name === 'undefined') {
                    return ComparisonValueType.Undefined;
                }
                return null;
        }
        return null;
    }
    function isMemberBasedExpression(node) {
        if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {
            return true;
        }
        if (node.type === utils_1.AST_NODE_TYPES.CallExpression &&
            node.callee.type === utils_1.AST_NODE_TYPES.MemberExpression) {
            return true;
        }
        return false;
    }
    function getBinaryComparisonChain(node) {
        const { left, right } = node;
        const isLeftMemberExpression = isMemberBasedExpression(left);
        const isRightMemberExpression = isMemberBasedExpression(right);
        if (isLeftMemberExpression && !isRightMemberExpression) {
            const [comparedName, comparedValue] = [left, right];
            return {
                comparedName,
                comparedValue,
                yoda: Yoda.No,
            };
        }
        if (!isLeftMemberExpression && isRightMemberExpression) {
            const [comparedName, comparedValue] = [right, left];
            return {
                comparedName,
                comparedValue,
                yoda: Yoda.Yes,
            };
        }
        if (isLeftMemberExpression && isRightMemberExpression) {
            return {
                comparedName: left,
                comparedValue: right,
                yoda: Yoda.Unknown,
            };
        }
        return null;
    }
}


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\PreferOptionalChainOptions.d.ts
--------------------------------------------------------------------------------

export type PreferOptionalChainMessageIds = 'optionalChainSuggest' | 'preferOptionalChain';
export interface PreferOptionalChainOptions {
    allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing?: boolean;
    checkAny?: boolean;
    checkBigInt?: boolean;
    checkBoolean?: boolean;
    checkNumber?: boolean;
    checkString?: boolean;
    checkUnknown?: boolean;
    requireNullish?: boolean;
}


--------------------------------------------------------------------------------
FILE: prefer-optional-chain-utils\PreferOptionalChainOptions.js
--------------------------------------------------------------------------------

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

